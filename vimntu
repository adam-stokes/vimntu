#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Clone/PP.pm"} = <<'CLONE_PP';
  package Clone::PP;
  
  use strict;
  use vars qw($VERSION @EXPORT_OK);
  use Exporter;
  
  $VERSION = 1.02;
  
  @EXPORT_OK = qw( clone );
  sub import { goto &Exporter::import } # lazy Exporter
  
  # These methods can be temporarily overriden to work with a given class.
  use vars qw( $CloneSelfMethod $CloneInitMethod );
  $CloneSelfMethod ||= 'clone_self';
  $CloneInitMethod ||= 'clone_init';
  
  # Used to detect looped networks and avoid infinite recursion. 
  use vars qw( %CloneCache );
  
  # Generic cloning function
  sub clone {
    my $source = shift;
    
    # Optional depth limit: after a given number of levels, do shallow copy.
    my $depth = shift;
    return $source if ( defined $depth and $depth -- < 1 );
    
    # Maintain a shared cache during recursive calls, then clear it at the end.
    local %CloneCache = ( undef => undef ) unless ( exists $CloneCache{undef} );
    
    return $CloneCache{ $source } if ( exists $CloneCache{ $source } );
    
    # Non-reference values are copied shallowly
    my $ref_type = ref $source or return $source;
    
    # Extract both the structure type and the class name of referent
    my $class_name;
    if ( "$source" =~ /^\Q$ref_type\E\=([A-Z]+)\(0x[0-9a-f]+\)$/ ) {
      $class_name = $ref_type;
      $ref_type = $1;
      # Some objects would prefer to clone themselves; check for clone_self().
      return $CloneCache{ $source } = $source->$CloneSelfMethod() 
  				  if $source->can($CloneSelfMethod);
    }
    
    # To make a copy:
    # - Prepare a reference to the same type of structure;
    # - Store it in the cache, to avoid looping it it refers to itself;
    # - Tie in to the same class as the original, if it was tied;
    # - Assign a value to the reference by cloning each item in the original;
    
    my $copy;
    if ($ref_type eq 'HASH') {
      $CloneCache{ $source } = $copy = {};
      if ( my $tied = tied( %$source ) ) { tie %$copy, ref $tied }
      %$copy = map { ! ref($_) ? $_ : clone($_, $depth) } %$source;
    } elsif ($ref_type eq 'ARRAY') {
      $CloneCache{ $source } = $copy = [];
      if ( my $tied = tied( @$source ) ) { tie @$copy, ref $tied }
      @$copy = map { ! ref($_) ? $_ : clone($_, $depth) } @$source;
    } elsif ($ref_type eq 'REF' or $ref_type eq 'SCALAR') {
      $CloneCache{ $source } = $copy = \( my $var = "" );
      if ( my $tied = tied( $$source ) ) { tie $$copy, ref $tied }
      $$copy = clone($$source, $depth);
    } else {
      # Shallow copy anything else; this handles a reference to code, glob, regex
      $CloneCache{ $source } = $copy = $source;
    }
    
    # - Bless it into the same class as the original, if it was blessed;
    # - If it has a post-cloning initialization method, call it.
    if ( $class_name ) {
      bless $copy, $class_name;
      $copy->$CloneInitMethod() if $copy->can($CloneInitMethod);
    }
    
    return $copy;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Clone::PP - Recursively copy Perl datatypes
  
  =head1 SYNOPSIS
  
    use Clone::PP qw(clone);
    
    $item = { 'foo' => 'bar', 'move' => [ 'zig', 'zag' ]  };
    $copy = clone( $item );
  
    $item = [ 'alpha', 'beta', { 'gamma' => 'vlissides' } ];
    $copy = clone( $item );
  
    $item = Foo->new();
    $copy = clone( $item );
  
  Or as an object method:
  
    require Clone::PP;
    push @Foo::ISA, 'Clone::PP';
    
    $item = Foo->new();
    $copy = $item->clone();
  
  =head1 DESCRIPTION
  
  This module provides a general-purpose clone function to make deep
  copies of Perl data structures. It calls itself recursively to copy
  nested hash, array, scalar and reference types, including tied
  variables and objects.
  
  The clone() function takes a scalar argument to copy. To duplicate
  arrays or hashes, pass them in by reference:
  
    my $copy = clone(\@array);    my @copy = @{ clone(\@array) };
    my $copy = clone(\%hash);     my %copy = %{ clone(\%hash) };
  
  The clone() function also accepts an optional second parameter that
  can be used to limit the depth of the copy. If you pass a limit of
  0, clone will return the same value you supplied; for a limit of
  1, a shallow copy is constructed; for a limit of 2, two layers of
  copying are done, and so on.
  
    my $shallow_copy = clone( $item, 1 );
  
  To allow objects to intervene in the way they are copied, the
  clone() function checks for a couple of optional methods. If an
  object provides a method named C<clone_self>, it is called and the
  result returned without further processing. Alternately, if an
  object provides a method named C<clone_init>, it is called on the
  copied object before it is returned.
  
  =head1 BUGS
  
  Some data types, such as globs, regexes, and code refs, are always copied shallowly.
  
  References to hash elements are not properly duplicated. (This is why two tests in t/dclone.t that are marked "todo".) For example, the following test should succeed but does not:
  
    my $hash = { foo => 1 }; 
    $hash->{bar} = \{ $hash->{foo} }; 
    my $copy = clone( \%hash ); 
    $hash->{foo} = 2; 
    $copy->{foo} = 2; 
    ok( $hash->{bar} == $copy->{bar} );
  
  To report bugs via the CPAN web tracking system, go to 
  C<http://rt.cpan.org/NoAuth/Bugs.html?Dist=Clone-PP> or send mail 
  to C<Dist=Clone-PP#rt.cpan.org>, replacing C<#> with C<@>.
  
  =head1 SEE ALSO
  
  For a faster implementation in XS, see L<Clone/clone>, L<Util/clone>, or <Storable/dclone>.
  
  =head1 CREDITS AND COPYRIGHT
  
  Developed by Matthew Simon Cavalletto at Evolution Softworks. 
  More free Perl software is available at C<www.evoscript.org>.
  
  Copyright 2003 Matthew Simon Cavalletto. You may contact the author
  directly at C<evo@cpan.org> or C<simonm@cavalletto.org>.
  
  Code initially derived from Ref.pm. Portions Copyright 1994 David Muir Sharnoff.
  
  Interface based by Clone by Ray Finch with contributions from chocolateboy.
  Portions Copyright 2001 Ray Finch. Portions Copyright 2001 chocolateboy. 
  
  You may use, modify, and distribute this software under the same terms as Perl.
  
  =cut
CLONE_PP

$fatpacked{"DDP.pm"} = <<'DDP';
  package DDP;
  use strict;
  use warnings;
  use Data::Printer;
  
  BEGIN {
      push our @ISA, 'Data::Printer';
      our $VERSION = $Data::Printer::VERSION;
  }
  1;
  __END__
  
  =head1 NAME
  
  DDP - Data::Printer shortcut for faster debugging
  
  =head1 SYNOPSIS
  
    use DDP; p $my_data;
  
  =head1 DESCRIPTION
  
  Tired of typing C<use Data::Printer> every time? C<DDP> lets you quickly call
  your favorite variable dumper!
  
  It behaves exacly like L<Data::Printer> - it is, indeed, just an alias to it :)
  
  Happy debugging!
  
  =head1 SEE ALSO
  
  L<Data::Printer>
  
DDP

$fatpacked{"Data/Printer.pm"} = <<'DATA_PRINTER';
  package Data::Printer;
  use strict;
  use warnings;
  use Term::ANSIColor qw(color colored);
  use Scalar::Util;
  use Sort::Naturally;
  use Carp qw(croak);
  use Clone::PP qw(clone);
  use if $] >= 5.010, 'Hash::Util::FieldHash' => qw(fieldhash);
  use if $] < 5.010, 'Hash::Util::FieldHash::Compat' => qw(fieldhash);
  use File::Spec;
  use File::HomeDir ();
  use Fcntl;
  use version 0.77 ();
  
  our $VERSION = '0.35';
  
  BEGIN {
      if ($^O =~ /Win32/i) {
          require Win32::Console::ANSI;
          Win32::Console::ANSI->import;
      }
  }
  
  
  # defaults
  my $BREAK = "\n";
  my $properties = {
      'name'           => 'var',
      'indent'         => 4,
      'index'          => 1,
      'max_depth'      => 0,
      'multiline'      => 1,
      'sort_keys'      => 1,
      'deparse'        => 0,
      'hash_separator' => '   ',
      'separator'      => ',',
      'end_separator'  => 0,
      'show_tied'      => 1,
      'show_tainted'   => 1,
      'show_weak'      => 1,
      'show_readonly'  => 0,
      'show_lvalue'    => 1,
      'print_escapes'  => 0,
      'quote_keys'     => 'auto',
      'use_prototypes' => 1,
      'output'         => 'stderr',
      'return_value'   => 'dump',       # also 'void' or 'pass'
      'colored'        => 'auto',       # also 0 or 1
      'caller_info'    => 0,
      'caller_message' => 'Printing in line __LINE__ of __FILENAME__:',
      'class_method'   => '_data_printer', # use a specific dump method, if available
      'color'          => {
          'array'       => 'bright_white',
          'number'      => 'bright_blue',
          'string'      => 'bright_yellow',
          'class'       => 'bright_green',
          'method'      => 'bright_green',
          'undef'       => 'bright_red',
          'hash'        => 'magenta',
          'regex'       => 'yellow',
          'code'        => 'green',
          'glob'        => 'bright_cyan',
          'vstring'     => 'bright_blue',
          'lvalue'      => 'bright_white',
          'format'      => 'bright_cyan',
          'repeated'    => 'white on_red',
          'caller_info' => 'bright_cyan',
          'weak'        => 'cyan',
          'tainted'     => 'red',
          'escaped'     => 'bright_red',
          'unknown'     => 'bright_yellow on_blue',
      },
      'class' => {
          inherited    => 'none',   # also 'all', 'public' or 'private'
          universal    => 1,
          parents      => 1,
          linear_isa   => 'auto',
          expand       => 1,        # how many levels to expand. 0 for none, 'all' for all
          internals    => 1,
          export       => 1,
          sort_methods => 1,
          show_methods => 'all',    # also 'none', 'public', 'private'
          show_reftype => 0,
          _depth       => 0,        # used internally
      },
      'filters' => {
          # The IO ref type isn't supported as you can't actually create one,
          # any handle you make is automatically blessed into an IO::* object,
          # and those are separately handled.
          SCALAR  => [ \&SCALAR   ],
          ARRAY   => [ \&ARRAY    ],
          HASH    => [ \&HASH     ],
          REF     => [ \&REF      ],
          CODE    => [ \&CODE     ],
          GLOB    => [ \&GLOB     ],
          VSTRING => [ \&VSTRING  ],
          LVALUE  => [ \&LVALUE ],
          FORMAT  => [ \&FORMAT ],
          Regexp  => [ \&Regexp   ],
          -unknown=> [ \&_unknown ],
          -class  => [ \&_class   ],
      },
  
      _output          => *STDERR,     # used internally
      _current_indent  => 0,           # used internally
      _linebreak       => \$BREAK,     # used internally
      _seen            => {},          # used internally
      _seen_override   => {},          # used internally
      _depth           => 0,           # used internally
      _tie             => 0,           # used internally
  };
  
  
  sub import {
      my $class = shift;
      my $args;
      if (scalar @_) {
          $args = @_ == 1 ? shift : {@_};
          croak 'Data::Printer can receive either a hash or a hash reference.'
              unless ref $args and ref $args eq 'HASH';
      }
  
      # the RC file overrides the defaults,
      # (and we load it only once)
      unless( exists $properties->{_initialized} ) {
          _load_rc_file($args);
          $properties->{_initialized} = 1;
      }
  
      # and 'use' arguments override the RC file
      if ($args) {
          $properties = _merge( $args );
      }
  
      my $exported = ($properties->{use_prototypes} ? \&p : \&np );
      my $imported = $properties->{alias} || 'p';
      my $caller = caller;
      no strict 'refs';
      *{"$caller\::$imported"} = $exported;
  }
  
  
  sub p (\[@$%&];%) {
      return _print_and_return( $_[0], _data_printer(!!defined wantarray, @_) );
  }
  
  # np() is a p() clone without prototypes.
  # Just like regular Data::Dumper, this version
  # expects a reference as its first argument.
  # We make a single exception for when we only
  # get one argument, in which case we ref it
  # for the user and keep going.
  sub np  {
      my $item = shift;
  
      if (!ref $item && @_ == 0) {
          my $item_value = $item;
          $item = \$item_value;
      }
  
      return _print_and_return( $item, _data_printer(!!defined wantarray, $item, @_) );
  }
  
  sub _print_and_return {
      my ($item, $dump, $p) = @_;
  
      if ( $p->{return_value} eq 'pass' ) {
          print { $p->{_output} } $dump . $/;
  
          my $ref = ref $item;
          if ($ref eq 'ARRAY') {
              return @{ $item };
          }
          elsif ($ref eq 'HASH') {
              return %{ $item };
          }
          elsif ( grep { $ref eq $_ } qw(REF SCALAR CODE Regexp GLOB VSTRING) ) {
              return $$item;
          }
          else {
              return $item;
          }
      }
      elsif ( $p->{return_value} eq 'void' ) {
          print { $p->{_output} } $dump . $/;
          return;
      }
      else {
          print { $p->{_output} } $dump . $/ unless defined wantarray;
          return $dump;
      }
  }
  
  sub _data_printer {
      my $wantarray = shift;
  
      croak 'When calling p() without prototypes, please pass arguments as references'
          unless ref $_[0];
  
      my ($item, %local_properties) = @_;
      local %ENV = %ENV;
  
      my $p = _merge(\%local_properties);
      unless ($p->{multiline}) {
          $BREAK = ' ';
          $p->{'indent'} = 0;
          $p->{'index'}  = 0;
      }
  
      # We disable colors if colored is set to false.
      # If set to "auto", we disable colors if the user
      # set ANSI_COLORS_DISABLED or if we're either
      # returning the value (instead of printing) or
      # being piped to another command.
      if ( !$p->{colored}
            or ($p->{colored} eq 'auto'
                and (exists $ENV{ANSI_COLORS_DISABLED}
                     or $wantarray
                     or not -t $p->{_output}
                    )
            )
      ) {
          $ENV{ANSI_COLORS_DISABLED} = 1;
      }
      else {
          delete $ENV{ANSI_COLORS_DISABLED};
      }
  
      my $out = color('reset');
  
      if ( $p->{caller_info} and $p->{_depth} == 0 ) {
          $out .= _get_info_message($p);
      }
  
      $out .= _p( $item, $p );
      return ($out, $p);
  }
  
  
  sub _p {
      my ($item, $p) = @_;
      my $ref = (defined $p->{_reftype} ? $p->{_reftype} : ref $item);
      my $tie;
  
      my $string = '';
  
      # Object's unique ID, avoiding circular structures
      my $id = _object_id( $item );
      if ( exists $p->{_seen}->{$id} ) {
          if ( not defined $p->{_reftype} ) {
              return colored($p->{_seen}->{$id}, $p->{color}->{repeated});
          }
      }
      # some filters don't want us to show their repeated refs
      elsif( !exists $p->{_seen_override}{$ref} ) {
          $p->{_seen}->{$id} = $p->{name};
      }
  
      delete $p->{_reftype}; # abort override
  
      # globs don't play nice
      $ref = 'GLOB' if "$item" =~ /GLOB\([^()]+\)$/;
  
  
      # filter item (if user set a filter for it)
      my $found;
      if ( exists $p->{filters}->{$ref} ) {
          foreach my $filter ( @{ $p->{filters}->{$ref} } ) {
              if ( defined (my $result = $filter->($item, $p)) ) {
                  $string .= $result;
                  $found = 1;
                  last;
              }
          }
      }
  
      if (not $found and Scalar::Util::blessed($item) ) {
          # let '-class' filters have a go
          foreach my $filter ( @{ $p->{filters}->{'-class'} } ) {
              if ( defined (my $result = $filter->($item, $p)) ) {
                  $string .= $result;
                  $found = 1;
                  last;
              }
          }
      }
      
      if ( not $found ) {
          # if it's not a class and not a known core type, we must be in
          # a future perl with some type we're unaware of
          foreach my $filter ( @{ $p->{filters}->{'-unknown'} } ) {
              if ( defined (my $result = $filter->($item, $p)) ) {
                  $string .= $result;
                  last;
              }
          }
      }
  
      if ($p->{show_tied} and $p->{_tie} ) {
          $string .= ' (tied to ' . $p->{_tie} . ')';
          $p->{_tie} = '';
      }
  
      return $string;
  }
  
  
  
  ######################################
  ## Default filters
  ######################################
  
  sub SCALAR {
      my ($item, $p) = @_;
      my $string = '';
  
      if (not defined $$item) {
          $string .= colored('undef', $p->{color}->{'undef'});
      }
      elsif (Scalar::Util::looks_like_number($$item)) {
          $string .= colored($$item, $p->{color}->{'number'});
      }
      else {
          my $val = _escape_chars($$item, $p->{color}{string}, $p);
  
          $string .= q["] . colored($val, $p->{color}->{'string'}) . q["];
      }
  
      $string .= ' ' . colored('(TAINTED)', $p->{color}->{'tainted'})
          if $p->{show_tainted} and Scalar::Util::tainted($$item);
  
      $p->{_tie} = ref tied $$item;
  
      if ($p->{show_readonly} and &Internals::SvREADONLY( $item )) {
          $string .= ' (read-only)';
      }
  
      return $string;
  }
  
  sub _escape_chars {
      my ($str, $orig_color, $p) = @_;
  
      $orig_color   = color( $orig_color );
      my $esc_color = color( $p->{color}{escaped} );
  
      if ($p->{print_escapes}) {
          $str =~ s/\e/$esc_color\\e$orig_color/g;
  
          my %escaped = (
              "\n" => '\n',
              "\r" => '\r',
              "\t" => '\t',
              "\f" => '\f',
              "\b" => '\b',
              "\a" => '\a',
          );
          foreach my $k ( keys %escaped ) {
              $str =~ s/$k/$esc_color$escaped{$k}$orig_color/g;
          }
      }
      # always escape the null character
      $str =~ s/\0/$esc_color\\0$orig_color/g;
  
      return $str;
  }
  
  
  sub ARRAY {
      my ($item, $p) = @_;
      my $string = '';
      $p->{_depth}++;
  
      if ( $p->{max_depth} and $p->{_depth} > $p->{max_depth} ) {
          $string .= '[ ... ]';
      }
      elsif (not @$item) {
          $string .= '[]';
      }
      else {
          $string .= "[$BREAK";
          $p->{_current_indent} += $p->{indent};
  
          foreach my $i (0 .. $#{$item} ) {
              $p->{name} .= "[$i]";
  
              my $array_elem = $item->[$i];
              $string .= (' ' x $p->{_current_indent});
              if ($p->{'index'}) {
                  $string .= colored(
                               sprintf("%-*s", 3 + length($#{$item}), "[$i]"),
                               $p->{color}->{'array'}
                         );
              }
  
              my $ref = ref $array_elem;
  
              # scalar references should be re-referenced
              # to gain a '\' sign in front of them
              if (!$ref or $ref eq 'SCALAR') {
                  $string .= _p( \$array_elem, $p );
              }
              else {
                  $string .= _p( $array_elem, $p );
              }
              $string .= ' ' . colored('(weak)', $p->{color}->{'weak'})
                  if $ref and Scalar::Util::isweak($item->[$i]) and $p->{show_weak};
  
              $string .= $p->{separator}
                if $i < $#{$item} || $p->{end_separator};
  
              $string .= $BREAK;
  
              my $size = 2 + length($i); # [10], [100], etc
              substr $p->{name}, -$size, $size, '';
          }
          $p->{_current_indent} -= $p->{indent};
          $string .= (' ' x $p->{_current_indent}) . "]";
      }
  
      $p->{_tie} = ref tied @$item;
      $p->{_depth}--;
  
      return $string;
  }
  
  
  sub REF {
      my ($item, $p) = @_;
      my $string = '';
  
      # look-ahead, add a '\' only if it's not an object
      if (my $ref_ahead = ref $$item ) {
          $string .= '\\ ' if grep { $_ eq $ref_ahead }
              qw(SCALAR CODE Regexp ARRAY HASH GLOB REF);
      }
      $string .= _p($$item, $p);
  
      $string .= ' ' . colored('(weak)', $p->{color}->{'weak'})
          if Scalar::Util::isweak($$item) and $p->{show_weak};
  
      return $string;
  }
  
  
  sub CODE {
      my ($item, $p) = @_;
      my $string = '';
  
      my $code = 'sub { ... }';
      if ($p->{deparse}) {
          $code = _deparse( $item, $p );
      }
      $string .= colored($code, $p->{color}->{'code'});
      return $string;
  }
  
  
  sub HASH {
      my ($item, $p) = @_;
      my $string = '';
  
      $p->{_depth}++;
  
      if ( $p->{max_depth} and $p->{_depth} > $p->{max_depth} ) {
          $string .= '{ ... }';
      }
      elsif (not keys %$item) {
          $string .= '{}';
      }
      else {
          $string .= "{$BREAK";
          $p->{_current_indent} += $p->{indent};
  
          my $total_keys  = scalar keys %$item;
          my $len         = 0;
          my $multiline   = $p->{multiline};
          my $hash_color  = $p->{color}{hash};
          my $quote_keys  = $p->{quote_keys};
  
          my @keys = ();
  
          # first pass, preparing keys to display (and getting largest key size)
          foreach my $key ($p->{sort_keys} ? nsort keys %$item : keys %$item ) {
              my $new_key = _escape_chars($key, $hash_color, $p);
              my $colored = colored( $new_key, $hash_color );
  
              # wrap in uncolored single quotes if there's
              # any space or escaped characters
              if ( $quote_keys
                    and (
                          $quote_keys ne 'auto'
                          or (
                               $key eq q()
                               or $new_key ne $key
                               or $new_key =~ /\s|\n|\t|\r/
                          )
                    )
              ) {
                  $colored = qq['$colored'];
              }
  
              push @keys, {
                  raw     => $key,
                  colored => $colored,
              };
  
              # length of the largest key is used for indenting
              if ($multiline) {
                  my $l = length $colored;
                  $len = $l if $l > $len;
              }
          }
  
          # second pass, traversing and rendering
          foreach my $key (@keys) {
              my $raw_key     = $key->{raw};
              my $colored_key = $key->{colored};
              my $element     = $item->{$raw_key};
              $p->{name}     .= "{$raw_key}";
  
              $string .= (' ' x $p->{_current_indent})
                       . sprintf("%-*s", $len, $colored_key)
                       . $p->{hash_separator}
                       ;
  
              my $ref = ref $element;
              # scalar references should be re-referenced
              # to gain a '\' sign in front of them
              if (!$ref or $ref eq 'SCALAR') {
                  $string .= _p( \$element, $p );
              }
              else {
                  $string .= _p( $element, $p );
              }
  
              $string .= ' ' . colored('(weak)', $p->{color}->{'weak'})
                  if $ref
                    and $p->{show_weak}
                    and Scalar::Util::isweak($item->{$raw_key});
  
              $string .= $p->{separator}
                if --$total_keys > 0 || $p->{end_separator};
  
              $string .= $BREAK;
  
              my $size = 2 + length($raw_key); # {foo}, {z}, etc
              substr $p->{name}, -$size, $size, '';
          }
          $p->{_current_indent} -= $p->{indent};
          $string .= (' ' x $p->{_current_indent}) . "}";
      }
  
      $p->{_tie} = ref tied %$item;
      $p->{_depth}--;
  
      return $string;
  }
  
  
  sub Regexp {
      my ($item, $p) = @_;
      my $string = '';
  
      my $val = "$item";
      # a regex to parse a regex. Talk about full circle :)
      # note: we are not validating anything, just grabbing modifiers
      if ($val =~ m/\(\?\^?([uladxismpogce]*)(?:\-[uladxismpogce]+)?:(.*)\)/s) {
          my ($modifiers, $val) = ($1, $2);
          $string .= colored($val, $p->{color}->{'regex'});
          if ($modifiers) {
              $string .= "  (modifiers: $modifiers)";
          }
      }
      else {
          croak "Unrecognized regex $val. Please submit a bug report for Data::Printer.";
      }
      return $string;
  }
  
  sub VSTRING {
      my ($item, $p) = @_;
      my $string = '';
      $string .= colored(version->declare($$item)->normal, $p->{color}->{'vstring'});
      return $string;
  }
  
  sub FORMAT {
      my ($item, $p) = @_;
      my $string = '';
      $string .= colored("FORMAT", $p->{color}->{'format'});
      return $string;
  }
  
  sub LVALUE {
      my ($item, $p) = @_;
      my $string = SCALAR( $item, $p );
      $string .= colored( ' (LVALUE)', $p->{color}{lvalue} )
          if $p->{show_lvalue};
  
      return $string;
  }
  
  sub GLOB {
      my ($item, $p) = @_;
      my $string = '';
  
      $string .= colored("$$item", $p->{color}->{'glob'});
  
      my $extra = '';
  
      # unfortunately, some systems (like Win32) do not
      # implement some of these flags (maybe not even
      # fcntl() itself, so we must wrap it.
      my $flags;
      eval { no warnings qw( unopened closed ); $flags = fcntl($$item, F_GETFL, 0) };
      if ($flags) {
          $extra .= ($flags & O_WRONLY) ? 'write-only'
                  : ($flags & O_RDWR)   ? 'read/write'
                  : 'read-only'
                  ;
  
          # How to avoid croaking when the system
          # doesn't implement one of those, without skipping
          # the whole thing? Maybe there's a better way.
          # Solaris, for example, doesn't have O_ASYNC :(
          my %flags = ();
          eval { $flags{'append'}      = O_APPEND   };
          eval { $flags{'async'}       = O_ASYNC    }; # leont says this is the only one I should care for.
          eval { $flags{'create'}      = O_CREAT    };
          eval { $flags{'truncate'}    = O_TRUNC    };
          eval { $flags{'nonblocking'} = O_NONBLOCK };
  
          if (my @flags = grep { $flags & $flags{$_} } keys %flags) {
              $extra .= ", flags: @flags";
          }
          $extra .= ', ';
      }
      my @layers = ();
      eval { @layers = PerlIO::get_layers $$item }; # TODO: try PerlIO::Layers::get_layers (leont)
      unless ($@) {
          $extra .= "layers: @layers";
      }
      $string .= "  ($extra)" if $extra;
  
      $p->{_tie} = ref tied *$$item;
      return $string;
  }
  
  
  sub _unknown {
      my($item, $p) = @_;
      my $ref = ref $item;
      
      my $string = '';
      $string = colored($ref, $p->{color}->{'unknown'});
      return $string;
  }
  
  sub _class {
      my ($item, $p) = @_;
      my $ref = ref $item;
  
      # if the user specified a method to use instead, we do that
      if ( $p->{class_method} and my $method = $item->can($p->{class_method}) ) {
          return $method->($item, $p);
      }
  
      my $string = '';
      $p->{class}{_depth}++;
  
      $string .= colored($ref, $p->{color}->{'class'});
  
      if ( $p->{class}{show_reftype} ) {
          $string .= ' (' . colored(
              Scalar::Util::reftype($item),
              $p->{color}->{'class'}
          ) . ')';
      }
  
      if ($p->{class}{expand} eq 'all'
          or $p->{class}{expand} >= $p->{class}{_depth}
      ) {
          $string .= "  {$BREAK";
  
          $p->{_current_indent} += $p->{indent};
  
          if ($] >= 5.010) {
              require mro;
          } else {
              require MRO::Compat;
          }
          require Package::Stash;
  
          my $stash = Package::Stash->new($ref);
  
          if ( my @superclasses = @{$stash->get_symbol('@ISA')||[]} ) {
              if ($p->{class}{parents}) {
                  $string .= (' ' x $p->{_current_indent})
                          . 'Parents       '
                          . join(', ', map { colored($_, $p->{color}->{'class'}) }
                                       @superclasses
                          ) . $BREAK;
              }
  
              if ( $p->{class}{linear_isa} and
                    (
                      ($p->{class}{linear_isa} eq 'auto' and @superclasses > 1)
                      or
                      ($p->{class}{linear_isa} ne 'auto')
                    )
              ) {
                  $string .= (' ' x $p->{_current_indent})
                          . 'Linear @ISA   '
                          . join(', ', map { colored( $_, $p->{color}->{'class'}) }
                                    @{mro::get_linear_isa($ref)}
                          ) . $BREAK;
              }
          }
  
          $string .= _show_methods($ref, $p)
              if $p->{class}{show_methods} and $p->{class}{show_methods} ne 'none';
  
          if ( $p->{'class'}->{'internals'} ) {
              $string .= (' ' x $p->{_current_indent})
                      . 'internals: ';
  
              local $p->{_reftype} = Scalar::Util::reftype $item;
              $string .= _p($item, $p);
              $string .= $BREAK;
          }
  
          $p->{_current_indent} -= $p->{indent};
          $string .= (' ' x $p->{_current_indent}) . "}";
      }
      $p->{class}{_depth}--;
  
      return $string;
  }
  
  
  
  ######################################
  ## Auxiliary (internal) subs
  ######################################
  
  # All glory to Vincent Pit for coming up with this implementation,
  # to Goro Fuji for Hash::FieldHash, and of course to Michael Schwern
  # and his "Object::ID", whose code is copied almost verbatim below.
  {
      fieldhash my %IDs;
  
      my $Last_ID = "a";
      sub _object_id {
          my $self = shift;
  
          # This is 15% faster than ||=
          return $IDs{$self} if exists $IDs{$self};
          return $IDs{$self} = ++$Last_ID;
      }
  }
  
  
  sub _show_methods {
      my ($ref, $p) = @_;
  
      my $string = '';
      my $methods = {
          public => [],
          private => [],
      };
      my $inherited = $p->{class}{inherited} || 'none';
  
      require B;
  
      my $methods_of = sub {
          my ($name) = @_;
          map {
              my $m;
              if ($_
                  and $m = B::svref_2object($_)
                  and $m->isa('B::CV')
                  and not $m->GV->isa('B::Special')
              ) {
                  [ $m->GV->STASH->NAME, $m->GV->NAME ]
              } else {
                  ()
              }
          } values %{Package::Stash->new($name)->get_all_symbols('CODE')}
      };
  
      my %seen_method_name;
  
  METHOD:
      foreach my $method (
          map $methods_of->($_), @{mro::get_linear_isa($ref)},
                                 $p->{class}{universal} ? 'UNIVERSAL' : ()
      ) {
          my ($package_string, $method_string) = @$method;
  
          next METHOD if $seen_method_name{$method_string}++;
  
          my $type = substr($method_string, 0, 1) eq '_' ? 'private' : 'public';
  
          if ($package_string ne $ref) {
              next METHOD unless $inherited ne 'none'
                             and ($inherited eq 'all' or $type eq $inherited);
              $method_string .= ' (' . $package_string . ')';
          }
  
          push @{ $methods->{$type} }, $method_string;
      }
  
      # render our string doing a natural sort by method name
      my $show_methods = $p->{class}{show_methods};
      foreach my $type (qw(public private)) {
          next unless $show_methods eq 'all'
                   or $show_methods eq $type;
  
          my @list = ($p->{class}{sort_methods} ? nsort @{$methods->{$type}} : @{$methods->{$type}});
  
          $string .= (' ' x $p->{_current_indent})
                   . "$type methods (" . scalar @list . ')'
                   . (@list ? ' : ' : '')
                   . join(', ', map { colored($_, $p->{color}->{method}) }
                                @list
                     ) . $BREAK;
      }
  
      return $string;
  }
  
  sub _deparse {
      my ($item, $p) = @_;
      require B::Deparse;
      my $i = $p->{indent};
      my $deparseopts = ["-sCi${i}v'Useless const omitted'"];
  
      my $sub = 'sub ' . B::Deparse->new($deparseopts)->coderef2text($item);
      my $pad = "\n" . (' ' x ($p->{_current_indent} + $i));
      $sub    =~ s/\n/$pad/gse;
      return $sub;
  }
  
  sub _get_info_message {
      my $p = shift;
      my @caller = caller 2;
  
      my $message = $p->{caller_message};
  
      $message =~ s/\b__PACKAGE__\b/$caller[0]/g;
      $message =~ s/\b__FILENAME__\b/$caller[1]/g;
      $message =~ s/\b__LINE__\b/$caller[2]/g;
  
      return colored($message, $p->{color}{caller_info}) . $BREAK;
  }
  
  
  sub _merge {
      my $p = shift;
      my $clone = clone $properties;
  
      if ($p) {
          foreach my $key (keys %$p) {
              if ($key eq 'color' or $key eq 'colour') {
                  my $color = $p->{$key};
                  if ( not ref $color or ref $color ne 'HASH' ) {
                      Carp::carp q['color' should be a HASH reference. Did you mean 'colored'?];
                      $clone->{color} = {};
                  }
                  else {
                      foreach my $target ( keys %$color ) {
                          $clone->{color}->{$target} = $p->{$key}->{$target};
                      }
                  }
              }
              elsif ($key eq 'class') {
                  foreach my $item ( keys %{$p->{class}} ) {
                      $clone->{class}->{$item} = $p->{class}->{$item};
                  }
              }
              elsif ($key eq 'filters') {
                  my $val = $p->{$key};
  
                  foreach my $item (keys %$val) {
                      my $filters = $val->{$item};
  
                      # EXPERIMENTAL: filters in modules
                      if ($item eq '-external') {
                          my @external = ( ref($filters) ? @$filters : ($filters) );
  
                          foreach my $class ( @external ) {
                              my $module = "Data::Printer::Filter::$class";
                              eval "use $module";
                              if ($@) {
                                  warn "Error loading filter '$module': $@";
                              }
                              else {
                                  my %from_module = %{$module->_filter_list};
                                  my %extras      = %{$module->_extra_options};
  
                                  foreach my $k (keys %from_module) {
                                      unshift @{ $clone->{filters}->{$k} }, @{ $from_module{$k} };
                                      $clone->{_seen_override}{$k} = 1
                                          if $extras{$k}{show_repeated};
                                  }
                              }
                          }
                      }
                      else {
                          my @filter_list = ( ref $filters eq 'CODE' ? ( $filters ) : @$filters );
                          unshift @{ $clone->{filters}->{$item} }, @filter_list;
                      }
                  }
              }
              elsif ($key eq 'output') {
                  my $out = $p->{output};
                  my $ref = ref $out;
  
                  $clone->{output} = $out;
  
                  my %output_target = (
                       stdout => *STDOUT,
                       stderr => *STDERR,
                  );
  
                  my $error;
                  if (!$ref and exists $output_target{ lc $out }) {
                      $clone->{_output} = $output_target{ lc $out };
                  }
                  elsif ( ( $ref and $ref eq 'GLOB')
                       or (!$ref and \$out =~ /GLOB\([^()]+\)$/)
                  ) {
                      $clone->{_output} = $out;
                  }
                  elsif ( !$ref or $ref eq 'SCALAR' ) {
                      if( open my $fh, '>>', $out ) {
                          $clone->{_output} = $fh;
                      }
                      else {
                          $error = 1;
                      }
                  }
                  else {
                      $error = 1;
                  }
  
                  if ($error) {
                      Carp::carp 'Error opening custom output handle.';
                      $clone->{_output} = $output_target{ 'stderr' };
                  }
              }
              else {
                  $clone->{$key} = $p->{$key};
              }
          }
      }
  
      return $clone;
  }
  
  
  sub _load_rc_file {
      my $args = shift || {};
  
      my $file = exists $args->{rc_file}    ? $args->{rc_file}
               : exists $ENV{DATAPRINTERRC} ? $ENV{DATAPRINTERRC}
               : File::Spec->catfile(File::HomeDir->my_home,'.dataprinter');
  
      return unless -e $file;
  
      my $mode = (stat $file )[2];
      if ($^O !~ /Win32/i && ($mode & 0020 || $mode & 0002) ) {
          warn "rc file '$file' must NOT be writeable to other users. Skipping.\n";
          return;
      }
  
      if ( -l $file || (!-f _) || -p _ || -S _ || -b _ || -c _ ) {
          warn "rc file '$file' doesn't look like a plain file. Skipping.\n";
          return;
      }
  
      unless (-o $file) {
          warn "rc file '$file' must be owned by your (effective) user. Skipping.\n";
          return;
      }
  
      if ( open my $fh, '<', $file ) {
          my $rc_data;
          { local $/; $rc_data = <$fh> }
          close $fh;
  
          if( ${^TAINT} != 0 ) {
              if ( $args->{allow_tainted} ) {
                  warn "WARNING: Reading tainted file '$file' due to user override.\n";
                  $rc_data =~ /(.+)/s; # very bad idea - god help you
                  $rc_data = $1;
              }
              else {
                  warn "taint mode on: skipping rc file '$file'.\n";
                  return;
              }
          }
  
          my $config = eval $rc_data;
          if ( $@ ) {
              warn "Error loading $file: $@\n";
          }
          elsif (!ref $config or ref $config ne 'HASH') {
              warn "Error loading $file: config file must return a hash reference\n";
          }
          else {
              $properties = _merge( $config );
          }
      }
      else {
          warn "error opening '$file': $!\n";
      }
  }
  
  
  1;
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  Data::Printer - colored pretty-print of Perl data structures and objects
  
  =head1 SYNOPSIS
  
  Want to see what's inside a variable in a complete, colored
  and human-friendly way?
  
    use Data::Printer;   # or just "use DDP" for short
    
    p @array;            # no need to pass references
  
  Code above might output something like this (with colors!):
  
     [
         [0] "a",
         [1] "b",
         [2] undef,
         [3] "c",
     ]
  
  You can also inspect objects:
  
      my $obj = SomeClass->new;
  
      p($obj);
  
  Which might give you something like:
  
    \ SomeClass  {
        Parents       Moose::Object
        Linear @ISA   SomeClass, Moose::Object
        public methods (3) : bar, foo, meta
        private methods (0)
        internals: {
           _something => 42,
        }
    }
  
  Data::Printer is fully customizable. If you want to change how things
  are displayed, or even its standard behavior. Take a look at the
  L<< available customizations|/"CUSTOMIZATION" >>. Once you figure out
  your own preferences, create a
  L<< configuration file|/"CONFIGURATION FILE (RUN CONTROL)" >> for
  yourself and Data::Printer will automatically use it!
  
  B<< That's about it! Feel free to stop reading now and start dumping
  your data structures! For more information, including feature set,
  how to create filters, and general tips, just keep reading :) >>
  
  Oh, if you are just experimenting and/or don't want to use a
  configuration file, you can set all options during initialization,
  including coloring, identation and filters!
  
    use Data::Printer {
        color => {
           'regex' => 'blue',
           'hash'  => 'yellow',
        },
        filters => {
           'DateTime' => sub { $_[0]->ymd },
           'SCALAR'   => sub { "oh noes, I found a scalar! $_[0]" },
        },
    };
  
  The first C<{}> block is just syntax sugar, you can safely ommit it
  if it makes things easier to read:
  
    use DDP colored => 1;
  
    use Data::Printer  deparse => 1, sort_keys => 0;
  
  
  =head1 FEATURES
  
  Here's what Data::Printer has to offer to Perl developers, out of the box:
  
  =over 4
  
  =item * Very sane defaults (I hope!)
  
  =item * Highly customizable (in case you disagree with me :)
  
  =item * Colored output by default
  
  =item * Human-friendly output, with array index and custom separators
  
  =item * Full object dumps including methods, inheritance and internals
  
  =item * Exposes extra information such as tainted data and weak references
  
  =item * Ability to easily create filters for objects and regular structures
  
  =item * Ability to load settings from a C<.dataprinter> file so you don't have to write anything other than "use DDP;" in your code!
  
  =back
  
  =head1 RATIONALE
  
  Data::Dumper is a fantastic tool, meant to stringify data structures
  in a way they are suitable for being C<eval>'ed back in.
  
  The thing is, a lot of people keep using it (and similar ones,
  like Data::Dump) to print data structures and objects on screen
  for inspection and debugging, and while you B<can> use those
  modules for that, it doesn't mean mean you B<should>.
  
  This is where Data::Printer comes in. It is meant to do one thing
  and one thing only:
  
  I<< display Perl variables and objects on screen, properly
  formatted >> (to be inspected by a human)
  
  If you want to serialize/store/restore Perl data structures,
  this module will NOT help you. Try L<Storable>, L<Data::Dumper>,
  L<JSON>, or whatever. CPAN is full of such solutions!
  
  =head1 THE p() FUNCTION
  
  Once you load Data::Printer, the C<p()> function will be imported
  into your namespace and available to you. It will pretty-print
  into STDERR (or any other output target) whatever variabe you pass to it.
  
  =head2 Changing output targets
  
  By default, C<p()> will be set to use STDERR. As of version 0.27, you
  can set up the 'output' property so Data::Printer outputs to
  several different places:
  
  =over 4
  
  =item * C<< output => 'stderr' >> - Standard error. Same as *STDERR
  
  =item * C<< output => 'stdout' >> - Standard output. Same as *STDOUT
  
  =item * C<< output => $filename >> - Appends to filename.
  
  =item * C<< output => $file_handle >> - Appends to opened handle
  
  =item * C<< output => \$scalar >> - Appends to that variable's content
  
  =back
  
  =head2 Return Value
  
  If for whatever reason you want to mangle with the output string
  instead of printing it, you can simply ask for a return
  value:
  
    # move to a string
    my $string = p @some_array;
  
    # output to STDOUT instead of STDERR;
    print p(%some_hash);
  
  Note that, in this case, Data::Printer will not colorize the
  returned string unless you explicitly set the C<colored> option to 1:
  
    print p(%some_hash, colored => 1); # now with colors!
  
  You can - and should - of course, set this during you "C<use>" call:
  
    use Data::Printer colored => 1;
    print p( %some_hash );  # will be colored
  
  Or by adding the setting to your C<.dataprinter> file.
  
  As most of Data::Printer, the return value is also configurable. You
  do this by setting the C<return_value> option. There are three options
  available:
  
  =over 4
  
  =item * C<'dump'> (default):
  
      p %var;               # prints the dump to STDERR (void context)
      my $string = p %var;  # returns the dump *without* printing
  
  =item * C<'void'>:
  
      p %var;               # prints the dump to STDERR, never returns.
      my $string = p %var;  # $string is undef. Data still printed in STDERR
  
  
  =item * C<'pass'>:
  
      p %var;               # prints the dump to STDERR, returns %var
      my %copy = p %var;    # %copy = %var. Data still printed in STDERR
  
  =back
  
  =head1 COLORS AND COLORIZATION
  
  Below are all the available colorizations and their default values.
  Note that both spellings ('color' and 'colour') will work.
  
     use Data::Printer {
       color => {
          array       => 'bright_white',  # array index numbers
          number      => 'bright_blue',   # numbers
          string      => 'bright_yellow', # strings
          class       => 'bright_green',  # class names
          method      => 'bright_green',  # method names
          undef       => 'bright_red',    # the 'undef' value
          hash        => 'magenta',       # hash keys
          regex       => 'yellow',        # regular expressions
          code        => 'green',         # code references
          glob        => 'bright_cyan',   # globs (usually file handles)
          vstring     => 'bright_blue',   # version strings (v5.16.0, etc)
          repeated    => 'white on_red',  # references to seen values
          caller_info => 'bright_cyan',   # details on what's being printed
          weak        => 'cyan',          # weak references
          tainted     => 'red',           # tainted content
          escaped     => 'bright_red',    # escaped characters (\t, \n, etc)
  
          # potential new Perl datatypes, unknown to Data::Printer
          unknown     => 'bright_yellow on_blue',
       },
     };
  
  Don't fancy colors? Disable them with:
  
    use Data::Printer colored => 0;
  
  By default, 'colored' is set to C<"auto">, which means Data::Printer
  will colorize only when not being used to return the dump string,
  nor when the output (default: STDERR) is being piped. If you're not
  seeing colors, try forcing it with:
  
    use Data::Printer colored => 1;
  
  Also worth noticing that Data::Printer I<will> honor the
  C<ANSI_COLORS_DISABLED> environment variable unless you force a
  colored output by setting 'colored' to 1.
  
  Remember to put your preferred settings in the C<.dataprinter> file
  so you never have to type them at all!
  
  
  =head1 ALIASING
  
  Data::Printer provides the nice, short, C<p()> function to dump your
  data structures and objects. In case you rather use a more explicit
  name, already have a C<p()> function (why?) in your code and want
  to avoid clashing, or are just used to other function names for that
  purpose, you can easily rename it:
  
    use Data::Printer alias => 'Dumper';
  
    Dumper( %foo );
  
  
  =head1 CUSTOMIZATION
  
  I tried to provide sane defaults for Data::Printer, so you'll never have
  to worry about anything other than typing C<< "p( $var )" >> in your code.
  That said, and besides coloring and filtering, there are several other
  customization options available, as shown below (with default values):
  
    use Data::Printer {
        name           => 'var',   # name to display on cyclic references
        indent         => 4,       # how many spaces in each indent
        hash_separator => '   ',   # what separates keys from values
        colored        => 'auto',  # colorize output (1 for always, 0 for never)
        index          => 1,       # display array indices
        multiline      => 1,       # display in multiple lines (see note below)
        max_depth      => 0,       # how deep to traverse the data (0 for all)
        sort_keys      => 1,       # sort hash keys
        deparse        => 0,       # use B::Deparse to expand (expose) subroutines
        show_tied      => 1,       # expose tied variables
        show_tainted   => 1,       # expose tainted variables
        show_weak      => 1,       # expose weak references
        show_readonly  => 0,       # expose scalar variables marked as read-only
        show_lvalue    => 1,       # expose lvalue types
        print_escapes  => 0,       # print non-printable chars as "\n", "\t", etc.
        quote_keys     => 'auto',  # quote hash keys (1 for always, 0 for never).
                                   # 'auto' will quote when key is empty/space-only.
        separator      => ',',     # uses ',' to separate array/hash elements
        end_separator  => 0,       # prints the separator after last element in array/hash.
                                   # the default is 0 that means not to print
  
        caller_info    => 0,       # include information on what's being printed
        use_prototypes => 1,       # allow p(%foo), but prevent anonymous data
        return_value   => 'dump',  # what should p() return? See 'Return Value' above.
        output         => 'stderr',# where to print the output. See
                                   # 'Changing output targets' above.
  
        class_method   => '_data_printer', # make classes aware of Data::Printer
                                           # and able to dump themselves.
  
        class => {
            internals  => 1,       # show internal data structures of classes
  
            inherited  => 'none',  # show inherited methods,
                                   # can also be 'all', 'private', or 'public'.
  
            universal  => 1,       # include UNIVERSAL methods in inheritance list
  
            parents    => 1,       # show parents, if there are any
            linear_isa => 'auto',  # show the entire @ISA, linearized, whenever
                                   # the object has more than one parent. Can
                                   # also be set to 1 (always show) or 0 (never).
  
            expand     => 1,       # how deep to traverse the object (in case
                                   # it contains other objects). Defaults to
                                   # 1, meaning expand only itself. Can be any
                                   # number, 0 for no class expansion, and 'all'
                                   # to expand everything.
  
            sort_methods => 1,     # sort public and private methods
  
            show_methods => 'all'  # method list. Also 'none', 'public', 'private'
        },
    };
  
  Note: setting C<multiline> to C<0> will also set C<index> and C<indent> to C<0>.
  
  =head1 FILTERS
  
  Data::Printer offers you the ability to use filters to override
  any kind of data display. The filters are placed on a hash,
  where keys are the types - or class names - and values
  are anonymous subs that receive two arguments: the item itself
  as first parameter, and the properties hashref (in case your
  filter wants to read from it). This lets you quickly override
  the way Data::Printer handles and displays data types and, in
  particular, objects.
  
    use Data::Printer filters => {
              'DateTime'      => sub { $_[0]->ymd },
              'HTTP::Request' => sub { $_[0]->uri },
    };
  
  Perl types are named as C<ref> calls them: I<SCALAR>, I<ARRAY>,
  I<HASH>, I<REF>, I<CODE>, I<Regexp> and I<GLOB>. As for objects,
  just use the class' name, as shown above.
  
  As of version 0.13, you may also use the '-class' filter, which
  will be called for all non-perl types (objects).
  
  Your filters are supposed to return a defined value (usually, the
  string you want to print). If you don't, Data::Printer will
  let the next filter of that same type have a go, or just fallback
  to the defaults. You can also use an array reference to pass more
  than one filter for the same type or class.
  
  B<Note>: If you plan on calling C<p()> from I<within> an inline
  filter, please make sure you are passing only REFERENCES as
  arguments. See L</CAVEATS> below.
  
  You may also like to specify standalone filter modules. Please
  see L<Data::Printer::Filter> for further information on a more
  powerful filter interface for Data::Printer, including useful
  filters that are shipped as part of this distribution.
  
  =head1 MAKING YOUR CLASSES DDP-AWARE (WITHOUT ADDING ANY DEPS)
  
  Whenever printing the contents of a class, Data::Printer first
  checks to see if that class implements a sub called '_data_printer'
  (or whatever you set the "class_method" option to in your settings,
  see L</CUSTOMIZATION> below).
  
  If a sub with that exact name is available in the target object,
  Data::Printer will use it to get the string to print instead of
  making a regular class dump.
  
  This means you could have the following in one of your classes:
  
    sub _data_printer {
        my ($self, $properties) = @_;
        return 'Hey, no peeking! But foo contains ' . $self->foo;
    }
  
  Notice you don't have to depend on Data::Printer at all, just
  write your sub and it will use that to pretty-print your objects.
  
  If you want to use colors and filter helpers, and still not
  add Data::Printer to your dependencies, remember you can import
  them during runtime:
  
    sub _data_printer {
        require Data::Printer::Filter;
        Data::Printer::Filter->import;
  
        # now we have 'indent', outdent', 'linebreak', 'p' and 'colored'
        my ($self, $properties) = @_;
        ...
    }
  
  Having a filter for that particular class will of course override
  this setting.
  
  
  =head1 CONFIGURATION FILE (RUN CONTROL)
  
  Data::Printer tries to let you easily customize as much as possible
  regarding the visualization of your data structures and objects.
  But we don't want you to keep repeating yourself every time you
  want to use it!
  
  To avoid this, you can simply create a file called C<.dataprinter> in
  your home directory (usually C</home/username> in Linux), and put
  your configuration hash reference in there.
  
  This way, instead of doing something like:
  
     use Data::Printer {
       colour => {
          array => 'bright_blue',
       },
       filters => {
           'Catalyst::Request' => sub {
               my $req = shift;
               return "Cookies: " . p($req->cookies)
           },
       },
     };
  
  You can create a .dataprinter file that looks like this:
  
     {
       colour => {
          array => 'bright_blue',
       },
       filters => {
           'Catalyst::Request' => sub {
               my $req = shift;
               return "Cookies: " . p($req->cookies)
           },
       },
     };
  
  Note that all we did was remove the "use Data::Printer" bit when
  writing the C<.dataprinter> file. From then on all you have to do
  while debugging scripts is:
  
    use Data::Printer;
  
  and it will load your custom settings every time :)
  
  =head2 Loading RC files in custom locations
  
  If your RC file is somewhere other than C<.dataprinter> in your home
  dir, you can load whichever file you want via the C<'rc_file'> parameter:
  
    use Data::Printer rc_file => '/path/to/my/rcfile.conf';
  
  You can even set this to undef or to a non-existing file to disable your
  RC file at will.
  
  The RC file location can also be specified with the C<DATAPRINTERRC>
  environment variable. Using C<rc_file> in code will override the environment
  variable.
  
  =head2 RC File Security
  
  The C<.dataprinter> RC file is nothing but a Perl hash that
  gets C<eval>'d back into the code. This means that whatever
  is in your RC file B<WILL BE INTERPRETED BY PERL AT RUNTIME>.
  This can be quite worrying if you're not the one in control
  of the RC file.
  
  For this reason, Data::Printer takes extra precaution before
  loading the file:
  
  =over 4
  
  =item * The file has to be in your home directory unless you
  specifically point elsewhere via the 'C<rc_file>' property or
  the DATAPRINTERRC environment variable;
  
  =item * The file B<must> be a plain file, never a symbolic
  link, named pipe or socket;
  
  =item * The file B<must> be owned by you (i.e. the effective
  user id that ran the script using Data::Printer);
  
  =item * The file B<must> be read-only for everyone but your user.
  This usually means permissions C<0644>, C<0640> or C<0600> in
  Unix-like systems. B<THIS IS NOT CHECKED IN WIN32>;
  
  =item * The file will B<NOT> be loaded in Taint mode, unless
  you specifically load Data::Printer with the 'allow_tainted'
  option set to true. And even if you do that, Data::Printer
  will still issue a warning before loading the file. But
  seriously, don't do that.
  
  =back
  
  Failure to comply with the security rules above will result in
  the RC file not being loaded (likely with a warning on what went
  wrong).
  
  
  =head1 THE "DDP" PACKAGE ALIAS
  
  You're likely to add/remove Data::Printer from source code being
  developed and debugged all the time, and typing it might feel too
  long. Because of this, the 'DDP' package is provided as a shorter
  alias to Data::Printer:
  
     use DDP;
     p %some_var;
  
  =head1 CALLER INFORMATION
  
  If you set caller_info to a true value, Data::Printer will prepend
  every call with an informational message. For example:
  
    use Data::Printer caller_info => 1;
  
    my $var = 42;
    p $var;
  
  will output something like:
  
    Printing in line 4 of myapp.pl:
    42
  
  The default message is C<< 'Printing in line __LINE__ of __FILENAME__:' >>.
  The special strings C<__LINE__>, C<__FILENAME__> and C<__PACKAGE__> will
  be interpolated into their according value so you can customize them at will:
  
    use Data::Printer
      caller_info => 1,
      caller_message => "Okay, __PACKAGE__, let's dance!"
      color => {
          caller_info => 'bright_red',
      };
  
  As shown above, you may also set a color for "caller_info" in your color
  hash. Default is cyan.
  
  
  =head1 EXPERIMENTAL FEATURES
  
  The following are volatile parts of the API which are subject to
  change at any given version. Use them at your own risk.
  
  =head2 Local Configuration (experimental!)
  
  You can override global configurations by writing them as the second
  parameter for p(). For example:
  
    p( %var, color => { hash => 'green' } );
  
  
  =head2 Filter classes
  
  As of Data::Printer 0.11, you can create complex filters as a separate
  module. Those can even be uploaded to CPAN and used by other people!
  See L<Data::Printer::Filter> for further information.
  
  =head1 CAVEATS
  
  You can't pass more than one variable at a time.
  
     p($foo, $bar); # wrong
     p($foo);       # right
     p($bar);       # right
  
  The default mode is to use prototypes, in which you are supposed to pass
  variables, not anonymous structures:
  
     p( { foo => 'bar' } ); # wrong
  
     p %somehash;        # right
     p $hash_ref;        # also right
  
  To pass anonymous structures, set "use_prototypes" option to 0. But
  remember you'll have to pass your variables as references:
  
     use Data::Printer use_prototypes => 0;
  
     p( { foo => 'bar' } ); # was wrong, now is right.
  
     p( %foo  ); # was right, but fails without prototypes
     p( \%foo ); # do this instead
  
  If you are using inline filters, and calling p() (or whatever name you
  aliased it to) from inside those filters, you B<must> pass the arguments
  to C<p()> as a reference:
  
    use Data::Printer {
        filters => {
            ARRAY => sub {
                my $listref = shift;
                my $string = '';
                foreach my $item (@$listref) {
                    $string .= p( \$item );      # p( $item ) will not work!
                }
                return $string;
            },
        },
    };
  
  This happens because your filter function is compiled I<before> Data::Printer
  itself loads, so the filter does not see the function prototype. As a way
  to avoid unpleasant surprises, if you forget to pass a reference, Data::Printer
  will generate an exception for you with the following message:
  
      'When calling p() without prototypes, please pass arguments as references'
  
  Another way to avoid this is to use the much more complete L<Data::Printer::Filter>
  interface for standalone filters.
  
  =head1 EXTRA TIPS
  
  =head2 Circumventing prototypes
  
  The C<p()> function uses prototypes by default, allowing you to say:
  
    p %var;
  
  instead of always having to pass references, like:
  
    p \%var;
  
  There are cases, however, where you may want to pass anonymous
  structures, like:
  
    p { foo => $bar };   # this blows up, don't use
  
  and because of prototypes, you can't. If this is your case, just
  set "use_prototypes" option to 0. Note, with this option,
  you B<will> have to pass your variables as references:
  
    use Data::Printer use_prototypes => 0;
  
     p { foo => 'bar' }; # doesn't blow up anymore, works just fine.
  
     p %var;  # but now this blows up...
     p \%var; # ...so do this instead
  
     p [ $foo, $bar, \@baz ]; # this way you can even pass
                              # several variables at once
  
  Versions prior to 0.17 don't have the "use_prototypes" option. If
  you're stuck in an older version you can write C<&p()> instead of C<p()>
  to circumvent prototypes and pass elements (including anonymous variables)
  as B<REFERENCES>. This notation, however, requires enclosing parentheses:
  
    &p( { foo => $bar } );        # this is ok, use at will
    &p( \"DEBUGGING THIS BIT" );  # this works too
  
  Or you could just create a very simple wrapper function:
  
    sub pp { p @_ };
  
  And use it just as you use C<p()>.
  
  =head2 Minding the return value of p()
  
  I<< (contributed by Matt S. Trout (mst)) >>
  
  There is a reason why explicit return statements are recommended unless
  you know what you're doing. By default, Data::Printer's return value
  depends on how it was called. When not in void context, it returns the
  serialized form of the dump.
  
  It's tempting to trust your own p() calls with that approach, but if
  this is your I<last> statement in a function, you should keep in mind
  your debugging code will behave differently depending on how your
  function was called!
  
  To prevent that, set the C<return_value> property to either 'void'
  or 'pass'. You won't be able to retrieve the dumped string but, hey,
  who does that anyway :)
  
  Assuming you have set the pass-through ('pass') property in your
  C<.dataprinter> file, another stunningly useful thing you can do with it
  is change code that says:
  
     return $obj->foo;
  
  with:
  
     use DDP;
  
     return p $obj->foo;
  
  You can even add it to chained calls if you wish to see the dump of
  a particular state, changing this:
  
     $obj->foo->bar->baz;
  
  to:
  
     $obj->foo->DDP::p->bar->baz
  
  And things will "Just Work".
  
  
  =head2 Using p() in some/all of your loaded modules
  
  I<< (contributed by Matt S. Trout (mst)) >>
  
  While debugging your software, you may want to use Data::Printer in
  some or all loaded modules and not bother having to load it in
  each and every one of them. To do this, in any module loaded by
  C<myapp.pl>, simply write:
  
    ::p( @myvar );  # note the '::' in front of p()
  
  Then call your program like:
  
    perl -MDDP myapp.pl
  
  This also has the great advantage that if you leave one p() call
  in by accident, it will fail without the -M, making it easier to spot :)
  
  If you really want to have p() imported into your loaded
  modules, use the next tip instead.
  
  =head2 Adding p() to all your loaded modules
  
  I<< (contributed by rpd Szsz) >>
  
  If you wish to automatically add Data::Printer's C<p()> function to
  every loaded module in you app, you can do something like this to
  your main program:
  
      BEGIN {
          {
              no strict 'refs';
              require Data::Printer;
              my $alias = 'p';
              foreach my $package ( keys %main:: ) {
                  if ( $package =~ m/::$/ ) {
                      *{ $package . $alias } = \&Data::Printer::p;
                  }
              }
          }
      }
  
  B<WARNING> This will override all locally defined subroutines/methods that
  are named C<p>, if they exist, in every loaded module. If you already
  have a subroutine named 'C<p()>', be sure to change C<$alias> to
  something custom.
  
  If you rather avoid namespace manipulation altogether, use the previous
  tip instead.
  
  =head2 Using Data::Printer from the Perl debugger
  
  I<< (contributed by rpd Szsz and Marcel Grnauer (hanekomu)) >>
  
  With L<DB::Pluggable>, you can easily set the perl debugger to use
  Data::Printer to print variable information, replacing the debugger's
  standard C<p()> function. All you have to do is add these lines to
  your C<.perldb> file:
  
    use DB::Pluggable;
    DB::Pluggable->run_with_config( \'[DataPrinter]' );  # note the '\'
  
  Then call the perl debugger as you normally would:
  
    perl -d myapp.pl
  
  Now Data::Printer's C<p()> command will be used instead of the debugger's!
  
  See L<perldebug> for more information on how to use the perl debugger, and
  L<DB::Pluggable> for extra functionality and other plugins.
  
  If you can't or don't wish to use DB::Pluggable, or simply want to keep
  the debugger's C<p()> function and add an extended version using
  Data::Printer (let's call it C<px()> for instance), you can add these
  lines to your C<.perldb> file instead:
  
      $DB::alias{px} = 's/px/DB::px/';
      sub px {
          my $expr = shift;
          require Data::Printer;
          print Data::Printer::p($expr);
      }
  
  Now, inside the Perl debugger, you can pass as reference to C<px> expressions
  to be dumped using Data::Printer.
  
  =head2 Using Data::Printer in a perl shell (REPL)
  
  Some people really enjoy using a REPL shell to quickly try Perl code. One
  of the most famous ones out there is L<Devel::REPL>. If you use it, now
  you can also see its output with Data::Printer!
  
  Just install L<Devel::REPL::Plugin::DataPrinter> and add the following
  line to your re.pl configuration file (usually ".re.pl/repl.rc" in your
  home dir):
  
    load_plugin('DataPrinter');
  
  The next time you run C<re.pl>, it should dump all your REPL using
  Data::Printer!
  
  =head2 Easily rendering Data::Printer's output as HTML
  
  To turn Data::Printer's output into HTML, you can do something like:
  
    use HTML::FromANSI;
    use Data::Printer;
    
    my $html_output = ansi2html( p($object, colored => 1) );
  
  In the example above, the C<$html_output> variable contains the
  HTML escaped output of C<p($object)>, so you can print it for
  later inspection or render it (if it's a web app).
  
  =head2 Using Data::Printer with Template Toolkit
  
  I<< (contributed by Stephen Thirlwall (sdt)) >>
  
  If you use Template Toolkit and want to dump your variables using Data::Printer,
  install the L<Template::Plugin::DataPrinter> module and load it in your template:
  
     [% USE DataPrinter %]
  
  The provided methods match those of C<Template::Plugin::Dumper>:
  
     ansi-colored dump of the data structure in "myvar":
     [% DataPrinter.dump( myvar ) %]
  
     html-formatted, colored dump of the same data structure:
     [% DataPrinter.dump_html( myvar ) %]
  
  The module allows several customization options, even letting you load it as a
  complete drop-in replacement for Template::Plugin::Dumper so you don't even have
  to change your previous templates!
  
  =head2 Unified interface for Data::Printer and other debug formatters
  
  I<< (contributed by Kevin McGrath (catlgrep)) >>
  
  If you are porting your code to use Data::Printer instead of
  Data::Dumper or similar, you can just replace:
  
    use Data::Dumper;
  
  with:
  
    use Data::Printer alias => 'Dumper';
    # use Data::Dumper;
  
  making sure to provide Data::Printer with the proper alias for the
  previous dumping function.
  
  If, however, you want a really unified approach where you can easily
  flip between debugging outputs, use L<Any::Renderer> and its plugins,
  like L<Any::Renderer::Data::Printer>.
  
  =head2 Printing stack traces with arguments expanded using Data::Printer
  
  I<< (contributed by Sergey Aleynikov (randir)) >>
  
  There are times where viewing the current state of a variable is not
  enough, and you want/need to see a full stack trace of a function call.
  
  The L<Devel::PrettyTrace> module uses Data::Printer to provide you just
  that. It exports a C<bt()> function that pretty-prints detailed information
  on each function in your stack, making it easier to spot any issues!
  
  =head2 Troubleshooting apps in real time without changing a single line of your code
  
  I<< (contributed by Marcel Grnauer (hanekomu)) >>
  
  L<dip> is a dynamic instrumentation framework for troubleshooting Perl
  programs, similar to L<DTrace|http://opensolaris.org/os/community/dtrace/>.
  In a nutshell, C<dip> lets you create probes for certain conditions
  in your application that, once met, will perform a specific action. Since
  it uses Aspect-oriented programming, it's very lightweight and you only
  pay for what you use.
  
  C<dip> can be very useful since it allows you to debug your software
  without changing a single line of your original code. And Data::Printer
  comes bundled with it, so you can use the C<p()> function to view your
  data structures too!
  
     # Print a stack trace every time the name is changed,
     # except when reading from the database.
     dip -e 'before { print longmess(p $_->{args}[1]) if $_->{args}[1] }
       call "MyObj::name" & !cflow("MyObj::read")' myapp.pl
  
  You can check you L<dip>'s own documentation for more information and options.
  
  =head2 Sample output for color fine-tuning
  
  I<< (contributed by Yanick Champoux (yanick)) >>
  
  The "examples/try_me.pl" file included in this distribution has a sample
  dump with a complex data structure to let you quickly test color schemes.
  
  =head2 creating fiddling filters
  
  I<< (contributed by dirk) >>
  
  Sometimes, you may want to take advantage of Data::Printer's original dump,
  but add/change some of the original data to enhance your debugging ability.
  Say, for example, you have an C<HTTP::Response> object you want to print
  but the content is encoded. The basic approach, of course, would be to
  just dump the decoded content:
  
    use DDP filter {
      'HTTP::Response' => sub { p( \shift->decoded_content, %{shift} );
    };
  
  But what if you want to see the rest of the original object? Dumping it
  would be a no-go, because you would just recurse forever in your own filter.
  
  Never fear! When you create a filter in Data::Printer, you're not replacing
  the original one, you're just stacking yours on top of it. To forward your data
  to the original filter, all you have to do is return an undefined value. This
  means you can rewrite your C<HTTP::Response> filter like so, if you want:
  
    use DDP filters => {
      'HTTP::Response' => sub {
        my ($res, $p) = @_;
  
        # been here before? Switch to original handler
        return if exists $res->{decoded_content};
  
        # first timer? Come on in!
        my $clone = $res->clone;
        $clone->{decoded_content} = $clone->decoded_content;
        return p($clone, %$p);
      }
    };
  
  And voil! Your fiddling filter now works like a charm :)
  
  =head1 BUGS
  
  If you find any, please file a bug report.
  
  
  =head1 SEE ALSO
  
  L<Data::Dumper>
  
  L<Data::Dump>
  
  L<Data::Dumper::Concise>
  
  L<Data::Dump::Streamer>
  
  L<Data::PrettyPrintObjects>
  
  L<Data::TreeDumper>
  
  
  =head1 AUTHOR
  
  Breno G. de Oliveira C<< <garu at cpan.org> >>
  
  =head1 CONTRIBUTORS
  
  Many thanks to everyone that helped design and develop this module
  with patches, bug reports, wishlists, comments and tests. They are
  (alphabetically):
  
  =over 4
  
  =item * Allan Whiteford
  
  =item * Andreas Knig
  
  =item * Andy Bach
  
  =item * rpd Szsz
  
  =item * brian d foy
  
  =item * Chris Prather (perigrin)
  
  =item * David Golden (xdg)
  
  =item * David Raab
  
  =item * Damien Krotkine (dams)
  
  =item * Denis Howe
  
  =item * Dotan Dimet
  
  =item * Eden Cardim (edenc)
  
  =item * Elliot Shank (elliotjs)
  
  =item * Fernando Corra (SmokeMachine)
  
  =item * Fitz Elliott
  
  =item * Ivan Bessarabov (bessarabv)
  
  =item * J Mash
  
  =item * Jesse Luehrs (doy)
  
  =item * Joel Berger (jberger)
  
  =item * Kartik Thakore (kthakore)
  
  =item * Kevin Dawson (bowtie)
  
  =item * Kevin McGrath (catlgrep)
  
  =item * Kip Hampton (ubu)
  
  =item * Marcel Grnauer (hanekomu)
  
  =item * Matt S. Trout (mst)
  
  =item * Maxim Vuets
  
  =item * Mike Doherty (doherty)
  
  =item * Paul Evans (LeoNerd)
  
  =item * Przemysaw Wesoek (jest)
  
  =item * Rebecca Turner (iarna)
  
  =item * Rob Hoelz (hoelzro)
  
  =item * Sebastian Willing (Sewi)
  
  =item * Sergey Aleynikov (randir)
  
  =item * Stanislaw Pusep (syp)
  
  =item * Stephen Thirlwall (sdt)
  
  =item * sugyan
  
  =item * Tatsuhiko Miyagawa (miyagawa)
  
  =item * Tim Heaney (oylenshpeegul)
  
  =item * Torsten Raudssus (Getty)
  
  =item * Wesley Dal`Col (blabos)
  
  =item * Yanick Champoux (yanick)
  
  =back
  
  If I missed your name, please drop me a line!
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2011 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
  
  =head1 DISCLAIMER OF WARRANTY
  
  BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
  FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
  OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
  PROVIDE THE SOFTWARE "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
  EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
  ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH
  YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
  NECESSARY SERVICING, REPAIR, OR CORRECTION.
  
  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
  WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
  REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE
  LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL,
  OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
  THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
  RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
  FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
  SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
  SUCH DAMAGES.
  
  
  
DATA_PRINTER

$fatpacked{"Data/Printer/Filter.pm"} = <<'DATA_PRINTER_FILTER';
  package Data::Printer::Filter;
  use strict;
  use warnings;
  use Clone::PP qw(clone);
  require Carp;
  require Data::Printer;
  
  my %_filters_for   = ();
  my %_extras_for    = ();
  
  sub import {
      my $caller = caller;
      my $id = Data::Printer::_object_id( \$caller );
  
      my %properties = ();
  
      my $filter = sub {
          my ($type, $code, $extra) = @_;
  
          Carp::croak( "syntax: filter 'Class', sub { ... }" )
            unless $type and $code and ref $code eq 'CODE';
  
          if ($extra) {
              Carp::croak( 'extra filter field must be a hashref' )
                  unless ref $extra and ref $extra eq 'HASH';
  
              $_extras_for{$id}{$type} = $extra;
          }
          else {
              $_extras_for{$id}{$type} = {};
          }
  
          unshift @{ $_filters_for{$id}{$type} }, sub {
              my ($item, $p) = @_;
  
              # send our closured %properties var instead
              # so newline(), indent(), etc can work it
              %properties = %{ clone $p };
              delete $properties{filters}; # no need to rework filters
              $code->($item, \%properties);
          };
      };
  
      my $filters = sub {
          return $_filters_for{$id};
      };
  
      my $extras = sub {
          return $_extras_for{$id};
      };
  
      my $newline = sub {
          return ${$properties{_linebreak}} . (' ' x $properties{_current_indent});
      };
  
      my $indent = sub {
          $properties{_current_indent} += $properties{indent};
          $properties{_depth}++;
          return;
      };
  
      my $outdent = sub {
          $properties{_current_indent} -= $properties{indent};
          $properties{_depth}--;
          return;
      };
  
      my $imported = sub (\[@$%&];%) {
          my ($item, $p) = @_;
          return Data::Printer::p( $item, %properties );
      };
  
      {
          no strict 'refs';
          *{"$caller\::filter"}  = $filter;
          *{"$caller\::indent"}  = $indent;
          *{"$caller\::outdent"} = $outdent;
          *{"$caller\::newline"} = $newline;
  
          *{"$caller\::p"} = $imported;
  
          *{"$caller\::_filter_list"}   = $filters;
          *{"$caller\::_extra_options"} = $extras;
      }
  };
  
  
  1;
  __END__
  
  =head1 NAME
  
  Data::Printer::Filter - Create powerful stand-alone filters for Data::Printer
  
  =head1 SYNOPSIS
  
  Create your filter module:
  
    package Data::Printer::Filter::MyFilter;
    use strict;
    use warnings;
  
    use Data::Printer::Filter;
  
    # type filter
    filter 'SCALAR', sub {
        my ($ref, $properties) = @_;
        my $val = $$ref;
        
        if ($val > 100) {
            return 'too big!!';
        }
        else {
            return $val;
        }
    };
  
    # you can also filter objects of any class
    filter 'Some::Class', sub {
        my ($object, $properties) = @_;
  
        return $ref->some_method;   # or whatever
  
        # see 'HELPER FUNCTIONS' below for
        # customization options, including
        # proper indentation.
    };
  
    1;
  
  
  Later, in your main code:
  
    use Data::Printer {
        filters => {
            -external => [ 'MyFilter', 'OtherFilter' ],
  
            # you can still add regular (inline) filters
            SCALAR => sub {
                ...
            }
        },
    };
  
  
  
  =head1 WARNING - ALPHA CODE (VERY LOOSE API)
  
  We are still experimenting with the standalone filter syntax, so
  B<< filters written like so may break in the future without any warning! >>
  
  B<< If you care, or have any suggestions >>, please drop me a line via RT, email,
  or find me ('garu') on irc.perl.org.
  
  You have been warned.
  
  
  =head1 DESCRIPTION
  
  L<Data::Printer> lets you add custom filters to display data structures and
  objects, by either specifying them during "use", in the C<.dataprinter>
  configuration file, or even in runtime customizations.
  
  But there are times when you may want to group similar filters, or make
  them standalone in order to be easily reutilized in other environments and
  applications, or even upload them to CPAN so other people can benefit from
  a cleaner - and clearer - object/structure dump.
  
  This is where C<Data::Printer::Filter> comes in. It B<exports> into your
  package's namespace the L</filter> function, along with some helpers to
  create custom filter packages.
  
  L<Data::Printer> recognizes all filters in the C<Data::Printer::Filter::*>
  namespace. You can load them by specifying them in the '-external' filter
  list (note the dash, to avoid clashing with a potential class or pragma
  labelled 'external'):
  
    use Data::Printer {
        filters => {
            -external => 'MyFilter',
        },
    };
  
  This will load all filters defined by the C<Data::Printer::Filter::MyFilter>
  module.
  
  If there are more than one filter, use an array reference instead:
  
    -external => [ 'MyFilter', 'MyOtherFilter' ]
  
  B<< IMPORTANT: THIS WAY OF LOADING EXTERNAL PLUGINS IS EXPERIMENTAL AND
  SUBJECT TO SUDDEN CHANGE! IF YOU CARE, AND/OR HAVE IDEAS ON A BETTER API,
  PLEASE LET US KNOW >>
  
  =head1 HELPER FUNCTIONS
  
  =head2 filter TYPE, sub { ... };
  
  The C<filter> function creates a new filter for I<TYPE>, using
  the given subref. The subref receives two arguments: the item
  itself - be it an object or a reference to a standard Perl type -
  and the properties in effect (so you can inspect for certain
  options, etc). The subroutine is expected to return a string
  containing whatever it wants C<Data::Printer> to display on screen.
  
  =head2 p()
  
  This is the same as C<Data::Printer>'s p(), only you can't rename it.
  You can use this to throw some data structures back at C<Data::Printer>
  and use the results in your own return string - like when manipulating
  hashes or arrays.
  
  =head2 newline()
  
  This helper returns a string using the linebreak as specified by the
  caller's settings. For instance, it provides the proper indentation
  level of spaces for you and considers the C<multiline> option to
  avoid line breakage.
  
  In other words, if you do this:
  
     filter ARRAY => {
         my ($ref, $p) = @_;
         my $string = "Hey!! I got this array:";
  
         foreach my $val (@$ref) {
             $string .= newline . p($val);
         }
  
         return $string;
     };
  
  ... your C<p($val)> returns will be properly indented, vertically aligned
  to your level of the data structure, while simply using "\n" would just
  make things messy if your structure has more than one level of depth.
  
  =head2 indent()
  
  =head2 outdent()
  
  These two helpers let you increase/decrease the indentation level of
  your data display, for C<newline()> and nested C<p()> calls inside your filters.
  
  For example, the filter defined in the C<newline> explanation above would
  show the values on the same (vertically aligned) level as the "I got this array"
  message. If you wanted your array to be one level further deep, you could use
  this instead:
  
    filter ARRAY => {
        my ($ref, $p) = @_;
        my $string = "Hey!! I got this array:";
  
        indent;
        foreach my $val (@$ref) {
            $string .= newline . p($val);
        }
        outdent;
  
        return $string;
    };
  
  
  =head1 COLORIZATION
  
  You can use L<Term::ANSIColor>'s C<colored()>' for string
  colorization. Data::Printer will automatically enable/disable
  colors for you.
  
  =head1 EXISTING FILTERS
  
  This is meant to provide a complete list of standalone filters for
  Data::Printer available on CPAN. If you write one, please put it under
  the C<Data::Printer::Filter::*> namespace, and drop me a line so I can
  add it to this list!
  
  =head2 Databases
  
  L<Data::Printer::Filter::DB> provides filters for Database objects. So
  far only DBI is covered, but more to come!
  
  =head2 Dates & Times
  
  L<Data::Printer::Filter::DateTime> pretty-prints several date
  and time objects (not just DateTime) for you on the fly, including
  duration/delta objects!
  
  =head2 Digest
  
  L<Data::Printer::Filter::Digest> displays a string containing the
  hash of the actual message digest instead of the object. Works on
  C<Digest::MD5>, C<Digest::SHA>, any digest class that inherits from
  C<Digest::base> and some others that implement their own thing!
  
  =head2 ClassicRegex
  
  L<Data::Printer::Filter::ClassicRegex> changes the way Data::Printer
  dumps regular expressions, doing it the classic C<qr//> way that got
  popular in C<Data::Dumper>.
  
  =head2 URI
  
  L<Data::Printer::Filter::URI> pretty-prints L<URI> objects, displaying
  the URI as a string instead of dumping the object.
  
  =head2 JSON
  
  L<Data::Printer::Filter::JSON> lets you see your JSON structures
  replacing boolean objects with simple C<true/false> strings!
  
  =head2 URIs
  
  L<Data::Printer::Filter::URI> filters through several L<URI> manipulation
  classes and displays the URI as a colored string. A very nice addition
  by Stanislaw Pusep (SYP).
  
  =head1 USING MORE THAN ONE FILTER FOR THE SAME TYPE/CLASS
  
  As of version 0.13, standalone filters let you stack together
  filters for the same type or class. Filters of the same type are
  called in order, until one of them returns a string. This lets
  you have several filters inspecting the same given value until
  one of them decides to actually treat it somehow.
  
  If your filter catched a value and you don't want to treat it,
  simply return and the next filter will be called. If there are no
  other filters for that particular class or type available, the
  standard Data::Printer calls will be used.
  
  For example:
  
    filter SCALAR => sub {
        my ($ref, $properties) = @_;
        if ( Scalar::Util::looks_like_number $$ref ) {
            return sprintf "%.8d", $$ref;
        }
        return; # lets the other SCALAR filter have a go
    };
  
    filter SCALAR => sub {
        my ($ref, $properties) = @_;
        return qq["$$ref"];
    };
  
  Note that this "filter stack" is not possible on inline filters, since
  it's a hash and keys with the same name are overwritten. Instead, you
  can pass them as an array reference:
  
    use Data::Printer filters => {
        SCALAR => [ sub { ... }, sub { ... } ],
    };
  
  
  =head1 SEE ALSO
  
  L<Data::Printer>
  
  
  =head1 LICENSE AND COPYRIGHT
  
  Copyright 2011 Breno G. de Oliveira C<< <garu at cpan.org> >>. All rights reserved.
  
  This module is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself. See L<perlartistic>.
  
  
DATA_PRINTER_FILTER

$fatpacked{"Data/Printer/Filter/DB.pm"} = <<'DATA_PRINTER_FILTER_DB';
  package Data::Printer::Filter::DB;
  use strict;
  use warnings;
  use Data::Printer::Filter;
  use Term::ANSIColor;
  
  filter 'DBI::db', sub {
      my ($dbh, $p) = @_;
      my $name = $dbh->{Driver}{Name};
  
      my $string = "$name Database Handle ("
                 . ($dbh->{Active} 
                    ? colored('connected', 'bright_green')
                    : colored('disconnected', 'bright_red'))
                 . ') {'
                 ;
      indent;
      my %dsn = split( /[;=]/, $dbh->{Name} );
      foreach my $k (keys %dsn) {
          $string .= newline . "$k: " . $dsn{$k};
      }
      $string .= newline . 'Auto Commit: ' . $dbh->{AutoCommit};
  
      my $kids = $dbh->{Kids};
      $string .= newline . 'Statement Handles: ' . $kids;
      if ($kids > 0) {
          $string .= ' (' . $dbh->{ActiveKids} . ' active)';
      }
  
      if ( defined $dbh->err ) {
          $string .= newline . 'Error: ' . $dbh->errstr;
      }
      $string .= newline . 'Last Statement: '
              . colored( ($dbh->{Statement} || '-'), 'bright_yellow');
  
      outdent;
      $string .= newline . '}';
      return $string;
  };
  
  filter 'DBI::st', sub {
      my ($sth, $properties) = @_;
      my $str = colored( ($sth->{Statement} || '-'), 'bright_yellow');
  
      if ($sth->{NUM_OF_PARAMS} > 0) {
          my $values = $sth->{ParamValues};
          if ($values) {
              $str .= '  (' 
                   . join(', ',
                        map {
                           my $v = $values->{$_};
                           $v || 'undef';
                        } 1 .. $sth->{NUM_OF_PARAMS}
                     )
                   . ')';
          }
          else {
              $str .= colored('  (bindings unavailable)', 'yellow');
          }
      }
      return $str;
  };
  
  # DBIx::Class filters
  filter '-class' => sub {
      my ($obj, $properties) = @_;
  
      if ( $obj->isa('DBIx::Class::Schema') ) {
          return ref($obj) . ' DBIC Schema with ' . p( $obj->storage->dbh );
      }
      elsif ( grep { $obj->isa($_) } qw(DBIx::Class::ResultSet DBIx::Class::ResultSetColumn) ) {
  
          my $str = colored( ref($obj), $properties->{color}{class} );
          $str .= ' (' . $obj->result_class . ')'
            if $obj->can( 'result_class' );
  
          if (my $query_data = $obj->as_query) {
            my @query_data = @$$query_data;
            indent;
            my $sql = shift @query_data;
            $str .= ' {'
                 . newline . colored($sql, 'bright_yellow')
                 . newline . join ( newline, map {
                        $_->[1] . ' (' . $_->[0]{sqlt_datatype} . ')'
                      } @query_data
                 )
                 ;
            outdent;
            $str .= newline . '}';
          }
  
          return $str;
      }
      else {
          return;
      }
  };
  
  
  1;
  __END__
  
  =head1 NAME
  
  Data::Printer::Filter::DB - pretty printing database objects
  
  
  =head1 SYNOPSIS
  
  In your program:
  
    use Data::Printer filters => {
        -external => [ 'DB' ],
    };
  
  or, in your C<.dataprinter> file:
  
    {
      filters => {
        -external => [ 'DB' ],
      },
    };
  
  
  
  =head1 DESCRIPTION
  
  This is a filter plugin for L<Data::Printer>. It filters through
  L<DBI>'s handlers (dbh) and statement (sth) objects displaying relevant
  information for the user.
  
  L<DBI> is an extremely powerful and complete database interface. But
  it does a lot of magic under the hood, making their objects somewhat harder
  to debug. This filter aims to fix that :)
  
  For instance, say you want to debug something like this:
  
    use DBI;
    my $dbh = DBI->connect('dbi:DBM(RaiseError=1):', undef, undef );
  
  A regular Data::Dumper output gives you absolutely nothing:
  
  $VAR1 = bless( {}, 'DBI::db' );
  
  L<Data::Printer> makes it better, but only to debug the class itself,
  not helpful at all to see its contents and debug your own code:
  
      DBI::db  {
          Parents       DBI::common
          Linear @ISA   DBI::db, DBI::common
          public methods (48) : begin_work, clone, column_info, commit, connected, data_sources, disconnect, do, foreign_key_info, get_info, last_insert_id, ping, prepare, prepare_cached, preparse, primary_key, primary_key_info, quote, quote_identifier, rollback, rows, selectall_arrayref, selectall_hashref, selectcol_arrayref, selectrow_array, selectrow_arrayref, selectrow_hashref, sqlite_backup_from_file, sqlite_backup_to_file, sqlite_busy_timeout, sqlite_collation_needed, sqlite_commit_hook, sqlite_create_aggregate, sqlite_create_collation, sqlite_create_function, sqlite_enable_load_extension, sqlite_last_insert_rowid, sqlite_progress_handler, sqlite_register_fts3_perl_tokenizer, sqlite_rollback_hook, sqlite_set_authorizer, sqlite_update_hook, statistics_info, table_info, tables, take_imp_data, type_info, type_info_all
          private methods (0)
          internals: {
          }
      }
  
  Fear no more! If you use this filter, here's what you'll see:
  
      SQLite Database Handle (connected) {
          dbname: file.db
          Auto Commit: 1
          Statement Handles: 0
          Last Statement: -
      }
  
  Much better, huh? :)
  
  Statement handlers are even better. Imagine you continued your code with something like:
  
    my $sth = $dbh->prepare('SELECT * FROM foo WHERE bar = ?');
    $sth->execute(42);
  
  With this filter, instead of an empty dump or full method information, you'll get
  exactly what you came for:
  
   SELECT * FROM foo WHERE bar = ?  (42)
  
  Note that if your driver does not support holding of parameter values, you'll get a
  C<bindings unavailable> message instead of the bound values.
  
  
  =head1 SEE ALSO
  
  L<Data::Printer>
  
  
DATA_PRINTER_FILTER_DB

$fatpacked{"Data/Printer/Filter/DateTime.pm"} = <<'DATA_PRINTER_FILTER_DATETIME';
  package Data::Printer::Filter::DateTime;
  use strict;
  use warnings;
  use Data::Printer::Filter;
  use Term::ANSIColor;
  
  filter 'Time::Piece', sub {
      return _format($_[0]->cdate, @_ );
  };
  
  filter 'DateTime', sub {
      my ($obj, $p) = @_;
      my $string = "$obj";
      if ( not exists $p->{datetime}{show_timezone} or $p->{datetime}{show_timezone} ) {
          $string .= ' [' . $obj->time_zone->name . ']';
      }
      return _format( $string, @_ );
  };
  
  # DateTime::TimeZone filters
  filter '-class' => sub {
      my ($obj, $properties) = @_;
  
      if ( $obj->isa('DateTime::TimeZone' ) ) {
          return $obj->name;
      }
      else {
          return;
      }
  };
  
  filter 'DateTime::Incomplete', sub {
      return _format( $_[0]->iso8601, @_ );
  };
  
  filter 'DateTime::Duration', sub {
      my ($object, $p) = @_;
  
      my @dur = $object->in_units(
           qw(years months days hours minutes seconds)
      );
  
      my $string = "$dur[0]y $dur[1]m $dur[2]d $dur[3]h $dur[4]m $dur[5]s";
  
      return _format( $string, @_ );
  };
  
  filter 'DateTime::Tiny', sub {
      return _format( $_[0]->as_string, @_ );
  };
  
  filter 'Date::Calc::Object', sub {
      return _format( $_[0]->string(2), @_ );
  };
  
  filter 'Date::Pcalc::Object', sub {
      return _format( $_[0]->string(2), @_ );
  };
  
  filter 'Date::Handler', sub {
      return _format( "$_[0]", @_ );
  };
  
  filter 'Date::Handler::Delta', sub {
      return _format( $_[0]->AsScalar, @_ );
  };
  
  
  sub _format {
      my ($str, $obj, $p) = @_;
  
      if ( $p->{datetime}{show_class_name} ) {
          $str .= ' (' . ref($obj) . ')';
      }
  
      my $color = $p->{color}{datetime};
      $color = 'bright_green' unless defined $color;
  
      return colored( $str, $color );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Data::Printer::Filter::DateTime - pretty-printing date and time objects (not just DateTime!)
  
  =head1 SYNOPSIS
  
  In your program:
  
    use Data::Printer filters => {
      -external => [ 'DateTime' ],
    };
  
  or, in your C<.dataprinter> file:
  
    {
      filters => {
         -external => [ 'DateTime' ],
      },
    };
  
  You can also setup color and display details:
  
    use Data::Printer
        filters => {
            -external => [ 'DateTime' ],
        },
        color   => {
            datetime => 'bright_green',
        }
        datetime => {
            show_class_name => 1,  # default is 0
            show_timezone   => 0,  # default is 1 (only works for DateTime objects)
        },
    };
  
  =head1 DESCRIPTION
  
  This is a filter plugin for L<Data::Printer>. It filters through
  several date and time manipulation classes and displays the time
  (or time duration) as a string.
  
  =head2 Parsed Modules
  
  =over 4
  
  =item * L<DateTime>
  
  =item * L<DateTime::Duration>
  
  =item * L<DateTime::Incomplete>
  
  =item * L<Time::Piece>
  
  =item * L<Date::Handler>
  
  =item * L<Date::Handler::Delta>
  
  =item * L<Date::Calc::Object>
  
  =item * L<Date::Pcalc::Object>
  
  =back
  
  If you have any suggestions for more modules or better output,
  please let us know.
  
  
  =head1 SEE ALSO
  
  L<Data::Printer>
  
  
DATA_PRINTER_FILTER_DATETIME

$fatpacked{"Data/Printer/Filter/Digest.pm"} = <<'DATA_PRINTER_FILTER_DIGEST';
  package Data::Printer::Filter::Digest;
  use strict;
  use warnings;
  use Data::Printer::Filter;
  use Term::ANSIColor;
  
  foreach my $digest ( qw( Digest::MD2 Digest::MD4 Digest::Haval256)) {
      filter $digest => \&_print_digest;
  }
  
  filter '-class', sub {
    my ($obj, $p) = @_;
    return unless $obj->isa( 'Digest::base' );
    return _print_digest( $obj, $p );
  };
  
  
  sub _print_digest {
    my ($obj, $p) = @_;
    my $digest = $obj->clone->hexdigest;
    my $str = $digest;
    my $ref = ref $obj;
  
    if ( $p->{digest}{show_class_name} ) {
        $str .= " ($ref)";
    }
  
    unless ( exists  $p->{digest}{show_reset}
                and !$p->{digest}{show_reset}
     ) {
       if ($digest eq $ref->new->hexdigest) {
           $str .= ' [reset]';
       }
    }
  
    my $color = $p->{color}{digest};
    $color = 'bright_green' unless defined $color;
  
    return colored( $str, $color );
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Data::Printer::Filter::Digest - pretty-printing MD5, SHA and friends
  
  =head1 SYNOPSIS
  
  In your program:
  
    use Data::Printer filters => {
      -external => [ 'Digest' ],
    };
  
  or, in your C<.dataprinter> file:
  
    {
      filters => {
         -external => [ 'Digest' ],
      },
    };
  
  You can also setup color and display details:
  
    use Data::Printer
        filters => {
            -external => [ 'Digest' ],
        },
        color   => {
            digest => 'bright_green',
        }
        digest => {
            show_class_name => 0,  # default.
            show_reset      => 1,  # default.
        },
    };
  
  =head1 DESCRIPTION
  
  This is a filter plugin for L<Data::Printer>. It filters through
  several digest classes and displays their current value in
  hexadecimal format as a string.
  
  =head2 Parsed Modules
  
  =over 4
  
  =item * L<Digest::Adler32>
  
  =item * L<Digest::MD2>
  
  =item * L<Digest::MD4>
  
  =item * L<Digest::MD5>
  
  =item * L<Digest::SHA>
  
  =item * L<Digest::SHA1>
  
  =item * L<Digest::Whirlpool>
  
  =item * L<Digest::Haval256>
  
  =back
  
  If you have any suggestions for more modules or better output,
  please let us know.
  
  =head2 Extra Options
  
  Aside from the display color, there are a few other options to
  be customized via the C<digest> option key:
  
  =head3 show_class_name
  
  Set this to true to display the class name right next to the
  hexadecimal digest. Default is 0 (false).
  
  =head3 show_reset
  
  If set to true (the default), the filter will add a C<[reset]>
  tag after dumping an empty digest object. See the rationale below.
  
  =head2 Note on dumping Digest::* objects
  
  The digest operation is effectively a destructive, read-once operation. Once it has been performed, most Digest::* objects are automatically reset and can be used to calculate another digest value.
  
  This behaviour - or, rather, forgetting about this behaviour - is
  a common source of issues when working with Digests.
  
  This Data::Printer filter will B<not> destroy your object. Instead, we work on a cloned version to display the hexdigest, leaving your
  original object untouched.
  
  As another debugging convenience for developers, since the empty
  object will produce a digest even after being used, this filter
  adds by default a C<[reset]> tag to indicate that the object is
  empty, in a 'reset' state - i.e. its hexdigest is the same as
  the hexdigest of a new, empty object of that same class.
  
  =head1 SEE ALSO
  
  L<Data::Printer>
  
  
DATA_PRINTER_FILTER_DIGEST

$fatpacked{"Fatal.pm"} = <<'FATAL';
  package Fatal;
  
  # ABSTRACT: Replace functions with equivalents which succeed or die
  
  use 5.008;  # 5.8.x needed for autodie
  use Carp;
  use strict;
  use warnings;
  use Tie::RefHash;   # To cache subroutine refs
  use Config;
  use Scalar::Util qw(set_prototype);
  
  use constant PERL510     => ( $] >= 5.010 );
  
  use constant LEXICAL_TAG => q{:lexical};
  use constant VOID_TAG    => q{:void};
  use constant INSIST_TAG  => q{!};
  
  use constant ERROR_NOARGS    => 'Cannot use lexical %s with no arguments';
  use constant ERROR_VOID_LEX  => VOID_TAG.' cannot be used with lexical scope';
  use constant ERROR_LEX_FIRST => LEXICAL_TAG.' must be used as first argument';
  use constant ERROR_NO_LEX    => "no %s can only start with ".LEXICAL_TAG;
  use constant ERROR_BADNAME   => "Bad subroutine name for %s: %s";
  use constant ERROR_NOTSUB    => "%s is not a Perl subroutine";
  use constant ERROR_NOT_BUILT => "%s is neither a builtin, nor a Perl subroutine";
  use constant ERROR_NOHINTS   => "No user hints defined for %s";
  
  use constant ERROR_CANT_OVERRIDE => "Cannot make the non-overridable builtin %s fatal";
  
  use constant ERROR_NO_IPC_SYS_SIMPLE => "IPC::System::Simple required for Fatalised/autodying system()";
  
  use constant ERROR_IPC_SYS_SIMPLE_OLD => "IPC::System::Simple version %f required for Fatalised/autodying system().  We only have version %f";
  
  use constant ERROR_AUTODIE_CONFLICT => q{"no autodie '%s'" is not allowed while "use Fatal '%s'" is in effect};
  
  use constant ERROR_FATAL_CONFLICT => q{"use Fatal '%s'" is not allowed while "no autodie '%s'" is in effect};
  
  use constant ERROR_58_HINTS => q{Non-subroutine %s hints for %s are not supported under Perl 5.8.x};
  
  # Older versions of IPC::System::Simple don't support all the
  # features we need.
  
  use constant MIN_IPC_SYS_SIMPLE_VER => 0.12;
  
  our $VERSION = '2.20'; # VERSION: Generated by DZP::OurPkg::Version
  
  our $Debug ||= 0;
  
  # EWOULDBLOCK values for systems that don't supply their own.
  # Even though this is defined with our, that's to help our
  # test code.  Please don't rely upon this variable existing in
  # the future.
  
  our %_EWOULDBLOCK = (
      MSWin32 => 33,
  );
  
  # the linux parisc port has separate EAGAIN and EWOULDBLOCK,
  # and the kernel returns EAGAIN
  my $try_EAGAIN = ($^O eq 'linux' and $Config{archname} =~ /hppa|parisc/) ? 1 : 0;
  
  # We have some tags that can be passed in for use with import.
  # These are all assumed to be CORE::
  
  my %TAGS = (
      ':io'      => [qw(:dbm :file :filesys :ipc :socket
                         read seek sysread syswrite sysseek )],
      ':dbm'     => [qw(dbmopen dbmclose)],
      ':file'    => [qw(open close flock sysopen fcntl fileno binmode
                       ioctl truncate)],
      ':filesys' => [qw(opendir closedir chdir link unlink rename mkdir
                        symlink rmdir readlink umask chmod chown utime)],
      ':ipc'     => [qw(:msg :semaphore :shm pipe kill)],
      ':msg'     => [qw(msgctl msgget msgrcv msgsnd)],
      ':threads' => [qw(fork)],
      ':semaphore'=>[qw(semctl semget semop)],
      ':shm'     => [qw(shmctl shmget shmread)],
      ':system'  => [qw(system exec)],
  
      # Can we use qw(getpeername getsockname)? What do they do on failure?
      # TODO - Can socket return false?
      ':socket'  => [qw(accept bind connect getsockopt listen recv send
                     setsockopt shutdown socketpair)],
  
      # Our defaults don't include system(), because it depends upon
      # an optional module, and it breaks the exotic form.
      #
      # This *may* change in the future.  I'd love IPC::System::Simple
      # to be a dependency rather than a recommendation, and hence for
      # system() to be autodying by default.
  
      ':default' => [qw(:io :threads)],
  
      # Everything in v2.07 and brefore. This was :default less chmod and chown
      ':v207'    => [qw(:threads :dbm :socket read seek sysread
                     syswrite sysseek open close flock sysopen fcntl fileno
                     binmode ioctl truncate opendir closedir chdir link unlink
                     rename mkdir symlink rmdir readlink umask
                     :msg :semaphore :shm pipe)],
  
      # Chmod was added in 2.13
      ':v213'    => [qw(:v207 chmod)],
  
      # chown, utime, kill were added in 2.14
      ':v214'    => [qw(:v213 chown utime kill)],
  
      # Version specific tags.  These allow someone to specify
      # use autodie qw(:1.994) and know exactly what they'll get.
  
      ':1.994' => [qw(:v207)],
      ':1.995' => [qw(:v207)],
      ':1.996' => [qw(:v207)],
      ':1.997' => [qw(:v207)],
      ':1.998' => [qw(:v207)],
      ':1.999' => [qw(:v207)],
      ':1.999_01' => [qw(:v207)],
      ':2.00'  => [qw(:v207)],
      ':2.01'  => [qw(:v207)],
      ':2.02'  => [qw(:v207)],
      ':2.03'  => [qw(:v207)],
      ':2.04'  => [qw(:v207)],
      ':2.05'  => [qw(:v207)],
      ':2.06'  => [qw(:v207)],
      ':2.06_01' => [qw(:v207)],
      ':2.07'  => [qw(:v207)],     # Last release without chmod
      ':2.08'  => [qw(:v213)],
      ':2.09'  => [qw(:v213)],
      ':2.10'  => [qw(:v213)],
      ':2.11'  => [qw(:v213)],
      ':2.12'  => [qw(:v213)],
      ':2.13'  => [qw(:v213)],
      ':2.14'  => [qw(:default)],
      ':2.15'  => [qw(:default)],
      ':2.16'  => [qw(:default)],
      ':2.17'  => [qw(:default)],
      ':2.18'  => [qw(:default)],
      ':2.19'  => [qw(:default)],
      ':2.20'  => [qw(:default)],
  );
  
  # chmod was only introduced in 2.07
  # chown was only introduced in 2.14
  
  $TAGS{':all'}  = [ keys %TAGS ];
  
  # This hash contains subroutines for which we should
  # subroutine() // die() rather than subroutine() || die()
  
  my %Use_defined_or;
  
  # CORE::open returns undef on failure.  It can legitimately return
  # 0 on success, eg: open(my $fh, '-|') || exec(...);
  
  @Use_defined_or{qw(
      CORE::fork
      CORE::recv
      CORE::send
      CORE::open
      CORE::fileno
      CORE::read
      CORE::readlink
      CORE::sysread
      CORE::syswrite
      CORE::sysseek
      CORE::umask
  )} = ();
  
  # Some functions can return true because they changed *some* things, but
  # not all of them.  This is a list of offending functions, and how many
  # items to subtract from @_ to determine the "success" value they return.
  
  my %Returns_num_things_changed = (
      'CORE::chmod'  => 1,
      'CORE::chown'  => 2,
      'CORE::kill'   => 1,  # TODO: Could this return anything on negative args?
      'CORE::unlink' => 0,
      'CORE::utime'  => 2,
  );
  
  # Optional actions to take on the return value before returning it.
  
  my %Retval_action = (
      "CORE::open"        => q{
  
      # apply the open pragma from our caller
      if( defined $retval ) {
          # Get the caller's hint hash
          my $hints = (caller 0)[10];
  
          # Decide if we're reading or writing and apply the appropriate encoding
          # These keys are undocumented.
          # Match what PerlIO_context_layers() does.  Read gets the read layer,
          # everything else gets the write layer.
          my $encoding = $_[1] =~ /^\+?>/ ? $hints->{"open>"} : $hints->{"open<"};
  
          # Apply the encoding, if any.
          if( $encoding ) {
              binmode $_[0], $encoding;
          }
      }
  
  },
      "CORE::sysopen"     => q{
  
      # apply the open pragma from our caller
      if( defined $retval ) {
          # Get the caller's hint hash
          my $hints = (caller 0)[10];
  
          require Fcntl;
  
          # Decide if we're reading or writing and apply the appropriate encoding.
          # Match what PerlIO_context_layers() does.  Read gets the read layer,
          # everything else gets the write layer.
          my $open_read_only = !($_[2] ^ Fcntl::O_RDONLY());
          my $encoding = $open_read_only ? $hints->{"open<"} : $hints->{"open>"};
  
          # Apply the encoding, if any.
          if( $encoding ) {
              binmode $_[0], $encoding;
          }
      }
  
  },
  );
  
  my %reusable_builtins;
  
  # "Wait!" I hear you cry, "truncate() and chdir() are not reuseable! They can
  # take file and directory handles, which are package depedent."
  #
  # You would be correct, except that prototype() returns signatures which don't
  # allow for passing of globs, and nobody's complained about that. You can
  # still use \*FILEHANDLE, but that results in a reference coming through,
  # and it's already pointing to the filehandle in the caller's packge, so
  # it's all okay.
  
  @reusable_builtins{qw(
      CORE::fork
      CORE::kill
      CORE::truncate
      CORE::chdir
      CORE::link
      CORE::unlink
      CORE::rename
      CORE::mkdir
      CORE::symlink
      CORE::rmdir
      CORE::readlink
      CORE::umask
      CORE::chmod
      CORE::chown
      CORE::utime
      CORE::msgctl
      CORE::msgget
      CORE::msgrcv
      CORE::msgsnd
      CORE::semctl
      CORE::semget
      CORE::semop
      CORE::shmctl
      CORE::shmget
      CORE::shmread
  )} = ();
  
  # Cached_fatalised_sub caches the various versions of our
  # fatalised subs as they're produced.  This means we don't
  # have to build our own replacement of CORE::open and friends
  # for every single package that wants to use them.
  
  my %Cached_fatalised_sub = ();
  
  # Every time we're called with package scope, we record the subroutine
  # (including package or CORE::) in %Package_Fatal.  This allows us
  # to detect illegal combinations of autodie and Fatal, and makes sure
  # we don't accidently make a Fatal function autodying (which isn't
  # very useful).
  
  my %Package_Fatal = ();
  
  # The first time we're called with a user-sub, we cache it here.
  # In the case of a "no autodie ..." we put back the cached copy.
  
  my %Original_user_sub = ();
  
  # Is_fatalised_sub simply records a big map of fatalised subroutine
  # refs.  It means we can avoid repeating work, or fatalising something
  # we've already processed.
  
  my  %Is_fatalised_sub = ();
  tie %Is_fatalised_sub, 'Tie::RefHash';
  
  # Our trampoline cache allows us to cache trampolines which are used to
  # bounce leaked wrapped core subroutines to their actual core counterparts.
  
  my %Trampoline_cache;
  
  # We use our package in a few hash-keys.  Having it in a scalar is
  # convenient.  The "guard $PACKAGE" string is used as a key when
  # setting up lexical guards.
  
  my $PACKAGE       = __PACKAGE__;
  my $PACKAGE_GUARD = "guard $PACKAGE";
  my $NO_PACKAGE    = "no $PACKAGE";      # Used to detect 'no autodie'
  
  # Here's where all the magic happens when someone write 'use Fatal'
  # or 'use autodie'.
  
  sub import {
      my $class        = shift(@_);
      my @original_args = @_;
      my $void         = 0;
      my $lexical      = 0;
      my $insist_hints = 0;
  
      my ($pkg, $filename) = caller();
  
      @_ or return;   # 'use Fatal' is a no-op.
  
      # If we see the :lexical flag, then _all_ arguments are
      # changed lexically
  
      if ($_[0] eq LEXICAL_TAG) {
          $lexical = 1;
          shift @_;
  
          # If we see no arguments and :lexical, we assume they
          # wanted ':default'.
  
          if (@_ == 0) {
              push(@_, ':default');
          }
  
          # Don't allow :lexical with :void, it's needlessly confusing.
          if ( grep { $_ eq VOID_TAG } @_ ) {
              croak(ERROR_VOID_LEX);
          }
      }
  
      if ( grep { $_ eq LEXICAL_TAG } @_ ) {
          # If we see the lexical tag as the non-first argument, complain.
          croak(ERROR_LEX_FIRST);
      }
  
      my @fatalise_these =  @_;
  
      # Thiese subs will get unloaded at the end of lexical scope.
      my %unload_later;
  
      # Use _translate_import_args to expand tags for us.  It will
      # pass-through unknown tags (i.e. we have to manually handle
      # VOID_TAG).
      #
      # TODO: Consider how to handle stuff like:
      #   use autodie qw(:defaults ! :io);
      #   use Fatal qw(:defaults :void :io);
      #
      # The ! and :void is currently not applied to anything in the
      # example above since duplicates are filtered out.  This has been
      # autodie's behaviour for quite a while, but it might make sense
      # to change it so "!" or ":void" applies to stuff after they
      # appear (even if they are all duplicates).
      for my $func ($class->_translate_import_args(@fatalise_these)) {
  
          if ($func eq VOID_TAG) {
  
              # When we see :void, set the void flag.
              $void = 1;
  
          } elsif ($func eq INSIST_TAG) {
  
              $insist_hints = 1;
  
          } else {
  
              # Otherwise, fatalise it.
  
              # Check to see if there's an insist flag at the front.
              # If so, remove it, and insist we have hints for this sub.
              my $insist_this;
  
              if ($func =~ s/^!//) {
                  $insist_this = 1;
              }
  
              # We're going to make a subroutine fatalistic.
              # However if we're being invoked with 'use Fatal qw(x)'
              # and we've already been called with 'no autodie qw(x)'
              # in the same scope, we consider this to be an error.
              # Mixing Fatal and autodie effects was considered to be
              # needlessly confusing on p5p.
  
              my $sub = $func;
              $sub = "${pkg}::$sub" unless $sub =~ /::/;
  
              # If we're being called as Fatal, and we've previously
              # had a 'no X' in scope for the subroutine, then complain
              # bitterly.
  
              if (! $lexical and $^H{$NO_PACKAGE}{$sub}) {
                   croak(sprintf(ERROR_FATAL_CONFLICT, $func, $func));
              }
  
              # We're not being used in a confusing way, so make
              # the sub fatal.  Note that _make_fatal returns the
              # old (original) version of the sub, or undef for
              # built-ins.
  
              my $sub_ref = $class->_make_fatal(
                  $func, $pkg, $void, $lexical, $filename,
                  ( $insist_this || $insist_hints )
              );
  
              $Original_user_sub{$sub} ||= $sub_ref;
  
              # If we're making lexical changes, we need to arrange
              # for them to be cleaned at the end of our scope, so
              # record them here.
  
              $unload_later{$func} = $sub_ref if $lexical;
          }
      }
  
      if ($lexical) {
  
          # Dark magic to have autodie work under 5.8
          # Copied from namespace::clean, that copied it from
          # autobox, that found it on an ancient scroll written
          # in blood.
  
          # This magic bit causes %^H to be lexically scoped.
  
          $^H |= 0x020000;
  
          # Our package guard gets invoked when we leave our lexical
          # scope.
  
          push(@ { $^H{$PACKAGE_GUARD} }, autodie::Scope::Guard->new(sub {
              $class->_install_subs($pkg, \%unload_later);
          }));
  
          # To allow others to determine when autodie was in scope,
          # and with what arguments, we also set a %^H hint which
          # is how we were called.
  
          # This feature should be considered EXPERIMENTAL, and
          # may change without notice.  Please e-mail pjf@cpan.org
          # if you're actually using it.
  
          $^H{autodie} = "$PACKAGE @original_args";
  
      }
  
      return;
  
  }
  
  # The code here is originally lifted from namespace::clean,
  # by Robert "phaylon" Sedlacek.
  #
  # It's been redesigned after feedback from ikegami on perlmonks.
  # See http://perlmonks.org/?node_id=693338 .  Ikegami rocks.
  #
  # Given a package, and hash of (subname => subref) pairs,
  # we install the given subroutines into the package.  If
  # a subref is undef, the subroutine is removed.  Otherwise
  # it replaces any existing subs which were already there.
  
  sub _install_subs {
      my ($class, $pkg, $subs_to_reinstate) = @_;
  
      my $pkg_sym = "${pkg}::";
  
      # It does not hurt to do this in a predictable order, and might help debugging.
      foreach my $sub_name (sort keys %$subs_to_reinstate) {
          my $sub_ref= $subs_to_reinstate->{$sub_name};
  
          my $full_path = $pkg_sym.$sub_name;
  
          # Copy symbols across to temp area.
  
          no strict 'refs';   ## no critic
  
          local *__tmp = *{ $full_path };
  
          # Nuke the old glob.
          { no strict; delete $pkg_sym->{$sub_name}; }    ## no critic
  
          # Copy innocent bystanders back.  Note that we lose
          # formats; it seems that Perl versions up to 5.10.0
          # have a bug which causes copying formats to end up in
          # the scalar slot.  Thanks to Ben Morrow for spotting this.
  
          foreach my $slot (qw( SCALAR ARRAY HASH IO ) ) {
              next unless defined *__tmp{ $slot };
              *{ $full_path } = *__tmp{ $slot };
          }
  
          # Put back the old sub (if there was one).
  
          if ($sub_ref) {
  
              no strict;  ## no critic
              *{ $full_path } = $sub_ref;
          }
      }
  
      return;
  }
  
  sub unimport {
      my $class = shift;
  
      # Calling "no Fatal" must start with ":lexical"
      if ($_[0] ne LEXICAL_TAG) {
          croak(sprintf(ERROR_NO_LEX,$class));
      }
  
      shift @_;   # Remove :lexical
  
      my $pkg = (caller)[0];
  
      # If we've been called with arguments, then the developer
      # has explicitly stated 'no autodie qw(blah)',
      # in which case, we disable Fatalistic behaviour for 'blah'.
  
      my @unimport_these = @_ ? @_ : ':all';
  
      for my $symbol ($class->_translate_import_args(@unimport_these)) {
  
          my $sub = $symbol;
          $sub = "${pkg}::$sub" unless $sub =~ /::/;
  
          # If 'blah' was already enabled with Fatal (which has package
          # scope) then, this is considered an error.
  
          if (exists $Package_Fatal{$sub}) {
              croak(sprintf(ERROR_AUTODIE_CONFLICT,$symbol,$symbol));
          }
  
          # Record 'no autodie qw($sub)' as being in effect.
          # This is to catch conflicting semantics elsewhere
          # (eg, mixing Fatal with no autodie)
  
          $^H{$NO_PACKAGE}{$sub} = 1;
  
          if (my $original_sub = $Original_user_sub{$sub}) {
              # Hey, we've got an original one of these, put it back.
              $class->_install_subs($pkg, { $symbol => $original_sub });
              next;
          }
  
          # We don't have an original copy of the sub, on the assumption
          # it's core (or doesn't exist), we'll just nuke it.
  
          $class->_install_subs($pkg,{ $symbol => undef });
  
      }
  
      return;
  
  }
  
  sub _translate_import_args {
      my ($class, @args) = @_;
      my @result;
      for my $a (@args){
          if (exists $TAGS{$a}) {
              my $expanded = $class->_expand_tag($a);
              # Strip "CORE::" from all elements in the list as import and
              # unimport does not handle the "CORE::" prefix too well.
              #
              # NB: we use substr as it is faster than s/^CORE::// and
              # it does not change the elements.
              push @result, map { substr($_, 6) } @{$expanded};
          } else {
              #pass through
              push @result, $a;
          }
      }
      # If @args < 2, then we have no duplicates (because _expand_tag
      # does not have duplicates and if it is not a tag, it is just a
      # single value).  We optimize for this because it is a fairly
      # common case (e.g. use autodie; or use autodie qw(:all); both
      # trigger this).
      return @result if @args < 2;
  
      my %seen = ();
      # Yes, this is basically List::MoreUtils's uniq/distinct, but
      # List::MoreUtils is not in the Perl core and autodie is
      return grep { !$seen{$_}++ } @result;
  }
  
  
  # NB: Perl::Critic's dump-autodie-tag-contents depends upon this
  # continuing to work.
  
  {
      my %tag_cache;
  
      # Expand a given tag (e.g. ":default") into a listref containing
      # all sub names covered by that tag.  Each sub is returned as
      # "CORE::<name>" (i.e. "CORE::open" rather than "open").
      #
      # NB: the listref must not be modified.
      sub _expand_tag {
          my ($class, $tag) = @_;
  
          if (my $cached = $tag_cache{$tag}) {
              return $cached;
          }
  
          if (not exists $TAGS{$tag}) {
              croak "Invalid exception class $tag";
          }
  
          my @to_process = @{$TAGS{$tag}};
  
          # If the tag is basically an alias of another tag (like e.g. ":2.11"),
          # then just share the resulting reference with the original content (so
          # we only pay for an extra reference for the alias memory-wise).
          if (@to_process == 1 && substr($to_process[0], 0, 1) eq ':') {
              # We could do this for "non-tags" as well, but that only occurs
              # once at the time of writing (":threads" => ["fork"]), so
              # probably not worth it.
              my $expanded = $class->_expand_tag($to_process[0]);
              $tag_cache{$tag} = $expanded;
              return $expanded;
          }
  
          my %seen = ();
          my @taglist = ();
  
          for my $item (@to_process) {
              # substr is more efficient than m/^:/ for stuff like this,
              # at the price of being a bit more verbose/low-level.
              if (substr($item, 0, 1) eq ':') {
                  # Use recursion here to ensure we expand a tag at most once.
                  #
                  # TODO: Improve handling of :all so we don't expand
                  # all those aliases (e.g :2.00..:2.07 are all aliases
                  # of v2.07).
  
                  my $expanded = $class->_expand_tag($item);
                  push @taglist, grep { !$seen{$_}++ } @{$expanded};
              } else {
                  my $subname = "CORE::$item";
                  push @taglist, $subname
                      unless $seen{$subname}++;
              }
          }
  
          $tag_cache{$tag} = \@taglist;
  
          return \@taglist;
  
      }
  
  }
  
  # This code is from the original Fatal.  It scares me.
  # It is 100% compatible with the 5.10.0 Fatal module, right down
  # to the scary 'XXXX' comment.  ;)
  
  sub fill_protos {
      my $proto = shift;
      my ($n, $isref, @out, @out1, $seen_semi) = -1;
      if ($proto =~ m{^\s* (?: [;] \s*)? \@}x) {
          # prototype is entirely slurp - special case that does not
          # require any handling.
          return ([0, '@_']);
      }
  
      while ($proto =~ /\S/) {
          $n++;
          push(@out1,[$n,@out]) if $seen_semi;
          push(@out, $1 . "{\$_[$n]}"), next if $proto =~ s/^\s*\\([\@%\$\&])//;
          push(@out, "\$_[$n]"),        next if $proto =~ s/^\s*([_*\$&])//;
          push(@out, "\@_[$n..\$#_]"),  last if $proto =~ s/^\s*(;\s*)?\@//;
          $seen_semi = 1, $n--,         next if $proto =~ s/^\s*;//; # XXXX ????
          die "Internal error: Unknown prototype letters: \"$proto\"";
      }
      push(@out1,[$n+1,@out]);
      return @out1;
  }
  
  # This is a backwards compatible version of _write_invocation.  It's
  # recommended you don't use it.
  
  sub write_invocation {
      my ($core, $call, $name, $void, @args) = @_;
  
      return Fatal->_write_invocation(
          $core, $call, $name, $void,
          0,      # Lexical flag
          undef,  # Sub, unused in legacy mode
          undef,  # Subref, unused in legacy mode.
          @args
      );
  }
  
  # This version of _write_invocation is used internally.  It's not
  # recommended you call it from external code, as the interface WILL
  # change in the future.
  
  sub _write_invocation {
  
      my ($class, $core, $call, $name, $void, $lexical, $sub, $sref, @argvs) = @_;
  
      if (@argvs == 1) {        # No optional arguments
  
          my @argv = @{$argvs[0]};
          shift @argv;
  
          return $class->_one_invocation($core,$call,$name,$void,$sub,! $lexical, $sref, @argv);
  
      } else {
          my $else = "\t";
          my (@out, @argv, $n);
          while (@argvs) {
              @argv = @{shift @argvs};
              $n = shift @argv;
  
              my $condition = "\@_ == $n";
  
              if (@argv and $argv[-1] =~ /[#@]_/) {
                  # This argv ends with '@' in the prototype, so it matches
                  # any number of args >= the number of expressions in the
                  # argv.
                  $condition = "\@_ >= $n";
              }
  
              push @out, "${else}if ($condition) {\n";
  
              $else = "\t} els";
  
          push @out, $class->_one_invocation($core,$call,$name,$void,$sub,! $lexical, $sref, @argv);
          }
          push @out, qq[
              }
              die "Internal error: $name(\@_): Do not expect to get ", scalar(\@_), " arguments";
      ];
  
          return join '', @out;
      }
  }
  
  
  # This is a slim interface to ensure backward compatibility with
  # anyone doing very foolish things with old versions of Fatal.
  
  sub one_invocation {
      my ($core, $call, $name, $void, @argv) = @_;
  
      return Fatal->_one_invocation(
          $core, $call, $name, $void,
          undef,   # Sub.  Unused in back-compat mode.
          1,       # Back-compat flag
          undef,   # Subref, unused in back-compat mode.
          @argv
      );
  
  }
  
  # This is the internal interface that generates code.
  # NOTE: This interface WILL change in the future.  Please do not
  # call this subroutine directly.
  
  # TODO: Whatever's calling this code has already looked up hints.  Pass
  # them in, rather than look them up a second time.
  
  sub _one_invocation {
      my ($class, $core, $call, $name, $void, $sub, $back_compat, $sref, @argv) = @_;
  
  
      # If someone is calling us directly (a child class perhaps?) then
      # they could try to mix void without enabling backwards
      # compatibility.  We just don't support this at all, so we gripe
      # about it rather than doing something unwise.
  
      if ($void and not $back_compat) {
          Carp::confess("Internal error: :void mode not supported with $class");
      }
  
      # @argv only contains the results of the in-built prototype
      # function, and is therefore safe to interpolate in the
      # code generators below.
  
      # TODO - The following clobbers context, but that's what the
      #        old Fatal did.  Do we care?
  
      if ($back_compat) {
  
          # Use Fatal qw(system) will never be supported.  It generated
          # a compile-time error with legacy Fatal, and there's no reason
          # to support it when autodie does a better job.
  
          if ($call eq 'CORE::system') {
              return q{
                  croak("UNIMPLEMENTED: use Fatal qw(system) not supported.");
              };
          }
  
          local $" = ', ';
  
          if ($void) {
              return qq/return (defined wantarray)?$call(@argv):
                     $call(@argv) || Carp::croak("Can't $name(\@_)/ .
                     ($core ? ': $!' : ', \$! is \"$!\"') . '")'
          } else {
              return qq{return $call(@argv) || Carp::croak("Can't $name(\@_)} .
                     ($core ? ': $!' : ', \$! is \"$!\"') . '")';
          }
      }
  
      # The name of our original function is:
      #   $call if the function is CORE
      #   $sub if our function is non-CORE
  
      # The reason for this is that $call is what we're actually
      # calling.  For our core functions, this is always
      # CORE::something.  However for user-defined subs, we're about to
      # replace whatever it is that we're calling; as such, we actually
      # calling a subroutine ref.
  
      my $human_sub_name = $core ? $call : $sub;
  
      # Should we be testing to see if our result is defined, or
      # just true?
  
      my $use_defined_or;
  
      my $hints;      # All user-sub hints, including list hints.
  
      if ( $core ) {
  
          # Core hints are built into autodie.
  
          $use_defined_or = exists ( $Use_defined_or{$call} );
  
      }
      else {
  
          # User sub hints are looked up using autodie::hints,
          # since users may wish to add their own hints.
  
          require autodie::hints;
  
          $hints = autodie::hints->get_hints_for( $sref );
  
          # We'll look up the sub's fullname.  This means we
          # get better reports of where it came from in our
          # error messages, rather than what imported it.
  
          $human_sub_name = autodie::hints->sub_fullname( $sref );
  
      }
  
      # Checks for special core subs.
  
      if ($call eq 'CORE::system') {
  
          # Leverage IPC::System::Simple if we're making an autodying
          # system.
  
          local $" = ", ";
  
          # We need to stash $@ into $E, rather than using
          # local $@ for the whole sub.  If we don't then
          # any exceptions from internal errors in autodie/Fatal
          # will mysteriously disappear before propagating
          # upwards.
  
          return qq{
              my \$retval;
              my \$E;
  
  
              {
                  local \$@;
  
                  eval {
                      \$retval = IPC::System::Simple::system(@argv);
                  };
  
                  \$E = \$@;
              }
  
              if (\$E) {
  
                  # TODO - This can't be overridden in child
                  # classes!
  
                  die autodie::exception::system->new(
                      function => q{CORE::system}, args => [ @argv ],
                      message => "\$E", errno => \$!,
                  );
              }
  
              return \$retval;
          };
  
      }
  
      local $" = ', ';
  
      # If we're going to throw an exception, here's the code to use.
      my $die = qq{
          die $class->throw(
              function => q{$human_sub_name}, args => [ @argv ],
              pragma => q{$class}, errno => \$!,
              context => \$context, return => \$retval,
              eval_error => \$@
          )
      };
  
      if ($call eq 'CORE::flock') {
  
          # flock needs special treatment.  When it fails with
          # LOCK_UN and EWOULDBLOCK, then it's not really fatal, it just
          # means we couldn't get the lock right now.
  
          require POSIX;      # For POSIX::EWOULDBLOCK
  
          local $@;   # Don't blat anyone else's $@.
  
          # Ensure that our vendor supports EWOULDBLOCK.  If they
          # don't (eg, Windows), then we use known values for its
          # equivalent on other systems.
  
          my $EWOULDBLOCK = eval { POSIX::EWOULDBLOCK(); }
                            || $_EWOULDBLOCK{$^O}
                            || _autocroak("Internal error - can't overload flock - EWOULDBLOCK not defined on this system.");
          my $EAGAIN = $EWOULDBLOCK;
          if ($try_EAGAIN) {
              $EAGAIN = eval { POSIX::EAGAIN(); }
                            || _autocroak("Internal error - can't overload flock - EAGAIN not defined on this system.");
          }
  
          require Fcntl;      # For Fcntl::LOCK_NB
  
          return qq{
  
              my \$context = wantarray() ? "list" : "scalar";
  
              # Try to flock.  If successful, return it immediately.
  
              my \$retval = $call(@argv);
              return \$retval if \$retval;
  
              # If we failed, but we're using LOCK_NB and
              # returned EWOULDBLOCK, it's not a real error.
  
              if (\$_[1] & Fcntl::LOCK_NB() and
                  (\$! == $EWOULDBLOCK or
                  ($try_EAGAIN and \$! == $EAGAIN ))) {
                  return \$retval;
              }
  
              # Otherwise, we failed.  Die noisily.
  
              $die;
  
          };
      }
  
      if (exists $Returns_num_things_changed{$call}) {
  
          # Some things return the number of things changed (like
          # chown, kill, chmod, etc). We only consider these successful
          # if *all* the things are changed.
  
          return qq[
              my \$num_things = \@_ - $Returns_num_things_changed{$call};
              my \$retval = $call(@argv);
  
              if (\$retval != \$num_things) {
  
                  # We need \$context to throw an exception.
                  # It's *always* set to scalar, because that's how
                  # autodie calls chown() above.
  
                  my \$context = "scalar";
                  $die;
              }
  
              return \$retval;
          ];
      }
  
      # AFAIK everything that can be given an unopned filehandle
      # will fail if it tries to use it, so we don't really need
      # the 'unopened' warning class here.  Especially since they
      # then report the wrong line number.
  
      # Other warnings are disabled because they produce excessive
      # complaints from smart-match hints under 5.10.1.
  
      my $code = qq[
          no warnings qw(unopened uninitialized numeric);
          no if \$\] >= 5.017011, warnings => "experimental::smartmatch";
  
          if (wantarray) {
              my \@results = $call(@argv);
              my \$retval  = \\\@results;
              my \$context = "list";
  
      ];
  
      my $retval_action = $Retval_action{$call} || '';
  
      if ( $hints and ( ref($hints->{list} ) || "" ) eq 'CODE' ) {
  
          # NB: Subroutine hints are passed as a full list.
          # This differs from the 5.10.0 smart-match behaviour,
          # but means that context unaware subroutines can use
          # the same hints in both list and scalar context.
  
          $code .= qq{
              if ( \$hints->{list}->(\@results) ) { $die };
          };
      }
      elsif ( PERL510 and $hints ) {
          $code .= qq{
              if ( \@results ~~ \$hints->{list} ) { $die };
          };
      }
      elsif ( $hints ) {
          croak sprintf(ERROR_58_HINTS, 'list', $sub);
      }
      else {
          $code .= qq{
              # An empty list, or a single undef is failure
              if (! \@results or (\@results == 1 and ! defined \$results[0])) {
                  $die;
              }
          }
      }
  
      # Tidy up the end of our wantarray call.
  
      $code .= qq[
              return \@results;
          }
      ];
  
  
      # Otherwise, we're in scalar context.
      # We're never in a void context, since we have to look
      # at the result.
  
      $code .= qq{
          my \$retval  = $call(@argv);
          my \$context = "scalar";
      };
  
      if ( $hints and ( ref($hints->{scalar} ) || "" ) eq 'CODE' ) {
  
          # We always call code refs directly, since that always
          # works in 5.8.x, and always works in 5.10.1
  
          return $code .= qq{
              if ( \$hints->{scalar}->(\$retval) ) { $die };
              $retval_action
              return \$retval;
          };
  
      }
      elsif (PERL510 and $hints) {
          return $code . qq{
  
              if ( \$retval ~~ \$hints->{scalar} ) { $die };
              $retval_action
              return \$retval;
          };
      }
      elsif ( $hints ) {
          croak sprintf(ERROR_58_HINTS, 'scalar', $sub);
      }
  
      return $code .
      ( $use_defined_or ? qq{
  
          $die if not defined \$retval;
          $retval_action
          return \$retval;
  
      } : qq{
  
          $retval_action
          return \$retval || $die;
  
      } ) ;
  
  }
  
  # This returns the old copy of the sub, so we can
  # put it back at end of scope.
  
  # TODO : Check to make sure prototypes are restored correctly.
  
  # TODO: Taking a huge list of arguments is awful.  Rewriting to
  #       take a hash would be lovely.
  
  # TODO - BACKCOMPAT - This is not yet compatible with 5.10.0
  
  sub _make_fatal {
      my($class, $sub, $pkg, $void, $lexical, $filename, $insist) = @_;
      my($name, $code, $sref, $real_proto, $proto, $core, $call, $hints);
      my $ini = $sub;
  
      $sub = "${pkg}::$sub" unless $sub =~ /::/;
  
      # Figure if we're using lexical or package semantics and
      # twiddle the appropriate bits.
  
      if (not $lexical) {
          $Package_Fatal{$sub} = 1;
      }
  
      # TODO - We *should* be able to do skipping, since we know when
      # we've lexicalised / unlexicalised a subroutine.
  
      $name = $sub;
      $name =~ s/.*::// or $name =~ s/^&//;
  
      warn  "# _make_fatal: sub=$sub pkg=$pkg name=$name void=$void\n" if $Debug;
      croak(sprintf(ERROR_BADNAME, $class, $name)) unless $name =~ /^\w+$/;
  
      if (defined(&$sub)) {   # user subroutine
  
          # NOTE: Previously we would localise $@ at this point, so
          # the following calls to eval {} wouldn't interfere with anything
          # that's already in $@.  Unfortunately, it would also stop
          # any of our croaks from triggering(!), which is even worse.
  
          # This could be something that we've fatalised that
          # was in core.
  
          if ( $Package_Fatal{$sub} and do { local $@; eval { prototype "CORE::$name" } } ) {
  
              # Something we previously made Fatal that was core.
              # This is safe to replace with an autodying to core
              # version.
  
              $core  = 1;
              $call  = "CORE::$name";
              $proto = prototype $call;
  
              # We return our $sref from this subroutine later
              # on, indicating this subroutine should be placed
              # back when we're finished.
  
              $sref = \&$sub;
  
          } else {
  
              # If this is something we've already fatalised or played with,
              # then look-up the name of the original sub for the rest of
              # our processing.
  
              $sub = $Is_fatalised_sub{\&$sub} || $sub;
  
              # A regular user sub, or a user sub wrapping a
              # core sub.
  
              $sref = \&$sub;
              $proto = prototype $sref;
              $call = '&$sref';
              require autodie::hints;
  
              $hints = autodie::hints->get_hints_for( $sref );
  
              # If we've insisted on hints, but don't have them, then
              # bail out!
  
              if ($insist and not $hints) {
                  croak(sprintf(ERROR_NOHINTS, $name));
              }
  
              # Otherwise, use the default hints if we don't have
              # any.
  
              $hints ||= autodie::hints::DEFAULT_HINTS();
  
          }
  
      } elsif ($sub eq $ini && $sub !~ /^CORE::GLOBAL::/) {
          # Stray user subroutine
          croak(sprintf(ERROR_NOTSUB,$sub));
  
      } elsif ($name eq 'system') {
  
          # If we're fatalising system, then we need to load
          # helper code.
  
          # The business with $E is to avoid clobbering our caller's
          # $@, and to avoid $@ being localised when we croak.
  
          my $E;
  
          {
              local $@;
  
              eval {
                  require IPC::System::Simple; # Only load it if we need it.
                  require autodie::exception::system;
              };
              $E = $@;
          }
  
          if ($E) { croak ERROR_NO_IPC_SYS_SIMPLE; }
  
          # Make sure we're using a recent version of ISS that actually
          # support fatalised system.
          if ($IPC::System::Simple::VERSION < MIN_IPC_SYS_SIMPLE_VER) {
              croak sprintf(
              ERROR_IPC_SYS_SIMPLE_OLD, MIN_IPC_SYS_SIMPLE_VER,
              $IPC::System::Simple::VERSION
              );
          }
  
          $call = 'CORE::system';
          $name = 'system';
          $core = 1;
  
      } elsif ($name eq 'exec') {
          # Exec doesn't have a prototype.  We don't care.  This
          # breaks the exotic form with lexical scope, and gives
          # the regular form a "do or die" behavior as expected.
  
          $call = 'CORE::exec';
          $name = 'exec';
          $core = 1;
  
      } else {            # CORE subroutine
          my $E;
          {
              local $@;
              $proto = eval { prototype "CORE::$name" };
              $E = $@;
          }
          croak(sprintf(ERROR_NOT_BUILT,$name)) if $E;
          croak(sprintf(ERROR_CANT_OVERRIDE,$name)) if not defined $proto;
          $core = 1;
          $call = "CORE::$name";
      }
  
      my $true_name = $core ? $call : $sub;
  
      # TODO: This caching works, but I don't like using $void and
      # $lexical as keys.  In particular, I suspect our code may end up
      # wrapping already wrapped code when autodie and Fatal are used
      # together.
  
      # NB: We must use '$sub' (the name plus package) and not
      # just '$name' (the short name) here.  Failing to do so
      # results code that's in the wrong package, and hence has
      # access to the wrong package filehandles.
  
      if (my $subref = $Cached_fatalised_sub{$class}{$sub}{$void}{$lexical}) {
          $class->_install_subs($pkg, { $name => $subref });
          return $sref;
      }
  
      # If our subroutine is reusable (ie, not package depdendent),
      # then check to see if we've got a cached copy, and use that.
      # See RT #46984. (Thanks to Niels Thykier for being awesome!)
  
      if ($core && exists $reusable_builtins{$call}) {
          # For non-lexical subs, we can just use this cache directly
          # - for lexical variants, we need a leak guard as well.
          $code = $reusable_builtins{$call}{$lexical};
          if (!$lexical && defined($code)) {
              $class->_install_subs($pkg, { $name => $code });
              return $sref;
          }
      }
  
      if (defined $proto) {
          $real_proto = " ($proto)";
      } else {
          $real_proto = '';
          $proto = '@';
      }
  
      if (!defined($code)) {
          # No code available, generate it now.
          my @protos = fill_protos($proto);
  
          $code = qq[
              sub$real_proto {
                local(\$", \$!) = (', ', 0);    # TODO - Why do we do this?
          ];
  
          # Don't have perl whine if exec fails, since we'll be handling
          # the exception now.
          $code .= "no warnings qw(exec);\n" if $call eq "CORE::exec";
  
          $code .= $class->_write_invocation($core, $call, $name, $void, $lexical,
                                             $sub, $sref, @protos);
          $code .= "}\n";
          warn $code if $Debug;
  
          # I thought that changing package was a monumental waste of
          # time for CORE subs, since they'll always be the same.  However
          # that's not the case, since they may refer to package-based
          # filehandles (eg, with open).
          #
          # The %reusable_builtins hash defines ones we can aggressively
          # cache as they never depend upon package-based symbols.
  
          {
              no strict 'refs'; ## no critic # to avoid: Can't use string (...) as a symbol ref ...
  
              my $E;
  
              {
                  local $@;
                  if (!exists($reusable_builtins{$call})) {
                      $code = eval("package $pkg; require Carp; $code");  ## no critic
                  } else {
                      $code = eval("require Carp; $code");  ## no critic
                      if (exists $reusable_builtins{$call}) {
                          # cache it so we don't recompile this part again
                          $reusable_builtins{$call}{$lexical} = $code;
                      }
                  }
                  $E = $@;
              }
  
              if (not $code) {
                  croak("Internal error in autodie/Fatal processing $true_name: $E");
  
              }
          }
      }
  
      # Now we need to wrap our fatalised sub inside an itty bitty
      # closure, which can detect if we've leaked into another file.
      # Luckily, we only need to do this for lexical (autodie)
      # subs.  Fatal subs can leak all they want, it's considered
      # a "feature" (or at least backwards compatible).
  
      # TODO: Cache our leak guards!
  
      # TODO: This is pretty hairy code.  A lot more tests would
      # be really nice for this.
  
      my $leak_guard;
  
      if ($lexical) {
          $leak_guard = _make_leak_guard($filename, $code, $sref, $call,
                                         $pkg, $proto, $real_proto);
      }
  
      my $installed_sub = $leak_guard || $code;
  
      $class->_install_subs($pkg, { $name => $installed_sub });
  
      $Cached_fatalised_sub{$class}{$sub}{$void}{$lexical} = $installed_sub;
  
      # Cache that we've now overridden this sub.  If we get called
      # again, we may need to find that find subroutine again (eg, for hints).
  
      $Is_fatalised_sub{$installed_sub} = $sref;
  
      return $sref;
  
  }
  
  # This subroutine exists primarily so that child classes can override
  # it to point to their own exception class.  Doing this is significantly
  # less complex than overriding throw()
  
  sub exception_class { return "autodie::exception" };
  
  {
      my %exception_class_for;
      my %class_loaded;
  
      sub throw {
          my ($class, @args) = @_;
  
          # Find our exception class if we need it.
          my $exception_class =
               $exception_class_for{$class} ||= $class->exception_class;
  
          if (not $class_loaded{$exception_class}) {
              if ($exception_class =~ /[^\w:']/) {
                  confess "Bad exception class '$exception_class'.\nThe '$class->exception_class' method wants to use $exception_class\nfor exceptions, but it contains characters which are not word-characters or colons.";
              }
  
              # Alas, Perl does turn barewords into modules unless they're
              # actually barewords.  As such, we're left doing a string eval
              # to make sure we load our file correctly.
  
              my $E;
  
              {
                  local $@;   # We can't clobber $@, it's wrong!
                  my $pm_file = $exception_class . ".pm";
                  $pm_file =~ s{ (?: :: | ' ) }{/}gx;
                  eval { require $pm_file };
                  $E = $@;    # Save $E despite ending our local.
              }
  
              # We need quotes around $@ to make sure it's stringified
              # while still in scope.  Without them, we run the risk of
              # $@ having been cleared by us exiting the local() block.
  
              confess "Failed to load '$exception_class'.\nThis may be a typo in the '$class->exception_class' method,\nor the '$exception_class' module may not exist.\n\n $E" if $E;
  
              $class_loaded{$exception_class}++;
  
          }
  
          return $exception_class->new(@args);
      }
  }
  
  # Creates and returns a leak guard (with prototype if needed).
  sub _make_leak_guard {
      my ($filename, $wrapped_sub, $orig_sub, $call, $pkg, $proto, $real_proto) = @_;
  
      # The leak guard is rather lengthly (in fact it makes up the most
      # of _make_leak_guard).  It is possible to split it into a large
      # "generic" part and a small wrapper with call-specific
      # information.  This was done in v2.19 and profiling suggested
      # that we ended up using a substantial amount of runtime in "goto"
      # between the leak guard(s) and the final sub.  Therefore, the two
      # parts were merged into one to reduce the runtime overhead.
  
      my $leak_guard = sub {
          my $caller_level = 0;
          my $caller;
  
          while ( ($caller = (caller $caller_level)[1]) =~ m{^\(eval \d+\)$} ) {
  
              # If our filename is actually an eval, and we
              # reach it, then go to our autodying code immediatately.
  
              last if ($caller eq $filename);
              $caller_level++;
          }
  
          # We're now out of the eval stack.
  
          if ($caller eq $filename) {
              # No leak, call the wrapper.  NB: In this case, it doesn't
              # matter if it is a CORE sub or not.
              goto $wrapped_sub;
          }
  
          # We leaked, time to call the original function.
          # - for non-core functions that will be $orig_sub
          goto $orig_sub if defined($orig_sub);
  
          # We are wrapping a CORE sub
  
          # If we've cached a trampoline, then use it.
          my $trampoline_sub = $Trampoline_cache{$pkg}{$call};
  
          if (not $trampoline_sub) {
              # If we don't have a trampoline, we need to build it.
              #
              # We only generate trampolines when we need them, and
              # we can cache them by subroutine + package.
  
              # TODO: Consider caching on reusable_builtins status as well.
  
              $trampoline_sub = _make_core_trampoline($call, $pkg, $proto);
  
              # Let's cache that, so we don't have to do it again.
              $Trampoline_cache{$pkg}{$call} = $trampoline_sub;
          }
  
          # Bounce to our trampoline, which takes us to our core sub.
          goto \&$trampoline_sub;
      };  # <-- end of leak guard
  
      # If there is a prototype on the original sub, copy it to the leak
      # guard.
      if ($real_proto ne '') {
          # The "\&" may appear to be redundant but set_prototype
          # croaks when it is removed.
          set_prototype(\&$leak_guard, $proto);
      }
  
      return $leak_guard;
  }
  
  # Create a trampoline for calling a core sub.  Essentially, a tiny sub
  # that figures out how we should be calling our core sub, puts in the
  # arguments in the right way, and bounces our control over to it.
  #
  # If we could use `goto &` on core builtins, we wouldn't need this.
  sub _make_core_trampoline {
      my ($call, $pkg, $proto_str) = @_;
      my $trampoline_code = 'sub {';
      my $trampoline_sub;
      my @protos = fill_protos($proto_str);
  
      # TODO: It may be possible to combine this with write_invocation().
  
      foreach my $proto (@protos) {
          local $" = ", ";    # So @args is formatted correctly.
          my ($count, @args) = @$proto;
          if (@args && $args[-1] =~ m/[@#]_/) {
              $trampoline_code .= qq/
                  if (\@_ >= $count) {
                      return $call(@args);
                  }
               /;
          } else {
              $trampoline_code .= qq<
                  if (\@_ == $count) {
                      return $call(@args);
                  }
               >;
          }
      }
  
      $trampoline_code .= qq< Carp::croak("Internal error in Fatal/autodie.  Leak-guard failure"); } >;
      my $E;
  
      {
          local $@;
          $trampoline_sub = eval "package $pkg;\n $trampoline_code"; ## no critic
          $E = $@;
      }
      die "Internal error in Fatal/autodie: Leak-guard installation failure: $E"
          if $E;
  
      return $trampoline_sub;
  }
  
  # For some reason, dying while replacing our subs doesn't
  # kill our calling program.  It simply stops the loading of
  # autodie and keeps going with everything else.  The _autocroak
  # sub allows us to die with a vengeance.  It should *only* ever be
  # used for serious internal errors, since the results of it can't
  # be captured.
  
  sub _autocroak {
      warn Carp::longmess(@_);
      exit(255);  # Ugh!
  }
  
  package autodie::Scope::Guard;
  
  # This code schedules the cleanup of subroutines at the end of
  # scope.  It's directly inspired by chocolateboy's excellent
  # Scope::Guard module.
  
  sub new {
      my ($class, $handler) = @_;
  
      return bless $handler, $class;
  }
  
  sub DESTROY {
      my ($self) = @_;
  
      $self->();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Fatal - Replace functions with equivalents which succeed or die
  
  =head1 SYNOPSIS
  
      use Fatal qw(open close);
  
      open(my $fh, "<", $filename);  # No need to check errors!
  
      use File::Copy qw(move);
      use Fatal qw(move);
  
      move($file1, $file2); # No need to check errors!
  
      sub juggle { . . . }
      Fatal->import('juggle');
  
  =head1 BEST PRACTICE
  
  B<Fatal has been obsoleted by the new L<autodie> pragma.> Please use
  L<autodie> in preference to C<Fatal>.  L<autodie> supports lexical scoping,
  throws real exception objects, and provides much nicer error messages.
  
  The use of C<:void> with Fatal is discouraged.
  
  =head1 DESCRIPTION
  
  C<Fatal> provides a way to conveniently replace
  functions which normally return a false value when they fail with
  equivalents which raise exceptions if they are not successful.  This
  lets you use these functions without having to test their return
  values explicitly on each call.  Exceptions can be caught using
  C<eval{}>.  See L<perlfunc> and L<perlvar> for details.
  
  The do-or-die equivalents are set up simply by calling Fatal's
  C<import> routine, passing it the names of the functions to be
  replaced.  You may wrap both user-defined functions and overridable
  CORE operators (except C<exec>, C<system>, C<print>, or any other
  built-in that cannot be expressed via prototypes) in this way.
  
  If the symbol C<:void> appears in the import list, then functions
  named later in that import list raise an exception only when
  these are called in void context--that is, when their return
  values are ignored.  For example
  
      use Fatal qw/:void open close/;
  
      # properly checked, so no exception raised on error
      if (not open(my $fh, '<', '/bogotic') {
          warn "Can't open /bogotic: $!";
      }
  
      # not checked, so error raises an exception
      close FH;
  
  The use of C<:void> is discouraged, as it can result in exceptions
  not being thrown if you I<accidentally> call a method without
  void context.  Use L<autodie> instead if you need to be able to
  disable autodying/Fatal behaviour for a small block of code.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Bad subroutine name for Fatal: %s
  
  You've called C<Fatal> with an argument that doesn't look like
  a subroutine name, nor a switch that this version of Fatal
  understands.
  
  =item %s is not a Perl subroutine
  
  You've asked C<Fatal> to try and replace a subroutine which does not
  exist, or has not yet been defined.
  
  =item %s is neither a builtin, nor a Perl subroutine
  
  You've asked C<Fatal> to replace a subroutine, but it's not a Perl
  built-in, and C<Fatal> couldn't find it as a regular subroutine.
  It either doesn't exist or has not yet been defined.
  
  =item Cannot make the non-overridable %s fatal
  
  You've tried to use C<Fatal> on a Perl built-in that can't be
  overridden, such as C<print> or C<system>, which means that
  C<Fatal> can't help you, although some other modules might.
  See the L</"SEE ALSO"> section of this documentation.
  
  =item Internal error: %s
  
  You've found a bug in C<Fatal>.  Please report it using
  the C<perlbug> command.
  
  =back
  
  =head1 BUGS
  
  C<Fatal> clobbers the context in which a function is called and always
  makes it a scalar context, except when the C<:void> tag is used.
  This problem does not exist in L<autodie>.
  
  "Used only once" warnings can be generated when C<autodie> or C<Fatal>
  is used with package filehandles (eg, C<FILE>).  It's strongly recommended
  you use scalar filehandles instead.
  
  =head1 AUTHOR
  
  Original module by Lionel Cons (CERN).
  
  Prototype updates by Ilya Zakharevich <ilya@math.ohio-state.edu>.
  
  L<autodie> support, bugfixes, extended diagnostics, C<system>
  support, and major overhauling by Paul Fenwick <pjf@perltraining.com.au>
  
  =head1 LICENSE
  
  This module is free software, you may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie> for a nicer way to use lexical Fatal.
  
  L<IPC::System::Simple> for a similar idea for calls to C<system()>
  and backticks.
  
  =for Pod::Coverage exception_class fill_protos one_invocation throw write_invocation
  
  =cut
FATAL

$fatpacked{"File/HomeDir.pm"} = <<'FILE_HOMEDIR';
  package File::HomeDir;
  
  # See POD at end for documentation
  
  use 5.00503;
  use strict;
  use Carp        ();
  use Config      ();
  use File::Spec  ();
  use File::Which ();
  
  # Globals
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK $IMPLEMENTED_BY};
  BEGIN {
  	$VERSION = '1.00';
  
  	# Inherit manually
  	require Exporter;
  	@ISA       = qw{ Exporter };
  	@EXPORT    = qw{ home     };
  	@EXPORT_OK = qw{
  		home
  		my_home
  		my_desktop
  		my_documents
  		my_music
  		my_pictures
  		my_videos
  		my_data
  		my_dist_config
  		my_dist_data
  		users_home
  		users_desktop
  		users_documents
  		users_music
  		users_pictures
  		users_videos
  		users_data
  	};
  
  	# %~ doesn't need (and won't take) exporting, as it's a magic
  	# symbol name that's always looked for in package 'main'.
  }
  
  # Inlined Params::Util functions
  sub _CLASS ($) {
  	(defined $_[0] and ! ref $_[0] and $_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s) ? $_[0] : undef;
  }
  sub _DRIVER ($$) {
  	(defined _CLASS($_[0]) and eval "require $_[0];" and ! $@ and $_[0]->isa($_[1]) and $_[0] ne $_[1]) ? $_[0] : undef;
  }
  
  # Platform detection
  if ( $IMPLEMENTED_BY ) {
  	# Allow for custom HomeDir classes
  	# Leave it as the existing value
  } elsif ( $^O eq 'MSWin32' ) {
  	# All versions of Windows
  	$IMPLEMENTED_BY = 'File::HomeDir::Windows';
  } elsif ( $^O eq 'darwin') {
  	# 1st: try Mac::SystemDirectory by chansen
  	if ( eval { require Mac::SystemDirectory; 1 } ) {
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Cocoa';
  	} elsif ( eval { require Mac::Files; 1 } ) {
  		# 2nd try Mac::Files: Carbon - unmaintained since 2006 except some 64bit fixes
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin::Carbon';
  	} else {
  		# 3rd: fallback: pure perl
  		$IMPLEMENTED_BY = 'File::HomeDir::Darwin';
  	}
  } elsif ( $^O eq 'MacOS' ) {
  	# Legacy Mac OS
  	$IMPLEMENTED_BY = 'File::HomeDir::MacOS9';
  } elsif ( File::Which::which('xdg-user-dir') ) {
  	# freedesktop unixes
  	$IMPLEMENTED_BY = 'File::HomeDir::FreeDesktop';
  } else {
  	# Default to Unix semantics
  	$IMPLEMENTED_BY = 'File::HomeDir::Unix';
  }
  unless ( _DRIVER($IMPLEMENTED_BY, 'File::HomeDir::Driver') ) {
  	Carp::croak("Missing or invalid File::HomeDir driver $IMPLEMENTED_BY");
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	$IMPLEMENTED_BY->my_home;
  }
  
  sub my_desktop {
  	$IMPLEMENTED_BY->can('my_desktop')
  		? $IMPLEMENTED_BY->my_desktop
  		: Carp::croak("The my_desktop method is not implemented on this platform");
  }
  
  sub my_documents {
  	$IMPLEMENTED_BY->can('my_documents')
  		? $IMPLEMENTED_BY->my_documents
  		: Carp::croak("The my_documents method is not implemented on this platform");
  }
  
  sub my_music {
  	$IMPLEMENTED_BY->can('my_music')
  		? $IMPLEMENTED_BY->my_music
  		: Carp::croak("The my_music method is not implemented on this platform");
  }
  
  sub my_pictures {
  	$IMPLEMENTED_BY->can('my_pictures')
  		? $IMPLEMENTED_BY->my_pictures
  		: Carp::croak("The my_pictures method is not implemented on this platform");
  }
  
  sub my_videos {
  	$IMPLEMENTED_BY->can('my_videos')
  		? $IMPLEMENTED_BY->my_videos
  		: Carp::croak("The my_videos method is not implemented on this platform");
  }
  
  sub my_data {
  	$IMPLEMENTED_BY->can('my_data')
  		? $IMPLEMENTED_BY->my_data
  		: Carp::croak("The my_data method is not implemented on this platform");
  }
  
  
  sub my_dist_data {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_data method requires an argument");
  	my $data   = my_data();
  
          # If datadir is not defined, there's nothing we can do: bail out
          # and return nothing...	
  	return undef unless defined $data;
  
          # On traditional unixes, hide the top-level directory
  	my $var = $data eq home()
  		? File::Spec->catdir( $data, '.perl', 'dist', $dist )
  		: File::Spec->catdir( $data, 'Perl',  'dist', $dist );
  
  	# directory exists: return it
  	return $var if -d $var;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $var );
  	return $var;
  }
  
  sub my_dist_config {
  	my $params = ref $_[-1] eq 'HASH' ? pop : {};
  	my $dist   = pop or Carp::croak("The my_dist_config method requires an argument");
  
  	# not all platforms support a specific my_config() method
  	my $config = $IMPLEMENTED_BY->can('my_config')
  		? $IMPLEMENTED_BY->my_config
  		: $IMPLEMENTED_BY->my_documents;
  
  	# If neither configdir nor my_documents is defined, there's
  	# nothing we can do: bail out and return nothing...	
  	return undef unless defined $config;
  
  	# On traditional unixes, hide the top-level dir
  	my $etc = $config eq home()
  		? File::Spec->catdir( $config, '.perl', $dist )
  		: File::Spec->catdir( $config, 'Perl',  $dist );
  
  	# directory exists: return it
  	return $etc if -d $etc;
  
  	# directory doesn't exist: check if we need to create it...
  	return undef unless $params->{create};
  
  	# user requested directory creation
  	require File::Path;
  	File::Path::mkpath( $etc );
  	return $etc;
  }
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	$IMPLEMENTED_BY->can('users_home')
  		? $IMPLEMENTED_BY->users_home( $_[-1] )
  		: Carp::croak("The users_home method is not implemented on this platform");
  }
  
  sub users_desktop {
  	$IMPLEMENTED_BY->can('users_desktop')
  		? $IMPLEMENTED_BY->users_desktop( $_[-1] )
  		: Carp::croak("The users_desktop method is not implemented on this platform");
  }
  
  sub users_documents {
  	$IMPLEMENTED_BY->can('users_documents')
  		? $IMPLEMENTED_BY->users_documents( $_[-1] )
  		: Carp::croak("The users_documents method is not implemented on this platform");
  }
  
  sub users_music {
  	$IMPLEMENTED_BY->can('users_music')
  		? $IMPLEMENTED_BY->users_music( $_[-1] )
  		: Carp::croak("The users_music method is not implemented on this platform");
  }
  
  sub users_pictures {
  	$IMPLEMENTED_BY->can('users_pictures')
  		? $IMPLEMENTED_BY->users_pictures( $_[-1] )
  		: Carp::croak("The users_pictures method is not implemented on this platform");
  }
  
  sub users_videos {
  	$IMPLEMENTED_BY->can('users_videos')
  		? $IMPLEMENTED_BY->users_videos( $_[-1] )
  		: Carp::croak("The users_videos method is not implemented on this platform");
  }
  
  sub users_data {
  	$IMPLEMENTED_BY->can('users_data')
  		? $IMPLEMENTED_BY->users_data( $_[-1] )
  		: Carp::croak("The users_data method is not implemented on this platform");
  }
  
  
  
  
  
  #####################################################################
  # Legacy Methods
  
  # Find the home directory of an arbitrary user
  sub home (;$) {
  	# Allow to be called as a method
  	if ( $_[0] and $_[0] eq 'File::HomeDir' ) {
  		shift();
  	}
  
  	# No params means my home
  	return my_home() unless @_;
  
  	# Check the param
  	my $name = shift;
  	if ( ! defined $name ) {
  		Carp::croak("Can't use undef as a username");
  	}
  	if ( ! length $name ) {
  		Carp::croak("Can't use empty-string (\"\") as a username");
  	}
  
  	# A dot also means my home
  	### Is this meant to mean File::Spec->curdir?
  	if ( $name eq '.' ) {
  		return my_home();
  	}
  
  	# Now hand off to the implementor
  	$IMPLEMENTED_BY->users_home($name);
  }
  
  
  
  
  
  #####################################################################
  # Tie-Based Interface
  
  # Okay, things below this point get scary
  
  CLASS: {
  	# Make the class for the %~ tied hash:
  	package File::HomeDir::TIE;
  
  	# Make the singleton object.
  	# (We don't use the hash for anything, though)
  	### THEN WHY MAKE IT???
  	my $SINGLETON = bless {};
  
  	sub TIEHASH { $SINGLETON }
  
  	sub FETCH {
  		# Catch a bad username
  		unless ( defined $_[1] ) {
  			Carp::croak("Can't use undef as a username");
  		}
  
  		# Get our homedir
  		unless ( length $_[1] ) {
  			return File::HomeDir::my_home();
  		}
  
  		# Get a named user's homedir
  		Carp::carp("The tied %~ hash has been deprecated");
  		return File::HomeDir::home($_[1]);
  	}
  
  	sub STORE    { _bad('STORE')    }
  	sub EXISTS   { _bad('EXISTS')   }
  	sub DELETE   { _bad('DELETE')   }
  	sub CLEAR    { _bad('CLEAR')    }
  	sub FIRSTKEY { _bad('FIRSTKEY') }
  	sub NEXTKEY  { _bad('NEXTKEY')  }
  
  	sub _bad ($) {
  		Carp::croak("You can't $_[0] with the %~ hash")
  	}
  }
  
  # Do the actual tie of the global %~ variable
  tie %~, 'File::HomeDir::TIE';
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir - Find your home and other directories on any platform
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Modern Interface (Current User)
    $home     = File::HomeDir->my_home;
    $desktop  = File::HomeDir->my_desktop;
    $docs     = File::HomeDir->my_documents;
    $music    = File::HomeDir->my_music;
    $pics     = File::HomeDir->my_pictures;
    $videos   = File::HomeDir->my_videos;
    $data     = File::HomeDir->my_data;
    $dist     = File::HomeDir->my_dist_data('File-HomeDir');
    $dist     = File::HomeDir->my_dist_config('File-HomeDir');
    
    # Modern Interface (Other Users)
    $home    = File::HomeDir->users_home('foo');
    $desktop = File::HomeDir->users_desktop('foo');
    $docs    = File::HomeDir->users_documents('foo');
    $music   = File::HomeDir->users_music('foo');
    $pics    = File::HomeDir->users_pictures('foo');
    $video   = File::HomeDir->users_videos('foo');
    $data    = File::HomeDir->users_data('foo');
  
  =head1 DESCRIPTION
  
  B<File::HomeDir> is a module for locating the directories that are "owned"
  by a user (typicaly your user) and to solve the various issues that arise
  trying to find them consistently across a wide variety of platforms.
  
  The end result is a single API that can find your resources on any platform,
  making it relatively trivial to create Perl software that works elegantly
  and correctly no matter where you run it.
  
  This module provides two main interfaces.
  
  The first is a modern L<File::Spec>-style interface with a consistent
  OO API and different implementation modules to support various
  platforms. You are B<strongly> recommended to use this interface.
  
  The second interface is for legacy support of the original 0.07 interface
  that exported a C<home()> function by default and tied the C<%~> variable.
  
  It is generally not recommended that you use this interface, but due to
  back-compatibility reasons they will remain supported until at least 2010.
  
  The C<%~> interface has been deprecated. Documentation was removed in 2009,
  Unit test were removed in 2011, usage will issue warnings from 2012, and the
  interface will be removed entirely in 2015  (in line with the general Perl
  toolchain convention of a 10 year support period for legacy APIs that
  are potentially or actually in common use).
  
  =head2 Platform Neutrality
  
  In the Unix world, many different types of data can be mixed together
  in your home directory (although on some Unix platforms this is no longer
  the case, particularly for "desktop"-oriented platforms).
  
  On some non-Unix platforms, separate directories are allocated for
  different types of data and have been for a long time.
  
  When writing applications on top of B<File::HomeDir>, you should thus
  always try to use the most specific method you can. User documents should
  be saved in C<my_documents>, data that supports an application but isn't
  normally editing by the user directory should go into C<my_data>.
  
  On platforms that do not make any distinction, all these different
  methods will harmlessly degrade to the main home directory, but on
  platforms that care B<File::HomeDir> will always try to Do The Right
  Thing(tm).
  
  =head1 METHODS
  
  Two types of methods are provided. The C<my_method> series of methods for
  finding resources for the current user, and the C<users_method> (read as
  "user's method") series for finding resources for arbitrary users.
  
  This split is necessary, as on most platforms it is B<much> easier to find
  information about the current user compared to other users, and indeed
  on a number you cannot find out information such as C<users_desktop> at
  all, due to security restrictions.
  
  All methods will double check (using a C<-d> test) that a directory
  actually exists before returning it, so you may trust in the values
  that are returned (subject to the usual caveats of race conditions of
  directories being deleted at the moment between a directory being returned
  and you using it).
  
  However, because in some cases platforms may not support the concept of home
  directories at all, any method may return C<undef> (both in scalar and list
  context) to indicate that there is no matching directory on the system.
  
  For example, most untrusted 'nobody'-type users do not have a home
  directory. So any modules that are used in a CGI application that
  at some level of recursion use your code, will result in calls to
  File::HomeDir returning undef, even for a basic home() call.
  
  =head2 my_home
  
  The C<my_home> method takes no arguments and returns the main home/profile
  directory for the current user.
  
  If the distinction is important to you, the term "current" refers to the
  real user, and not the effective user.
  
  This is also the case for all of the other "my" methods.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a home directory, or dies on error.
  
  =head2 my_desktop
  
  The C<my_desktop> method takes no arguments and returns the "desktop"
  directory for the current user.
  
  Due to the diversity and complexity of implementions required to deal with
  implementing the required functionality fully and completely, the
  C<my_desktop> method may or may not be implemented on each platform.
  
  That said, I am extremely interested in code to implement C<my_desktop> on
  Unix, as long as it is capable of dealing (as the Windows implementation
  does) with internationalisation. It should also avoid false positive
  results by making sure it only returns the appropriate directories for the
  appropriate platforms.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a desktop directory, or dies on error.
  
  =head2 my_documents
  
  The C<my_documents> method takes no arguments and returns the directory (for
  the current user) where the user's documents are stored.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a documents directory, or dies on error.
  
  =head2 my_music
  
  The C<my_music> method takes no arguments and returns the directory
  where the current user's music is stored.
  
  No bias is made to any particular music type or music program, rather the
  concept of a directory to hold the user's music is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_pictures
  
  The C<my_pictures> method takes no arguments and returns the directory
  where the current user's pictures are stored.
  
  No bias is made to any particular picture type or picture program, rather the
  concept of a directory to hold the user's pictures is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_videos
  
  The C<my_videos> method takes no arguments and returns the directory
  where the current user's videos are stored.
  
  No bias is made to any particular video type or video program, rather the
  concept of a directory to hold the user's videos is made at the level of the
  underlying operating system or (at least) desktop environment.
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a suitable directory, or dies on error.
  
  =head2 my_data
  
  The C<my_data> method takes no arguments and returns the directory where
  local applications should stored their internal data for the current
  user.
  
  Generally an application would create a subdirectory such as C<.foo>,
  beneath this directory, and store its data there. By creating your
  directory this way, you get an accurate result on the maximum number of
  platforms. But see the documentation about C<my_dist_config()> or
  C<my_dist_data()> below.
  
  For example, on Unix you get C<~/.foo> and on Win32 you get
  C<~/Local Settings/Application Data/.foo>
  
  Returns the directory path as a string, C<undef> if the current user
  does not have a data directory, or dies on error.
  
  
  =head2 my_dist_config
  
    File::HomeDir->my_dist_config( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_config( 'File-HomeDir' );
    File::HomeDir->my_dist_config( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_config> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal configuration.
  
  The base directory will be either C<my_config> if the platform supports
  it, or C<my_documents> otherwise. The subdirectory itself will be 
  C<BASE/Perl/Dist-Name>. If the base directory is the user's homedir,
  C<my_dist_config> will be in C<~/.perl/Dist-Name> (and thus be hidden on
  all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  
  =head2 my_dist_data
  
    File::HomeDir->my_dist_data( $dist [, \%params] );
    
    # For example...
    
    File::HomeDir->my_dist_data( 'File-HomeDir' );
    File::HomeDir->my_dist_data( 'File-HomeDir', { create => 1 } );
  
  The C<my_dist_data> method takes a distribution name as argument and
  returns an application-specific directory where they should store their
  internal data.
  
  This directory will be of course a subdirectory of C<my_data>. Platforms
  supporting data-specific directories will use
  C<DATA_DIR/perl/dist/Dist-Name> following the common
  "DATA/vendor/application" pattern. If the C<my_data> directory is the
  user's homedir, C<my_dist_data> will be in C<~/.perl/dist/Dist-Name>
  (and thus be hidden on all Unixes).
  
  The optional last argument is a hash reference to tweak the method
  behaviour. The following hash keys are recognized:
  
  =over 4
  
  =item * create
  
  Passing a true value to this key will force the creation of the
  directory if it doesn't exist (remember that C<File::HomeDir>'s policy
  is to return C<undef> if the directory doesn't exist).
  
  Defaults to false, meaning no automatic creation of directory.
  
  =back
  
  =head2 users_home
  
    $home = File::HomeDir->users_home('foo');
  
  The C<users_home> method takes a single param and is used to locate the
  parent home/profile directory for an identified user on the system.
  
  While most of the time this identifier would be some form of user name,
  it is permitted to vary per-platform to support user ids or UUIDs as
  applicable for that platform.
  
  Returns the directory path as a string, C<undef> if that user
  does not have a home directory, or dies on error.
  
  =head2 users_documents
  
    $docs = File::HomeDir->users_documents('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a documents directory, or dies on error.
  
  =head2 users_data
  
    $data = File::HomeDir->users_data('foo');
  
  Returns the directory path as a string, C<undef> if that user
  does not have a data directory, or dies on error.
  
  =head1 FUNCTIONS
  
  =head2 home
  
    use File::HomeDir;
    $home = home();
    $home = home('foo');
    $home = File::HomeDir::home();
    $home = File::HomeDir::home('foo');
  
  The C<home> function is exported by default and is provided for
  compatibility with legacy applications. In new applications, you should
  use the newer method-based interface above.
  
  Returns the directory path to a named user's home/profile directory.
  
  If provided no param, returns the directory path to the current user's
  home/profile directory.
  
  =head1 TO DO
  
  =over 4
  
  =item * Add more granularity to Unix, and add support to VMS and other
  esoteric platforms, so we can consider going core.
  
  =item * Add consistent support for users_* methods 
  
  =back
  
  =head1 SUPPORT
  
  This module is stored in an Open Repository at the following address.
  
  L<http://svn.ali.as/cpan/trunk/File-HomeDir>
  
  Write access to the repository is made available automatically to any
  published CPAN author, and to most other volunteers on request.
  
  If you are able to submit your bug report in the form of new (failing)
  unit tests, or can apply your fix directly instead of submitting a patch,
  you are B<strongly> encouraged to do so as the author currently maintains
  over 100 modules and it can take some time to deal with non-Critical bug
  reports or patches.
  
  This will guarantee that your issue will be addressed in the next
  release of the module.
  
  If you cannot provide a direct test or fix, or don't have time to do so,
  then regular bug reports are still accepted and appreciated via the CPAN
  bug tracker.
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-HomeDir>
  
  For other issues, for commercial enhancement or support, or to have your
  write access enabled for the repository, contact the author at the email
  address above.
  
  =head1 ACKNOWLEDGEMENTS
  
  The biggest acknowledgement goes to Chris Nandor, who wielded his
  legendary Mac-fu and turned my initial fairly ordinary Darwin
  implementation into something that actually worked properly everywhere,
  and then donated a Mac OS X license to allow it to be maintained properly.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  Chris Nandor E<lt>cnandor@cpan.orgE<gt>
  
  Stephen Steneker E<lt>stennie@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::ShareDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2012 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  Some parts copyright 2006 Chris Nandor.
  
  Some parts copyright 2006 Stephen Steneker.
  
  Some parts copyright 2009-2011 Jrme Quelin.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR

$fatpacked{"File/HomeDir/Darwin.pm"} = <<'FILE_HOMEDIR_DARWIN';
  package File::HomeDir::Darwin;
  
  use 5.00503;
  use strict;
  use Cwd                 ();
  use Carp                ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	my $home = (getpwuid($<))[7];
  	return $home if $home && -d $home;
  
  	return undef;
  }
  
  sub _my_home {
  	my($class, $path) = @_;
  	my $home = $class->my_home;
  	return undef unless defined $home;
  
  	my $folder = "$home/$path";
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  sub my_desktop {
  	my $class = shift;
  	$class->_my_home('Desktop');
  }
  
  sub my_documents {
  	my $class = shift;
  	$class->_my_home('Documents');
  }
  
  sub my_data {
  	my $class = shift;
  	$class->_my_home('Library/Application Support');
  }
  
  sub my_music {
  	my $class = shift;
  	$class->_my_home('Music');
  }
  
  sub my_pictures {
  	my $class = shift;
  	$class->_my_home('Pictures');
  }
  
  sub my_videos {
  	my $class = shift;
  	$class->_my_home('Movies');
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Mac OS X specific file path for determining
  common user directories in pure perl, by just using C<$ENV{HOME}>
  without Carbon nor Cocoa API calls. In normal usage this module will
  always be used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN

$fatpacked{"File/HomeDir/Darwin/Carbon.pm"} = <<'FILE_HOMEDIR_DARWIN_CARBON';
  package File::HomeDir::Darwin::Carbon;
  
  # Basic implementation for the Dawin family of operating systems.
  # This includes (most prominently) Mac OS X.
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  
  	# This is only a child class of the pure Perl darwin
  	# class so that we can do homedir detection of all three
  	# drivers at one via ->isa.
  	@ISA = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kCurrentUserFolderType(),
  	);
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDesktopFolderType(),
  	);
  }
  
  sub my_documents {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kDocumentsFolderType(),
  	);
  }
  
  sub my_data {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kApplicationSupportFolderType(),
  	);
  }
  
  sub my_music {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMusicDocumentsFolderType(),
  	);
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kPictureDocumentsFolderType(),
  	);
  }
  
  sub my_videos {
  	my $class = shift;
  
  	require Mac::Files;
  	$class->_find_folder(
  		Mac::Files::kMovieDocumentsFolderType(),
  	);
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::Files;
  	my $folder = Mac::Files::FindFolder(
  		Mac::Files::kUserDomain(),
  		$name,
  	);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  
  
  
  
  #####################################################################
  # Arbitrary User Methods
  
  sub users_home {
  	my $class = shift;
  	my $home  = $class->SUPER::users_home(@_);
  	return defined $home ? Cwd::abs_path($home) : undef;
  }
  
  # in theory this can be done, but for now, let's cheat, since the
  # rest is Hard
  sub users_desktop {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_desktop, $name );
  }
  
  sub users_documents {
  	my ($class, $name) = @_;
  	return undef if $name eq 'root';
  	$class->_to_user( $class->my_documents, $name );
  }
  
  sub users_data {
  	my ($class, $name) = @_;
  	$class->_to_user( $class->my_data, $name )
  	||
  	$class->users_home($name);
  }
  
  # cheap hack ... not entirely reliable, perhaps, but ... c'est la vie, since
  # there's really no other good way to do it at this time, that i know of -- pudge
  sub _to_user {
  	my ($class, $path, $name) = @_;
  	my $my_home    = $class->my_home;
  	my $users_home = $class->users_home($name);
  	defined $users_home or return undef;
  	$path =~ s/^\Q$my_home/$users_home/;
  	return $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Note -- since this module requires Mac::Carbon and Mac::Carbon does
  not work with 64-bit perls, on such systems, File::HomeDir will try
  L<File::HomeDir::Darwin::Cocoa> and then fall back to the (pure Perl)
  L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
  
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =head1 TODO
  
  =over 4
  
  =item * Test with Mac OS (versions 7, 8, 9)
  
  =item * Some better way for users_* ?
  
  =back
FILE_HOMEDIR_DARWIN_CARBON

$fatpacked{"File/HomeDir/Darwin/Cocoa.pm"} = <<'FILE_HOMEDIR_DARWIN_COCOA';
  package File::HomeDir::Darwin::Cocoa;
  
  use 5.00503;
  use strict;
  use Cwd                   ();
  use Carp                  ();
  use File::HomeDir::Darwin ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Darwin';
  
  	# Load early if in a forking environment and we have
  	# prefork, or at run-time if not.
  	local $@;
  	eval "use prefork 'Mac::SystemDirectory'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	require Mac::SystemDirectory;
  	return Mac::SystemDirectory::HomeDirectory();
  }
  
  # from 10.4
  sub my_desktop {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDesktopDirectory())
  	}
  	||
  	$class->SUPER::my_desktop;
  }
  
  # from 10.2
  sub my_documents {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSDocumentDirectory())
  	}
  	||
  	$class->SUPER::my_documents;
  }
  
  # from 10.4
  sub my_data {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSApplicationSupportDirectory())
  	}
  	||
  	$class->SUPER::my_data;
  }
  
  # from 10.6
  sub my_music {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMusicDirectory())
  	}
  	||
  	$class->SUPER::my_music;
  }
  
  # from 10.6
  sub my_pictures {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSPicturesDirectory())
  	}
  	||
  	$class->SUPER::my_pictures;
  }
  
  # from 10.6
  sub my_videos {
  	my $class = shift;
  
  	require Mac::SystemDirectory;
  	eval {
  		$class->_find_folder(Mac::SystemDirectory::NSMoviesDirectory())
  	}
  	||
  	$class->SUPER::my_videos;
  }
  
  sub _find_folder {
  	my $class = shift;
  	my $name  = shift;
  
  	require Mac::SystemDirectory;
  	my $folder = Mac::SystemDirectory::FindDirectory($name);
  	return undef unless defined $folder;
  
  	unless ( -d $folder ) {
  		# Make sure that symlinks resolve to directories.
  		return undef unless -l $folder;
  		my $dir = readlink $folder or return;
  		return undef unless -d $dir;
  	}
  
  	return Cwd::abs_path($folder);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Darwin::Cocoa - Find your home and other directories on Darwin (OS X)
  
  =head1 DESCRIPTION
  
  This module provides Darwin-specific implementations for determining
  common user directories using Cocoa API through
  L<Mac::SystemDirectory>.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Theoretically, this should return the same paths as both of the other
  Darwin drivers.
  
  Because this module requires L<Mac::SystemDirectory>, if the module
  is not installed, L<File::HomeDir> will fall back to L<File::HomeDir::Darwin>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;      # /Users/mylogin
    $desktop = File::HomeDir->my_desktop;   # /Users/mylogin/Desktop
    $docs    = File::HomeDir->my_documents; # /Users/mylogin/Documents
    $music   = File::HomeDir->my_music;     # /Users/mylogin/Music
    $pics    = File::HomeDir->my_pictures;  # /Users/mylogin/Pictures
    $videos  = File::HomeDir->my_videos;    # /Users/mylogin/Movies
    $data    = File::HomeDir->my_data;      # /Users/mylogin/Library/Application Support
  
  =cut
FILE_HOMEDIR_DARWIN_COCOA

$fatpacked{"File/HomeDir/Driver.pm"} = <<'FILE_HOMEDIR_DRIVER';
  package File::HomeDir::Driver;
  
  # Abstract base class that provides no functionality,
  # but confirms the class is a File::HomeDir driver class.
  
  use 5.00503;
  use strict;
  use Carp ();
  
  use vars qw{$VERSION};
  BEGIN {
  	$VERSION = '1.00';
  }
  
  sub my_home {
  	Carp::croak("$_[0] does not implement compulsory method $_[1]");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Driver - Base class for all File::HomeDir drivers
  
  =head1 DESCRIPTION
  
  This module is the base class for all L<File::HomeDir> drivers, and must
  be inherited from to identify a class as a driver.
  
  It is primarily provided as a convenience for this specific identification
  purpose, as L<File::HomeDir> supports the specification of custom drivers
  and an C<-E<gt>isa> check is used during the loading of the driver.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_DRIVER

$fatpacked{"File/HomeDir/FreeDesktop.pm"} = <<'FILE_HOMEDIR_FREEDESKTOP';
  package File::HomeDir::FreeDesktop;
  
  # Specific functionality for unixes running free desktops
  # compatible with (but not using) File-BaseDir-0.03
  
  # See POD at the end of the file for more documentation.
  
  use 5.00503;
  use strict;
  use Carp                ();
  use File::Spec          ();
  use File::Which         ();
  use File::HomeDir::Unix ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Unix';
  }
  
  # xdg uses $ENV{XDG_CONFIG_HOME}/user-dirs.dirs to know where are the
  # various "my xxx" directories. That is a shell file. The official API
  # is the xdg-user-dir executable. It has no provision for assessing
  # the directories of a user that is different than the one we are
  # running under; the standard substitute user mechanisms are needed to
  # overcome this.
  
  my $xdgprog = File::Which::which('xdg-user-dir');
  
  sub _my {
  	# No quoting because input is hard-coded and only comes from this module
  	my $thingy = qx($xdgprog $_[1]);
  	chomp $thingy;
  	return $thingy;
  }
  
  # Simple stuff
  sub my_desktop   { shift->_my('DESKTOP')   }
  sub my_documents { shift->_my('DOCUMENTS') }
  sub my_music     { shift->_my('MUSIC')     }
  sub my_pictures  { shift->_my('PICTURES')  }
  sub my_videos    { shift->_my('VIDEOS')    }
  
  sub my_data {
  	$ENV{XDG_DATA_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .local share }
  	);
  }
  
  sub my_config {
  	$ENV{XDG_CONFIG_HOME}
  	or
  	File::Spec->catdir(
  		shift->my_home,
  		qw{ .config }
  	);
  }
  
  # Custom locations (currently undocumented)
  sub my_download    { shift->_my('DOWNLOAD')    }
  sub my_publicshare { shift->_my('PUBLICSHARE') }
  sub my_templates   { shift->_my('TEMPLATES')   }
  
  sub my_cache {
      $ENV{XDG_CACHE_HOME}
      ||
      File::Spec->catdir(shift->my_home, qw{ .cache });
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_desktop   { Carp::croak('The users_desktop method is not available on an XDG based system.');   }
  sub users_documents { Carp::croak('The users_documents method is not available on an XDG based system.'); }
  sub users_music     { Carp::croak('The users_music method is not available on an XDG based system.');     }
  sub users_pictures  { Carp::croak('The users_pictures method is not available on an XDG based system.');  }
  sub users_videos    { Carp::croak('The users_videos method is not available on an XDG based system.');    }
  sub users_data      { Carp::croak('The users_data method is not available on an XDG based system.');      }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::FreeDesktop - Find your home and other directories on FreeDesktop.org Unix
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;
    $docs    = File::HomeDir->my_documents;
    $music   = File::HomeDir->my_music;
    $pics    = File::HomeDir->my_pictures;
    $videos  = File::HomeDir->my_videos;
    $data    = File::HomeDir->my_data;
  
  =head1 AUTHORS
  
  Jerome Quelin E<lt>jquellin@cpan.org<gt>
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2009 - 2011 Jerome Quelin.
  
  Some parts copyright 2010 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_FREEDESKTOP

$fatpacked{"File/HomeDir/MacOS9.pm"} = <<'FILE_HOMEDIR_MACOS9';
  package File::HomeDir::MacOS9;
  
  # Half-assed implementation for the legacy Mac OS9 operating system.
  # Provided mainly to provide legacy compatibility. May be removed at
  # a later date.
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  # Load early if in a forking environment and we have
  # prefork, or at run-time if not.
  SCOPE: {
  	local $@;
  	eval "use prefork 'Mac::Files'";
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# Try for $ENV{HOME} if we have it
  	if ( defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	### DESPERATION SETS IN
  
  	# We could use the desktop
  	SCOPE: {
  		local $@;
  		eval {
  			my $home = $class->my_desktop;
  			return $home if $home and -d $home;
  		};
  	}
  
  	# Desperation on any platform
  	SCOPE: {
  		# On some platforms getpwuid dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	Carp::croak("Could not locate current user's home directory");
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# Find the desktop via Mac::Files
  	local $SIG{'__DIE__'} = '';
  	require Mac::Files;
  	my $home = Mac::Files::FindFolder(
  		Mac::Files::kOnSystemDisk(),
  		Mac::Files::kDesktopFolderType(),
  		);
  	return $home if $home and -d $home;
  
  	Carp::croak("Could not locate current user's desktop");
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	SCOPE: {
  		# On some platforms getpwnam dies if called at all
  		local $SIG{'__DIE__'} = '';
  		my $home = (getpwnam($name))[7];
  		return $home if defined $home and -d $home;
  	}
  
  	Carp::croak("Failed to find home directory for user '$name'");
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::MacOS9 - Find your home and other directories on legacy Macs
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;
    $desktop = File::HomeDir->my_desktop;
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories on legacy Mac hosts. In normal usage this module will always be
  used via L<File::HomeDir>.
  
  This module is no longer actively maintained, and is included only for
  extreme back-compatibility.
  
  Only the C<my_home> and C<my_desktop> methods are supported.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_MACOS9

$fatpacked{"File/HomeDir/Test.pm"} = <<'FILE_HOMEDIR_TEST';
  package File::HomeDir::Test;
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::Temp            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA %DIR $ENABLED};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  	%DIR     = ();
  	$ENABLED = 0;
  }
  
  # Special magic use in test scripts
  sub import {
  	my $class = shift;
  	die "Attempted to initialise File::HomeDir::Test trice" if %DIR;
  
  	# Fill the test directories
  	my $BASE  = File::Temp::tempdir( CLEANUP => 1 );
  	%DIR = map { $_ => File::Spec->catdir( $BASE, $_ ) } qw{
  		my_home
  		my_desktop
  		my_documents
  		my_data
  		my_music
  		my_pictures
  		my_videos
  	};
  
  	# Hijack HOME to the home directory
  	$ENV{HOME} = $DIR{my_home};
  
  	# Make File::HomeDir load us instead of the native driver
  	$File::HomeDir::IMPLEMENTED_BY = # Prevent a warning
  	$File::HomeDir::IMPLEMENTED_BY = 'File::HomeDir::Test';
  
  	# Ready to go
  	$ENABLED = 1;
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	mkdir($DIR{my_home}, 0755) unless -d $DIR{my_home};
  	return $DIR{my_home};
  }
  
  sub my_desktop {
  	mkdir($DIR{my_desktop}, 0755) unless -d $DIR{my_desktop};
  	return $DIR{my_desktop};
  }
  
  sub my_documents {
  	mkdir($DIR{my_documents}, 0755) unless -f $DIR{my_documents};
  	return $DIR{my_documents};
  }
  
  sub my_data {
  	mkdir($DIR{my_data}, 0755) unless -d $DIR{my_data};
  	return $DIR{my_data};
  }
  
  sub my_music {
  	mkdir($DIR{my_music}, 0755) unless -d $DIR{my_music};
  	return $DIR{my_music};
  }
  
  sub my_pictures {
  	mkdir($DIR{my_pictures}, 0755) unless -d $DIR{my_pictures};
  	return $DIR{my_pictures};
  }
  
  sub my_videos {
  	mkdir($DIR{my_videos}, 0755) unless -d $DIR{my_videos};
  	return $DIR{my_videos};
  }
  
  sub users_home {
  	return undef;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Test - Prevent the accidental creation of user-owned files during testing
  
  =head1 SYNOPSIS
  
    use Test::More test => 1;
    use File::HomeDir::Test;
    use File::HomeDir;
  
  =head1 DESCRIPTION
  
  B<File::HomeDir::Test> is a L<File::HomeDir> driver intended for use in the test scripts
  of modules or applications that write files into user-owned directories.
  
  It is designed to prevent the pollution of user directories with files that are not part
  of the application install itself, but were created during testing. These files can leak
  state information from the tests into the run-time usage of an application, and on Unix
  systems also prevents tests (which may be executed as root via sudo) from writing files
  which cannot later be modified or removed by the regular user.
  
  =head1 SUPPORT
  
  See the support section of the main L<File::HomeDir> documentation.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_TEST

$fatpacked{"File/HomeDir/Unix.pm"} = <<'FILE_HOMEDIR_UNIX';
  package File::HomeDir::Unix;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  	my $home  = $class->_my_home(@_);
  
  	# On Unix in general, a non-existant home means "no home"
  	# For example, "nobody"-like users might use /nonexistant
  	if ( defined $home and ! -d $home ) {
  		$home = undef;
  	}
  
  	return $home;
  }
  
  sub _my_home {
  	my $class = shift;
  	if ( exists $ENV{HOME} and defined $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# This is from the original code, but I'm guessing
  	# it means "login directory" and exists on some Unixes.
  	if ( exists $ENV{LOGDIR} and $ENV{LOGDIR} ) {
  		return $ENV{LOGDIR};
  	}
  
  	### More-desperate methods
  
  	# Light desperation on any (Unixish) platform
  	SCOPE: {
  		my $home = (getpwuid($<))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  # On unix by default, everything is under the same folder
  sub my_desktop {
  	shift->my_home;
  }
  
  sub my_documents {
  	shift->my_home;
  }
  
  sub my_data {
  	shift->my_home;
  }
  
  sub my_music {
  	shift->my_home;
  }
  
  sub my_pictures {
  	shift->my_home;
  }
  
  sub my_videos {
  	shift->my_home;
  }
  
  
  
  
  
  #####################################################################
  # General User Methods
  
  sub users_home {
  	my ($class, $name) = @_;
  
  	# IF and only if we have getpwuid support, and the
  	# name of the user is our own, shortcut to my_home.
  	# This is needed to handle HOME environment settings.
  	if ( $name eq getpwuid($<) ) {
  		return $class->my_home;
  	}
  
  	SCOPE: {
  		my $home = (getpwnam($name))[7];
  		return $home if $home and -d $home;
  	}
  
  	return undef;
  }
  
  sub users_desktop {
  	shift->users_home(@_);
  }
  
  sub users_documents {
  	shift->users_home(@_);
  }
  
  sub users_data {
  	shift->users_home(@_);
  }
  
  sub users_music {
  	shift->users_home(@_);
  }
  
  sub users_pictures {
  	shift->users_home(@_);
  }
  
  sub users_videos {
  	shift->users_home(@_);
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Unix - Find your home and other directories on legacy Unix
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user
    $home    = File::HomeDir->my_home;        # /home/mylogin
    $desktop = File::HomeDir->my_desktop;     # All of these will... 
    $docs    = File::HomeDir->my_documents;   # ...default to home...
    $music   = File::HomeDir->my_music;       # ...directory
    $pics    = File::HomeDir->my_pictures;    #
    $videos  = File::HomeDir->my_videos;      #
    $data    = File::HomeDir->my_data;        # 
  
  =head1 DESCRIPTION
  
  This module provides implementations for determining common user
  directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_UNIX

$fatpacked{"File/HomeDir/Windows.pm"} = <<'FILE_HOMEDIR_WINDOWS';
  package File::HomeDir::Windows;
  
  # See POD at the end of the file for documentation
  
  use 5.00503;
  use strict;
  use Carp                  ();
  use File::Spec            ();
  use File::HomeDir::Driver ();
  
  use vars qw{$VERSION @ISA};
  BEGIN {
  	$VERSION = '1.00';
  	@ISA     = 'File::HomeDir::Driver';
  }
  
  sub CREATE () { 1 }
  
  
  
  
  
  #####################################################################
  # Current User Methods
  
  sub my_home {
  	my $class = shift;
  
  	# A lot of unix people and unix-derived tools rely on
  	# the ability to overload HOME. We will support it too
  	# so that they can replace raw HOME calls with File::HomeDir.
  	if ( exists $ENV{HOME} and $ENV{HOME} ) {
  		return $ENV{HOME};
  	}
  
  	# Do we have a user profile?
  	if ( exists $ENV{USERPROFILE} and $ENV{USERPROFILE} ) {
  		return $ENV{USERPROFILE};
  	}
  
  	# Some Windows use something like $ENV{HOME}
  	if ( exists $ENV{HOMEDRIVE} and exists $ENV{HOMEPATH} and $ENV{HOMEDRIVE} and $ENV{HOMEPATH} ) {
  		return File::Spec->catpath(
  			$ENV{HOMEDRIVE}, $ENV{HOMEPATH}, '',
  		);
  	}
  
  	return undef;
  }
  
  sub my_desktop {
  	my $class = shift;
  
  	# The most correct way to find the desktop
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_DESKTOP(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	# MSWindows sets WINDIR, MS WinNT sets USERPROFILE.
  	foreach my $e ( 'USERPROFILE', 'WINDIR' ) {
  		next unless $ENV{$e};
  		my $desktop = File::Spec->catdir($ENV{$e}, 'Desktop');
  		return $desktop if $desktop and $class->_d($desktop);
  	}
  
  	# As a last resort, try some hard-wired values
  	foreach my $fixed (
  		# The reason there are both types of slash here is because
  		# this set of paths has been kept from thethe original version
  		# of File::HomeDir::Win32 (before it was rewritten).
  		# I can only assume this is Cygwin-related stuff.
  		"C:\\windows\\desktop",
  		"C:\\win95\\desktop",
  		"C:/win95/desktop",
  		"C:/windows/desktop",
  	) {
  		return $fixed if $class->_d($fixed);
  	}
  
  	return undef;
  }
  
  sub my_documents {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_PERSONAL(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_data {
  	my $class = shift;
  
  	# The most correct way to find my documents
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_LOCAL_APPDATA(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_music {
  	my $class = shift;
  
  	# The most correct way to find my music
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYMUSIC(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_pictures {
  	my $class = shift;
  
  	# The most correct way to find my pictures
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYPICTURES(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  sub my_videos {
  	my $class = shift;
  
  	# The most correct way to find my videos
  	SCOPE: {
  		require Win32;
  		my $dir = Win32::GetFolderPath(Win32::CSIDL_MYVIDEO(), CREATE);
  		return $dir if $dir and $class->_d($dir);
  	}
  
  	return undef;
  }
  
  # Special case version of -d
  sub _d {
  	my $self = shift;
  	my $path = shift;
  
  	# Window can legally return a UNC path from GetFolderPath.
  	# Not only is the meaning of -d complicated in this situation,
  	# but even on a local network calling -d "\\\\cifs\\path" can
  	# take several seconds. UNC can also do even weirder things,
  	# like launching processes and such.
  	# To avoid various crazy bugs caused by this, we do NOT attempt
  	# to validate UNC paths at all so that the code that is calling
  	# us has an opportunity to take special actions without our 
  	# blundering getting in the way.
  	if ( $path =~ /\\\\/ ) {
  		return 1;
  	}
  
  	# Otherwise do a stat as normal
  	return -d $path;
  }
  
  1;
  
  =pod
  
  =head1 NAME
  
  File::HomeDir::Windows - Find your home and other directories on Windows
  
  =head1 SYNOPSIS
  
    use File::HomeDir;
    
    # Find directories for the current user (eg. using Windows XP Professional)
    $home    = File::HomeDir->my_home;        # C:\Documents and Settings\mylogin
    $desktop = File::HomeDir->my_desktop;     # C:\Documents and Settings\mylogin\Desktop
    $docs    = File::HomeDir->my_documents;   # C:\Documents and Settings\mylogin\My Documents
    $music   = File::HomeDir->my_music;       # C:\Documents and Settings\mylogin\My Documents\My Music
    $pics    = File::HomeDir->my_pictures;    # C:\Documents and Settings\mylogin\My Documents\My Pictures
    $videos  = File::HomeDir->my_videos;      # C:\Documents and Settings\mylogin\My Documents\My Video
    $data    = File::HomeDir->my_data;        # C:\Documents and Settings\mylogin\Local Settings\Application Data
  
  =head1 DESCRIPTION
  
  This module provides Windows-specific implementations for determining
  common user directories.  In normal usage this module will always be
  used via L<File::HomeDir>.
  
  Internally this module will use L<Win32>::GetFolderPath to fetch the location
  of your directories. As a result of this, in certain unusual situations
  (usually found inside large organisations) the methods may return UNC paths
  such as C<\\cifs.local\home$>.
  
  If your application runs on Windows and you want to have it work comprehensively
  everywhere, you may need to implement your own handling for these paths as they
  can cause strange behaviour.
  
  For example, stat calls to UNC paths may work but block for several seconds, but
  opendir() may not be able to read any files (creating the appearance of an existing
  but empty directory).
  
  To avoid complicating the problem any further, in the rare situation that a UNC path
  is returned by C<GetFolderPath> the usual -d validation checks will B<not> be done.
  
  =head1 SUPPORT
  
  See the support section the main L<File::HomeDir> module.
  
  =head1 AUTHORS
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Sean M. Burke E<lt>sburke@cpan.orgE<gt>
  
  =head1 SEE ALSO
  
  L<File::HomeDir>, L<File::HomeDir::Win32> (legacy)
  
  =head1 COPYRIGHT
  
  Copyright 2005 - 2011 Adam Kennedy.
  
  Some parts copyright 2000 Sean M. Burke.
  
  This program is free software; you can redistribute
  it and/or modify it under the same terms as Perl itself.
  
  The full text of the license can be found in the
  LICENSE file included with this module.
  
  =cut
FILE_HOMEDIR_WINDOWS

$fatpacked{"File/Which.pm"} = <<'FILE_WHICH';
  package File::Which;
  
  use 5.004;
  use strict;
  use Exporter   ();
  use File::Spec ();
  
  use vars qw{$VERSION @ISA @EXPORT @EXPORT_OK};
  BEGIN {
  	$VERSION   = '1.09';
  	@ISA       = 'Exporter';
  	@EXPORT    = 'which';
  	@EXPORT_OK = 'where';
  }
  
  use constant IS_VMS => ($^O eq 'VMS');
  use constant IS_MAC => ($^O eq 'MacOS');
  use constant IS_DOS => ($^O eq 'MSWin32' or $^O eq 'dos' or $^O eq 'os2');
  
  # For Win32 systems, stores the extensions used for
  # executable files
  # For others, the empty string is used
  # because 'perl' . '' eq 'perl' => easier
  my @PATHEXT = ('');
  if ( IS_DOS ) {
  	# WinNT. PATHEXT might be set on Cygwin, but not used.
  	if ( $ENV{PATHEXT} ) {
  		push @PATHEXT, split ';', $ENV{PATHEXT};
  	} else {
  		# Win9X or other: doesn't have PATHEXT, so needs hardcoded.
  		push @PATHEXT, qw{.com .exe .bat};
  	}
  } elsif ( IS_VMS ) {
  	push @PATHEXT, qw{.exe .com};
  }
  
  sub which {
  	my ($exec) = @_;
  
  	return undef unless $exec;
  
  	my $all = wantarray;
  	my @results = ();
  
  	# check for aliases first
  	if ( IS_VMS ) {
  		my $symbol = `SHOW SYMBOL $exec`;
  		chomp($symbol);
  		unless ( $? ) {
  			return $symbol unless $all;
  			push @results, $symbol;
  		}
  	}
  	if ( IS_MAC ) {
  		my @aliases = split /\,/, $ENV{Aliases};
  		foreach my $alias ( @aliases ) {
  			# This has not been tested!!
  			# PPT which says MPW-Perl cannot resolve `Alias $alias`,
  			# let's just hope it's fixed
  			if ( lc($alias) eq lc($exec) ) {
  				chomp(my $file = `Alias $alias`);
  				last unless $file;  # if it failed, just go on the normal way
  				return $file unless $all;
  				push @results, $file;
  				# we can stop this loop as if it finds more aliases matching,
  				# it'll just be the same result anyway
  				last;
  			}
  		}
  	}
  
  	my @path = File::Spec->path;
  	if ( IS_DOS or IS_VMS or IS_MAC ) {
  		unshift @path, File::Spec->curdir;
  	}
  
  	foreach my $base ( map { File::Spec->catfile($_, $exec) } @path ) {
  		for my $ext ( @PATHEXT ) {
  			my $file = $base.$ext;
  
  			# We don't want dirs (as they are -x)
  			next if -d $file;
  
  			if (
  				# Executable, normal case
  				-x _
  				or (
  					# MacOS doesn't mark as executable so we check -e
  					IS_MAC
  					||
  					(
  						IS_DOS
  						and
  						grep {
  							$file =~ /$_\z/i
  						} @PATHEXT[1..$#PATHEXT]
  					)
  					# DOSish systems don't pass -x on
  					# non-exe/bat/com files. so we check -e.
  					# However, we don't want to pass -e on files
  					# that aren't in PATHEXT, like README.
  					and -e _
  				)
  			) {
  				return $file unless $all;
  				push @results, $file;
  			}
  		}
  	}
  
  	if ( $all ) {
  		return @results;
  	} else {
  		return undef;
  	}
  }
  
  sub where {
  	# force wantarray
  	my @res = which($_[0]);
  	return @res;
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::Which - Portable implementation of the `which' utility
  
  =head1 SYNOPSIS
  
    use File::Which;                  # exports which()
    use File::Which qw(which where);  # exports which() and where()
    
    my $exe_path = which('perldoc');
    
    my @paths = where('perl');
    - Or -
    my @paths = which('perl'); # an array forces search for all of them
  
  =head1 DESCRIPTION
  
  C<File::Which> was created to be able to get the paths to executable programs
  on systems under which the `which' program wasn't implemented in the shell.
  
  C<File::Which> searches the directories of the user's C<PATH> (as returned by
  C<File::Spec-E<gt>path()>), looking for executable files having the name
  specified as a parameter to C<which()>. Under Win32 systems, which do not have a
  notion of directly executable files, but uses special extensions such as C<.exe>
  and C<.bat> to identify them, C<File::Which> takes extra steps to assure that
  you will find the correct file (so for example, you might be searching for
  C<perl>, it'll try F<perl.exe>, F<perl.bat>, etc.)
  
  =head1 Steps Used on Win32, DOS, OS2 and VMS
  
  =head2 Windows NT
  
  Windows NT has a special environment variable called C<PATHEXT>, which is used
  by the shell to look for executable files. Usually, it will contain a list in
  the form C<.EXE;.BAT;.COM;.JS;.VBS> etc. If C<File::Which> finds such an
  environment variable, it parses the list and uses it as the different
  extensions.
  
  =head2 Windows 9x and other ancient Win/DOS/OS2
  
  This set of operating systems don't have the C<PATHEXT> variable, and usually
  you will find executable files there with the extensions C<.exe>, C<.bat> and
  (less likely) C<.com>. C<File::Which> uses this hardcoded list if it's running
  under Win32 but does not find a C<PATHEXT> variable.
  
  =head2 VMS
  
  Same case as Windows 9x: uses C<.exe> and C<.com> (in that order).
  
  =head1 Functions
  
  =head2 which($short_exe_name)
  
  Exported by default.
  
  C<$short_exe_name> is the name used in the shell to call the program (for
  example, C<perl>).
  
  If it finds an executable with the name you specified, C<which()> will return
  the absolute path leading to this executable (for example, F</usr/bin/perl> or
  F<C:\Perl\Bin\perl.exe>).
  
  If it does I<not> find the executable, it returns C<undef>.
  
  If C<which()> is called in list context, it will return I<all> the
  matches.
  
  =head2 where($short_exe_name)
  
  Not exported by default.
  
  Same as C<which($short_exe_name)> in array context. Same as the
  C<`where'> utility, will return an array containing all the path names
  matching C<$short_exe_name>.
  
  =head1 BUGS AND CAVEATS
  
  Not tested on VMS or MacOS, although there is platform specific code
  for those. Anyone who haves a second would be very kind to send me a
  report of how it went.
  
  File::Spec adds the current directory to the front of PATH if on
  Win32, VMS or MacOS. I have no knowledge of those so don't know if the
  current directory is searced first or not. Could someone please tell
  me?
  
  =head1 SUPPORT
  
  Bugs should be reported via the CPAN bug tracker at
  
  L<http://rt.cpan.org/NoAuth/ReportBug.html?Queue=File-Which>
  
  For other issues, contact the maintainer.
  
  =head1 AUTHOR
  
  Adam Kennedy E<lt>adamk@cpan.orgE<gt>
  
  Per Einar Ellefsen E<lt>pereinar@cpan.orgE<gt>
  
  Originated in F<modperl-2.0/lib/Apache/Build.pm>. Changed for use in DocSet
  (for the mod_perl site) and Win32-awareness by me, with slight modifications
  by Stas Bekman, then extracted to create C<File::Which>.
  
  Version 0.04 had some significant platform-related changes, taken from
  the Perl Power Tools C<`which'> implementation by Abigail with
  enhancements from Peter Prymmer. See
  L<http://www.perl.com/language/ppt/src/which/index.html> for more
  information.
  
  =head1 COPYRIGHT
  
  Copyright 2002 Per Einar Ellefsen.
  
  Some parts copyright 2009 Adam Kennedy.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<File::Spec>, L<which(1)>, Perl Power Tools:
  L<http://www.perl.com/language/ppt/index.html>.
  
  =cut
FILE_WHICH

$fatpacked{"File/chdir.pm"} = <<'FILE_CHDIR';
  package File::chdir;
  use 5.004;
  use strict;
  use vars qw($VERSION @ISA @EXPORT $CWD @CWD);
  # ABSTRACT: a more sensible way to change directories
  our $VERSION = '0.1008'; # VERSION
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(*CWD);
  
  use Carp;
  use Cwd 3.16;
  use File::Spec::Functions 3.27 qw/canonpath splitpath catpath splitdir catdir/;
  
  tie $CWD, 'File::chdir::SCALAR' or die "Can't tie \$CWD";
  tie @CWD, 'File::chdir::ARRAY'  or die "Can't tie \@CWD";
  
  sub _abs_path {
      # Otherwise we'll never work under taint mode.
      my($cwd) = Cwd::getcwd =~ /(.*)/s;
      # Run through File::Spec, since everything else uses it
      return canonpath($cwd);
  }
  
  # splitpath but also split directory
  sub _split_cwd {
      my ($vol, $dir) = splitpath(_abs_path, 1);
      my @dirs = splitdir( $dir );
      shift @dirs; # get rid of leading empty "root" directory
      return ($vol, @dirs);
  }
  
  # catpath, but take list of directories
  # restore the empty root dir and provide an empty file to avoid warnings
  sub _catpath {
      my ($vol, @dirs) = @_;
      return catpath($vol, catdir(q{}, @dirs), q{});
  }
  
  sub _chdir {
      # Untaint target directory
      my ($new_dir) = $_[0] =~ /(.*)/s;
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      if ( ! CORE::chdir($new_dir) ) {
          croak "Failed to change directory to '$new_dir': $!";
      };
      return 1;
  }
  
  {
      package File::chdir::SCALAR;
      use Carp;
  
      BEGIN {
          *_abs_path = \&File::chdir::_abs_path;
          *_chdir = \&File::chdir::_chdir;
          *_split_cwd = \&File::chdir::_split_cwd;
          *_catpath = \&File::chdir::_catpath;
      }
  
      sub TIESCALAR {
          bless [], $_[0];
      }
  
      # To be safe, in case someone chdir'd out from under us, we always
      # check the Cwd explicitly.
      sub FETCH {
          return _abs_path;
      }
  
      sub STORE {
          return unless defined $_[1];
          _chdir($_[1]);
      }
  }
  
  
  {
      package File::chdir::ARRAY;
      use Carp;
  
      BEGIN {
          *_abs_path = \&File::chdir::_abs_path;
          *_chdir = \&File::chdir::_chdir;
          *_split_cwd = \&File::chdir::_split_cwd;
          *_catpath = \&File::chdir::_catpath;
      }
  
      sub TIEARRAY {
          bless {}, $_[0];
      }
  
      sub FETCH {
          my($self, $idx) = @_;
          my ($vol, @cwd) = _split_cwd;
          return $cwd[$idx];
      }
  
      sub STORE {
          my($self, $idx, $val) = @_;
  
          my ($vol, @cwd) = _split_cwd;
          if( $self->{Cleared} ) {
              @cwd = ();
              $self->{Cleared} = 0;
          }
  
          $cwd[$idx] = $val;
          my $dir = _catpath($vol,@cwd);
  
          _chdir($dir);
          return $cwd[$idx];
      }
  
      sub FETCHSIZE {
          my ($vol, @cwd) = _split_cwd;
          return scalar @cwd;
      }
      sub STORESIZE {}
  
      sub PUSH {
          my($self) = shift;
  
          my $dir = _catpath(_split_cwd, @_);
          _chdir($dir);
          return $self->FETCHSIZE;
      }
  
      sub POP {
          my($self) = shift;
  
          my ($vol, @cwd) = _split_cwd;
          my $popped = pop @cwd;
          my $dir = _catpath($vol,@cwd);
          _chdir($dir);
          return $popped;
      }
  
      sub SHIFT {
          my($self) = shift;
  
          my ($vol, @cwd) = _split_cwd;
          my $shifted = shift @cwd;
          my $dir = _catpath($vol,@cwd);
          _chdir($dir);
          return $shifted;
      }
  
      sub UNSHIFT {
          my($self) = shift;
  
          my ($vol, @cwd) = _split_cwd;
          my $dir = _catpath($vol, @_, @cwd);
          _chdir($dir);
          return $self->FETCHSIZE;
      }
  
      sub CLEAR  {
          my($self) = shift;
          $self->{Cleared} = 1;
      }
  
      sub SPLICE {
          my $self = shift;
          my $offset = shift || 0;
          my $len = shift || $self->FETCHSIZE - $offset;
          my @new_dirs = @_;
  
          my ($vol, @cwd) = _split_cwd;
          my @orig_dirs = splice @cwd, $offset, $len, @new_dirs;
          my $dir = _catpath($vol, @cwd);
          _chdir($dir);
          return @orig_dirs;
      }
  
      sub EXTEND { }
      sub EXISTS {
          my($self, $idx) = @_;
          return $self->FETCHSIZE >= $idx ? 1 : 0;
      }
  
      sub DELETE {
          my($self, $idx) = @_;
          croak "Can't delete except at the end of \@CWD"
              if $idx < $self->FETCHSIZE - 1;
          local $Carp::CarpLevel = $Carp::CarpLevel + 1;
          $self->POP;
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::chdir - a more sensible way to change directories
  
  =head1 VERSION
  
  version 0.1008
  
  =head1 SYNOPSIS
  
     use File::chdir;
   
     $CWD = "/foo/bar";     # now in /foo/bar
     {
         local $CWD = "/moo/baz";  # now in /moo/baz
         ...
     }
   
     # still in /foo/bar!
  
  =head1 DESCRIPTION
  
  Perl's C<<< chdir() >>> has the unfortunate problem of being very, very, very
  global.  If any part of your program calls C<<< chdir() >>> or if any library
  you use calls C<<< chdir() >>>, it changes the current working directory for
  the B<whole> program.
  
  This sucks.
  
  File::chdir gives you an alternative, C<<< $CWD >>> and C<<< @CWD >>>.  These two
  variables combine all the power of C<<< chdir() >>>, L<File::Spec> and L<Cwd>.
  
  =head1 $CWD
  
  Use the C<<< $CWD >>> variable instead of C<<< chdir() >>> and Cwd.
  
       use File::chdir;
       $CWD = $dir;  # just like chdir($dir)!
       print $CWD;   # prints the current working directory
  
  It can be localized, and it does the right thing.
  
       $CWD = "/foo";      # it's /foo out here.
       {
           local $CWD = "/bar";  # /bar in here
       }
       # still /foo out here!
  
  C<<< $CWD >>> always returns the absolute path in the native form for the
  operating system.
  
  C<<< $CWD >>> and normal C<<< chdir() >>> work together just fine.
  
  =head1 @CWD
  
  C<<< @CWD >>> represents the current working directory as an array, each
  directory in the path is an element of the array.  This can often make
  the directory easier to manipulate, and you don't have to fumble with
  C<<< File::Spec->splitpath >>> and C<<< File::Spec->catdir >>> to make portable code.
  
     # Similar to chdir("/usr/local/src/perl")
     @CWD = qw(usr local src perl);
  
  pop, push, shift, unshift and splice all work.  pop and push are
  probably the most useful.
  
     pop @CWD;                 # same as chdir(File::Spec->updir)
     push @CWD, 'some_dir'     # same as chdir('some_dir')
  
  C<<< @CWD >>> and C<<< $CWD >>> both work fine together.
  
  B<NOTE> Due to a perl bug you can't localize C<<< @CWD >>>.  See L</CAVEATS> for a work around.
  
  =head1 EXAMPLES
  
  (We omit the C<<< use File::chdir >>> from these examples for terseness)
  
  Here's C<<< $CWD >>> instead of C<<< chdir() >>>:
  
       $CWD = 'foo';           # chdir('foo')
  
  and now instead of Cwd.
  
       print $CWD;             # use Cwd;  print Cwd::abs_path
  
  you can even do zsh style C<<< cd foo bar >>>
  
       $CWD = '/usr/local/foo';
       $CWD =~ s/usr/var/;
  
  if you want to localize that, make sure you get the parens right
  
       {
           (local $CWD) =~ s/usr/var/;
           ...
       }
  
  It's most useful for writing polite subroutines which don't leave the
  program in some strange directory:
  
       sub foo {
           local $CWD = 'some/other/dir';
           ...do your work...
       }
  
  which is much simpler than the equivalent:
  
       sub foo {
           use Cwd;
           my $orig_dir = Cwd::getcwd;
           chdir('some/other/dir');
   
           ...do your work...
   
           chdir($orig_dir);
       }
  
  C<<< @CWD >>> comes in handy when you want to start moving up and down the
  directory hierarchy in a cross-platform manner without having to use
  File::Spec.
  
       pop @CWD;                   # chdir(File::Spec->updir);
       push @CWD, 'some', 'dir'    # chdir(File::Spec->catdir(qw(some dir)));
  
  You can easily change your parent directory:
  
       # chdir from /some/dir/bar/moo to /some/dir/foo/moo
       $CWD[-2] = 'foo';
  
  =head1 CAVEATS
  
  =head3 C<<< local @CWD >>> does not work.
  
  C<<< local @CWD >>> will not localize C<<< @CWD >>>.  This is a bug in Perl, you
  can't localize tied arrays.  As a work around localizing $CWD will
  effectively localize @CWD.
  
       {
           local $CWD;
           pop @CWD;
           ...
       }
  
  =head3 Assigning to C<<< @CWD >>> calls C<<< chdir() >>> for each element
  
       @CWD = qw/a b c d/;
  
  Internally, Perl clears C<<< @CWD >>> and assigns each element in turn.  Thus, this
  code above will do this:
  
       chdir 'a';
       chdir 'a/b';
       chdir 'a/b/c';
       chdir 'a/b/c/d';
  
  Generally, avoid assigning to C<<< @CWD >>> and just use push and pop instead.
  
  =head3 Volumes not handled
  
  There is currently no way to change the current volume via File::chdir.
  
  =head1 NOTES
  
  C<<< $CWD >>> returns the current directory using native path separators, i.e. \
  on Win32.  This ensures that C<<< $CWD >>> will compare correctly with directories
  created using File::Spec.  For example:
  
       my $working_dir = File::Spec->catdir( $CWD, "foo" );
       $CWD = $working_dir;
       doing_stuff_might_chdir();
       is( $CWD, $working_dir, "back to original working_dir?" );
  
  Deleting the last item of C<<< @CWD >>> will act like a pop.  Deleting from the
  middle will throw an exception.
  
       delete @CWD[-1]; # OK
       delete @CWD[-2]; # Dies
  
  What should %CWD do?  Something with volumes?
  
       # chdir to C:\Program Files\Sierra\Half Life ?
       $CWD{C} = '\\Program Files\\Sierra\\Half Life';
  
  =head1 DIAGNOSTICS
  
  If an error is encountered when changing C<<< $CWD >>> or C<<< @CWD >>>, one of
  the following exceptions will be thrown:
  
  =over
  
  =item *
  
  I<Can't delete except at the end of @CWD>
  
  =item *
  
  I<Failed to change directory to '$dir'>
  
  =back
  
  =head1 HISTORY
  
  Michael wanted C<<< local chdir >>> to work.  p5p didn't.  But it wasn't over!
  Was it over when the Germans bombed Pearl Harbor?  Hell, no!
  
  Abigail andE<sol>or Bryan Warnock suggested the C<<< $CWD >>> thing (Michael forgets
  which).  They were right.
  
  The C<<< chdir() >>> override was eliminated in 0.04.
  
  David became co-maintainer with 0.06_01 to fix some chronic
  Win32 path bugs.
  
  As of 0.08, if changing C<<< $CWD >>> or C<<< @CWD >>> fails to change the directory, an
  error will be thrown.
  
  =head1 SEE ALSO
  
  L<File::pushd>, L<File::Spec>, L<Cwd>, L<perlfunc/chdir>,
  "Animal House" L<http://www.imdb.com/title/tt0077975/quotes>
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://rt.cpan.org/Public/Dist/Display.html?Name=File-chdir>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/file-chdir>
  
    git clone git://github.com/dagolden/file-chdir.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David A Golden <dagolden@cpan.org>
  
  =item *
  
  Michael G Schwern <schwern@pobox.com> (original author)
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Michael G Schwern and David A Golden.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_CHDIR

$fatpacked{"Path/Tiny.pm"} = <<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Path::Tiny;
  # ABSTRACT: File path utility
  our $VERSION = '0.026'; # VERSION
  
  # Dependencies
  use autodie::exception 2.14; # autodie::skip support
  use Exporter 5.57   (qw/import/);
  use File::Spec 3.40 ();
  use Carp ();
  
  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
  
  use constant {
      PATH  => 0,
      CANON => 1,
      VOL   => 2,
      DIR   => 3,
      FILE  => 4,
      TEMP  => 5,
  };
  
  use overload (
      q{""}    => sub    { $_[0]->[PATH] },
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  my $TID = 0; # for thread safe atomic writes
  
  # if cloning, threads should already be loaded, but Win32 pseudoforks
  # don't do that so we have to be sure it's loaded anyway
  sub CLONE { require threads; threads->tid }
  
  sub DOES { return $_[1] eq 'autodie::skip' } # report errors like croak
  
  my $HAS_UU;                                  # has Unicode::UTF8; lazily populated
  
  sub _check_UU {
      eval { require Unicode::UTF8; Unicode::UTF8->VERSION(0.58); 1 };
  }
  
  # we do our own autodie::exceptions to avoid wrapping built-in functions
  sub _throw {
      my ( $function, $args ) = @_;
      die autodie::exception->new(
          function => "CORE::$function",
          args     => $args,
          errno    => $!,
          context  => 'scalar',
          return   => undef,
      );
  }
  
  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      Carp::croak("Options for @{[_called_as()]} must be a hash reference")
        if defined($raw) && ref($raw) ne 'HASH';
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      Carp::croak( "Invalid option(s) for @{[_called_as()]}: " . join( ", ", keys %$raw ) )
        if keys %$raw;
      return $cooked;
  }
  
  sub _called_as {
      my ( undef, undef, undef, $method ) = caller(2);
      $method =~ s{^.*::}{};
      return $method;
  }
  
  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#
  
  
  sub path {
      my $path = shift;
      Carp::croak("path() requires a defined, positive-length argument")
        unless defined $path && length $path;
      # join stringifies any objects, too, which is handy :-)
      $path = join( "/", ( $path eq '/' ? "" : $path ), @_ ) if @_;
      my $cpath = $path = File::Spec->canonpath($path); # ugh, but probably worth it
      $path =~ tr[\\][/];                               # unix convention enforced
      if ( $path =~ m{^(~[^/]*).*} ) {                  # expand a tilde
          my ($homedir) = glob($1); # glob without list context == heisenbug!
          $path =~ s{^(~[^/]*)}{$homedir};
      }
      $path =~ s{/$}{} if $path ne "/"; # hack to make splitpath give us a basename
      bless [ $path, $cpath ], __PACKAGE__;
  }
  
  
  sub new { shift; path(@_) }
  
  
  sub cwd {
      require Cwd;
      return path( Cwd::getcwd() );
  }
  
  
  sub rootdir { path( File::Spec->rootdir ) }
  
  
  sub tempfile {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
  
      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  sub tempdir {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
  
      # File::Temp->newdir demands leading template
      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );
      return ( \@template, \%args );
  }
  
  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#
  
  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }
  
  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#
  
  
  sub absolute {
      my ( $self, $base ) = @_;
      return $self if $self->is_absolute;
  
      require Cwd;
      return path( join "/", ( defined($base) ? $base : Cwd::getcwd() ), $_[0]->[PATH] );
  }
  
  
  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $fh = $self->filehandle( ">>", $binmode );
  
      require Fcntl;
      flock( $fh, Fcntl::LOCK_EX() ) or _throw( 'flock', [ $fh, Fcntl::LOCK_EX() ] );
  
      # Ensure we're at the end after the lock
      seek( $fh, 0, Fcntl::SEEK_END() ) or _throw( 'seek', [ $fh, 0, Fcntl::SEEK_END() ] );
  
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
  
      # For immediate flush
      close $fh or _throw( 'close', [$fh] );
  }
  
  sub append_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &append }
  
  sub append_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          append( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &append;
      }
  }
  
  
  sub basename {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[FILE];
      return $self->[FILE];
  }
  
  
  sub canonpath { $_[0]->[CANON] }
  
  
  sub child {
      my ( $self, @parts ) = @_;
      my $path = $self->[PATH];
      return path( join( "/", ( $path eq '/' ? "" : $path ), @parts ) );
  }
  
  
  # XXX take a match parameter?  qr or coderef?
  sub children {
      my ($self) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or _throw( 'opendir', [ $dh, $self->[PATH] ] );
  
      return
        map { path( $self->[PATH] . "/$_" ) } grep { $_ ne '.' && $_ ne '..' } readdir $dh;
  }
  
  
  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");
  }
  
  
  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }
  
  
  sub exists { -e $_[0]->[PATH] }
  
  sub is_file { -f $_[0]->[PATH] }
  
  sub is_dir { -d $_[0]->[PATH] }
  
  
  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added
  
  sub filehandle {
      my ( $self, $opentype, $binmode ) = @_;
      $opentype = "<" unless defined $opentype;
      $binmode  = ""  unless defined $binmode;
  
      my $mode = $opentype . $binmode;
      my $fh;
      open $fh, $mode, $self->[PATH] or _throw( 'open', [ $fh, $mode, $self->[PATH] ] );
  
      return $fh;
  }
  
  
  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
  
  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
  
  
  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or _throw( 'opendir', [ $dh, $current->[PATH] ] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }
  
  
  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( "<", $binmode );
      require Fcntl;
      flock( $fh, Fcntl::LOCK_SH() ) or _throw( 'flock', [ $fh, Fcntl::LOCK_SH() ] );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my (@result, $counter);
          while ( my $line = <$fh> ) {
              chomp $line if $chomp;
              push @result, $line;
              last if ++$counter == $args->{count};
          }
          return @result;
      }
      elsif ($chomp) {
          return map { chomp; $_ } <$fh>;
      }
      else {
          return wantarray ? <$fh> : ( my $count =()= <$fh> );
      }
  }
  
  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self); ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }
  
  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() )
          && $args->{chomp}
          && !$args->{count} )
      {
          return split /\n/, slurp_utf8($self); ## no critic
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }
  
  
  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err} = \$err unless defined $args->{err};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }
  
  
  sub move {
      my ( $self, $dst ) = @_;
  
      return rename( $self->[PATH], $dst ) || _throw( 'rename', [ $self->[PATH], $dst ] );
  }
  
  
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );
  
  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, $binmode ) = @_;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $v, $binmode );
      };
      *{ $k . "_raw" }  = sub { $_[0]->filehandle( $v, ":raw" ) };
      *{ $k . "_utf8" } = sub { $_[0]->filehandle( $v, ":raw:encoding(UTF-8)" ) };
  }
  
  
  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] =~ /\.\./ ) {
              $parent = path( $self->[PATH] . "/.." );
          }
          else {
              $parent = path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          if ( $self->[DIR] =~ /\.\./ ) {
              $parent = path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              $parent = path("/") if $self->[DIR] eq "/";
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/$}{/};
              $parent = path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }
  
  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }
  
  
  sub realpath {
      require Cwd;
      return path( Cwd::realpath( $_[0]->[PATH] ) );
  }
  
  
  # Easy to get wrong, so wash it through File::Spec (sigh)
  sub relative { path( File::Spec->abs2rel( $_[0]->[PATH], $_[1] ) ) }
  
  
  sub remove {
      my $self = shift;
  
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
  
      return unlink $self->[PATH] || _throw( 'unlink', [ $self->[PATH] ] );
  }
  
  
  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err}  = \$err unless defined $args->{err};
      $args->{safe} = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );
  
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }
  
  
  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( "<", $binmode );
      require Fcntl;
      flock( $fh, Fcntl::LOCK_SH() ) or _throw( 'flock', [ $fh, Fcntl::LOCK_SH() ] );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          read $fh, $buf, $size; # File::Slurp in a nutshell
          return $buf;
      }
      else {
          local $/;
          return scalar <$fh>;
      }
  }
  
  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
  
  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      else {
          $_[1] = { binmode => ":raw:encoding(UTF-8)" };
          goto &slurp;
      }
  }
  
  
  # XXX add "unsafe" option to disable flocking and atomic?  Check benchmarks on append() first.
  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $temp = path( $self->[PATH] . $TID . $$ );
      my $fh = $temp->filehandle( ">", $binmode );
      require Fcntl;
      flock( $fh, Fcntl::LOCK_EX() ) or _throw( 'flock', [ $fh, Fcntl::LOCK_EX() ] );
      seek( $fh, 0, Fcntl::SEEK_SET() ) or _throw( 'seek', [ $fh, 0, Fcntl::SEEK_SET() ] );
      truncate( $fh, 0 ) or _throw( 'truncate', [ $fh, 0 ] );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      flock( $fh, Fcntl::LOCK_UN() ) or _throw( 'flock', [ $fh, Fcntl::LOCK_UN() ] );
      close $fh or _throw( 'close', [$fh] );
  
      # spewing need to follow the link
      # and replace the destination instead
      my $resolved_path = $self->[PATH];
      $resolved_path = readlink $resolved_path while -l $resolved_path;
      return $temp->move($resolved_path);
  }
  
  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
  
  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          spew( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }
  
  
  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || _throw( 'stat', [ $self->[PATH] ] );
  }
  
  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || _throw( 'lstat', [ $self->[PATH] ] );
  }
  
  
  sub stringify { $_[0]->[PATH] }
  
  
  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or _throw( 'close', [$fh] );
      }
      $epoch = defined($epoch) ? $epoch : time();
      utime $epoch, $epoch, $self->[PATH]
        or _throw( 'utime', [ $epoch, $epoch, $self->[PATH] ] );
      return $self;
  }
  
  
  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkpath unless $parent->exists;
      $self->touch;
  }
  
  
  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Path::Tiny - File path utility
  
  =head1 VERSION
  
  version 0.026
  
  =head1 SYNOPSIS
  
    use Path::Tiny;
  
    # creating Path::Tiny objects
  
    $dir = path("/tmp");
    $foo = path("foo.txt");
  
    $subdir = $dir->child("foo");
    $bar = $subdir->child("bar.txt");
  
    # stringifies as cleaned up path
  
    $file = path("./foo.txt");
    print $file; # "foo.txt"
  
    # reading files
  
    $guts = $file->slurp;
    $guts = $file->slurp_utf8;
  
    @lines = $file->lines;
    @lines = $file->lines_utf8;
  
    $head = $file->lines( {count => 1} );
  
    # writing files
  
    $bar->spew( @data );
    $bar->spew_utf8( @data );
  
    # reading directories
  
    for ( $dir->children ) { ... }
  
    $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }
  
  =head1 DESCRIPTION
  
  This module attempts to provide a small, fast utility for working with
  file paths.  It is friendlier to use than L<File::Spec> and provides
  easy access to functions from several other core file handling modules.
  
  It doesn't attempt to be as full-featured as L<IO::All> or L<Path::Class>,
  nor does it try to work for anything except Unix-like and Win32 platforms.
  Even then, it might break if you try something particularly obscure or
  tortuous.  (Quick!  What does this mean: C<< ///../../..//./././a//b/.././c/././ >>?
  And how does it differ on Win32?)
  
  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).
  
  File input/output methods C<flock> handles before reading or writing,
  as appropriate.
  
  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode without CRLF translation.  Installing L<Unicode::UTF8> 0.58 or later
  will speed up several of them and is highly recommended.
  
  It uses L<autodie> internally, so most failures will be thrown as exceptions.
  
  =head1 CONSTRUCTORS
  
  =head2 path
  
      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd
      $path = path("~user/file.txt");   # tilde processing
  
  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.
  
  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.
  
  If the first component of the path is a tilde ('~') then the component will be
  replaced with the output of C<glob('~')>.  If the first component of the path
  is a tilde followed by a user name then the component will be replaced with
  output of C<glob('~username')>.  Behaviour for non-existent users depends on
  the output of C<glob> on the system.
  
  =head2 new
  
      $path = Path::Tiny->new("foo/bar");
  
  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)
  
  =head2 cwd
  
      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export
  
  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.
  
  C<cwd> may be exported on request and used as a function instead of as a
  method.
  
  =head2 rootdir
  
      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export 
  
  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.
  
  C<rootdir> may be exported on request and used as a function instead of as a
  method.
  
  =head2 tempfile, tempdir
  
      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export
  
  C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  object with the file name.  The C<TMPDIR> option is enabled by default.
  
  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.
  
  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.
  
      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  
  The tempfile path object will normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.
  
  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.
  
  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.
  
  =head1 METHODS
  
  =head2 absolute
  
      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");
  
  Returns a new C<Path::Tiny> object with an absolute path.  Unless
  an argument is given, the current directory is used as the absolute base path.
  The argument must be absolute or you won't get an absolute result.
  
  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.
  
  =head2 append, append_raw, append_utf8
  
      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);
  
  Appends data to a file.  The file is locked with C<flock> prior to writing.  An
  optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<binmode()> on the handle used for writing.
  
  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  unbuffered, raw write.
  
  C<append_utf8> is like C<append> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  append will be done instead on the data encoded with C<Unicode::UTF8>.
  
  =head2 basename
  
      $name = path("foo/bar.txt")->basename; # bar.txt
  
  Returns the file portion or last directory portion of a path.
  
  =head2 canonpath
  
      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  
  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.
  
  =head2 child
  
      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);
  
  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.
  
  =head2 children
  
      @paths = path("/tmp")->children;
  
  Returns a list of C<Path::Tiny> objects for all file and directories
  within a directory.  Excludes "." and ".." automatically.
  
  =head2 copy
  
      path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  
  Copies a file using L<File::Copy>'s C<copy> function.
  
  =head2 dirname
  
      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  
  Returns the directory name portion of the path.  This is roughly
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually has the trailing slash. If that's not desired, stringify directories
  or call C<parent> on files.
  
  =head2 exists, is_file, is_dir
  
      if ( path("/tmp")->exists ) { ... }
      if ( path("/tmp")->is_file ) { ... }
      if ( path("/tmp")->is_dir ) { ... }
  
  Just like C<-e>, C<-f> or C<-d>.  This means the file or directory actually has to
  exist on the filesystem.  Until then, it's just a path.
  
  =head2 filehandle
  
      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
  
  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", "<<", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.
  
  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  
  =head2 is_absolute, is_relative
  
      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }
  
  Booleans for whether the path appears absolute or relative.
  
  =head2 iterator
  
      $iter = path("/tmp")->iterator( \%options );
  
  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  
      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }
  
  The current and parent directory entries ("." and "..") will not
  be included.
  
  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links.
  
  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.
  
  =head2 lines, lines_raw, lines_utf8
  
      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;
  
  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.  If C<binmode>
  is provided, it will be set on the handle prior to reading.  If C<count> is
  provided, up to that many lines will be returned. If C<chomp> is set, lines
  will be chomped before being returned.
  
  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).
  
      $number_of_lines = path("/tmp/foo.txt")->lines;
  
  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.
  
  C<lines_utf8> is like C<lines> with a C<binmode> of
  C<:raw:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  UTF-8 slurp will be done and then the lines will be split.  This is
  actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  intensive.  If memory use is a concern, consider C<openr_utf8> and
  iterating directly on the handle.
  
  =head2 mkpath
  
      path("foo/bar/baz")->mkpath;
      path("foo/bar/baz")->mkpath( \%options );
  
  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.
  
  =head2 move
  
      path("foo.txt")->move("bar.txt");
  
  Just like C<rename>.
  
  =head2 openr, openw, openrw, opena
  
      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;
  
      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;
  
      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;
  
      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;
  
  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  C<:raw:encoding(UTF-8)>, respectively.
  
  =head2 parent
  
      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo
  
      $parent = path("foo/bar/baz")->parent(2); # foo
  
  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.
  
  =head2 realpath
  
      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;
  
  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.
  
  =head2 relative
  
      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  
  Returns a C<Path::Tiny> object with a relative path name.
  Given the trickiness of this, it's a thin wrapper around
  C<< File::Spec->abs2rel() >>.
  
  =head2 remove
  
      path("foo.txt")->remove;
  
  B<Note: as of 0.012, remove only works on files>.
  
  This is just like C<unlink>, except if the path does not exist, it returns
  false rather than throwing an exception.
  
  =head2 remove_tree
  
      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  
  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.
  
  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.
  
      rmdir path("foo/bar/baz/");
  
  =head2 slurp, slurp_raw, slurp_utf8
  
      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;
  
  Reads file contents into a scalar.  Takes an optional hash reference may be
  used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for reading.
  
  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.
  
  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  slurp will be done instead and the result decoded with C<Unicode::UTF8>.
  This is just as strict and is roughly an order of magnitude faster than
  using C<:encoding(UTF-8)>.
  
  =head2 spew, spew_raw, spew_utf8
  
      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);
  
  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.
  
  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.
  
  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>.
  If L<Unicode::UTF8> 0.58+ is installed, a raw spew will be done instead on
  the data encoded with C<Unicode::UTF8>.
  
  =head2 stat, lstat
  
      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;
  
  Like calling C<stat> or C<lstat> from L<File::stat>.
  
  =head2 stringify
  
      $path = path("foo.txt");
      say $path->stringify; # same as "$path"
  
  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.
  
  =head2 touch
  
      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);
  
  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.
  
  Returns the path object so it can be easily chained with spew:
  
      path("foo.txt")->touch->spew( $content );
  
  =head2 touchpath
  
      path("bar/baz/foo.txt")->touchpath;
  
  Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.
  
  =head2 volume
  
      $vol = path("/tmp/foo.txt")->volume;
  
  Returns the volume portion of the path.  This is equivalent
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems.
  
  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  DOES
  
  =head1 CAVEATS
  
  =head2 utf8 vs UTF-8
  
  All the C<*_utf8> methods use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered) or C<:raw:encoding(UTF-8)> (buffered) --
  which is strict against the Unicode spec and disallows illegal Unicode
  codepoints or UTF-8 sequences.
  
  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.
  
  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).
  
  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:
  
    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF
  
  Consider L<PerlIO::utf8_strict> for a faster L<PerlIO> layer alternative to
  C<:encoding(UTF-8)>, though it does not appear to be as fast as the
  C<Unicode::UTF8> approach.
  
  =head2 Default IO layers and the open pragma
  
  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<openr>, C<openw>, etc. but not
  C<filehandle>) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8>.
  
  =head1 TYPE CONSTRAINTS AND COERCION
  
  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.
  
  =head1 SEE ALSO
  
  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.
  
  * L<File::Fu>
  * L<IO::All>
  * L<Path::Class>
  
  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:
  
  * L<Path::Iterator::Rule>
  * L<File::Next>
  
  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/path-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/path-tiny>
  
    git clone git://github.com/dagolden/path-tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Chris Williams <bingos@cpan.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  George Hartzell <hartzell@cpan.org>
  
  =item *
  
  Goro Fuji <gfuji@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Keedi Kim <keedi@cpan.org>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
PATH_TINY

$fatpacked{"Sort/Naturally.pm"} = <<'SORT_NATURALLY';
  
  require 5;
  package Sort::Naturally;  # Time-stamp: "2004-12-29 18:30:03 AST"
  $VERSION = '1.03';
  @EXPORT = ('nsort', 'ncmp');
  require Exporter;
  @ISA = ('Exporter');
  
  use strict;
  use locale;
  use integer;
  
  #-----------------------------------------------------------------------------
  # constants:
  BEGIN { *DEBUG = sub () {0} unless defined &DEBUG }
  
  use Config ();
  BEGIN {
    # Make a constant such that if a whole-number string is that long
    #  or shorter, we KNOW it's treatable as an integer
    no integer;
    my $x = length(256 ** $Config::Config{'intsize'} / 2) - 1;
    die "Crazy intsize: <$Config::Config{'intsize'}>" if $x < 4;
    eval 'sub MAX_INT_SIZE () {' . $x . '}';
    die $@ if $@;
    print "intsize $Config::Config{'intsize'} => MAX_INT_SIZE $x\n" if DEBUG;
  }
  
  sub X_FIRST () {-1}
  sub Y_FIRST () { 1}
  
  my @ORD = ('same', 'swap', 'asis');
  
  #-----------------------------------------------------------------------------
  # For lack of a preprocessor:
  
  my($code, $guts);
  $guts = <<'EOGUTS';  # This is the guts of both ncmp and nsort:
  
      if($x eq $y) {
        # trap this expensive case first, and then fall thru to tiebreaker
        $rv = 0;
  
      # Convoluted hack to get numerics to sort first, at string start:
      } elsif($x =~ m/^\d/s) {
        if($y =~ m/^\d/s) {
          $rv = 0;    # fall thru to normal comparison for the two numbers
        } else {
          $rv = X_FIRST;
          DEBUG > 1 and print "Numeric-initial $x trumps letter-initial $y\n";
        }
      } elsif($y =~ m/^\d/s) {
        $rv = Y_FIRST;
        DEBUG > 1 and print "Numeric-initial $y trumps letter-initial $x\n";
      } else {
        $rv = 0;
      }
  
      unless($rv) {
        # Normal case:
        $rv = 0;
        DEBUG and print "<$x> and <$y> compared...\n";
  
       Consideration:
        while(length $x and length $y) {
  
          DEBUG > 2 and print " <$x> and <$y>...\n";
  
          # First, non-numeric comparison:
          $x2 = ($x =~ m/^(\D+)/s) ? length($1) : 0;
          $y2 = ($y =~ m/^(\D+)/s) ? length($1) : 0;
          # Now make x2 the min length of the two:
          $x2 = $y2 if $x2 > $y2;
          if($x2) {
            DEBUG > 1 and printf " <%s> and <%s> lexically for length $x2...\n",
              substr($x,0,$x2), substr($y,0,$x2);
            do {
             my $i = substr($x,0,$x2);
             my $j = substr($y,0,$x2);
             my $sv = $i cmp $j;
             print "SCREAM! on <$i><$j> -- $sv != $rv \n" unless $rv == $sv;
             last;
            }
  
  
             if $rv =
             # The ''. things here force a copy that seems to work around a
             #  mysterious intermittent bug that 'use locale' provokes in
             #  many versions of Perl.
                     $cmp
                     ? $cmp->(substr($x,0,$x2) . '',
                              substr($y,0,$x2) . '',
                             )
                     :
                     scalar(( substr($x,0,$x2) . '' ) cmp
                            ( substr($y,0,$x2) . '' )
                            )
            ;
            # otherwise trim and keep going:
            substr($x,0,$x2) = '';
            substr($y,0,$x2) = '';
          }
  
          # Now numeric:
          #  (actually just using $x2 and $y2 as scratch)
  
          if( $x =~ s/^(\d+)//s ) {
            $x2 = $1;
            if( $y =~ s/^(\d+)//s ) {
              # We have two numbers here.
              DEBUG > 1 and print " <$x2> and <$1> numerically\n";
              if(length($x2) < MAX_INT_SIZE and length($1) < MAX_INT_SIZE) {
                # small numbers: we can compare happily
                last if $rv = $x2 <=> $1;
              } else {
                # ARBITRARILY large integers!
  
                # This saves on loss of precision that could happen
                #  with actual stringification.
                # Also, I sense that very large numbers aren't too
                #  terribly common in sort data.
  
                # trim leading 0's:
                ($y2 = $1) =~ s/^0+//s;
                $x2 =~ s/^0+//s;
                print "   Treating $x2 and $y2 as bigint\n" if DEBUG;
  
                no locale; # we want the dumb cmp back.
                last if $rv = (
                   # works only for non-negative whole numbers:
                   length($x2) <=> length($y2)
                     # the longer the numeral, the larger the value
                   or $x2 cmp $y2
                     # between equals, compare lexically!!  amazing but true.
                );
              }
            } else {
              # X is numeric but Y isn't
              $rv = Y_FIRST;
              last;
            }
          } elsif( $y =~ s/^\d+//s ) {  # we don't need to capture the substring
            $rv = X_FIRST;
            last;
          }
           # else one of them is 0-length.
  
         # end-while
        }
      }
  EOGUTS
  
  sub maker {
    my $code = $_[0];
    $code =~ s/~COMPARATOR~/$guts/g || die "Can't find ~COMPARATOR~";
    eval $code;
    die $@ if $@;
  }
  
  ##############################################################################
  
  maker(<<'EONSORT');
  sub nsort {
    # get options:
    my($cmp, $lc);
    ($cmp,$lc) = @{shift @_} if @_ and ref($_[0]) eq 'ARRAY';
  
    return @_ unless @_ > 1 or wantarray; # be clever
  
    my($x, $x2, $y, $y2, $rv);  # scratch vars
  
    # We use a Schwartzian xform to memoize the lc'ing and \W-removal
  
    map $_->[0],
    sort {
      if($a->[0] eq $b->[0]) { 0 }   # trap this expensive case
      else {
  
      $x = $a->[1];
      $y = $b->[1];
  
  ~COMPARATOR~
  
      # Tiebreakers...
      DEBUG > 1 and print " -<${$a}[0]> cmp <${$b}[0]> is $rv ($ORD[$rv])\n";
      $rv ||= (length($x) <=> length($y))  # shorter is always first
          ||  ($cmp and $cmp->($x,$y) || $cmp->($a->[0], $b->[0]))
          ||  ($x      cmp $y     )
          ||  ($a->[0] cmp $b->[0])
      ;
  
      DEBUG > 1 and print "  <${$a}[0]> cmp <${$b}[0]> is $rv ($ORD[$rv])\n";
      $rv;
    }}
  
    map {;
      $x = $lc ? $lc->($_) : lc($_); # x as scratch
      $x =~ s/\W+//s;
      [$_, $x];
    }
    @_
  }
  EONSORT
  
  #-----------------------------------------------------------------------------
  maker(<<'EONCMP');
  sub ncmp {
    # The guts are basically the same as above...
  
    # get options:
    my($cmp, $lc);
    ($cmp,$lc) = @{shift @_} if @_ and ref($_[0]) eq 'ARRAY';
  
    if(@_ == 0) {
      @_ = ($a, $b); # bit of a hack!
      DEBUG > 1 and print "Hacking in <$a><$b>\n";
    } elsif(@_ != 2) {
      require Carp;
      Carp::croak("Not enough options to ncmp!");
    }
    my($a,$b) = @_;
    my($x, $x2, $y, $y2, $rv);  # scratch vars
  
    DEBUG > 1 and print "ncmp args <$a><$b>\n";
    if($a eq $b) { # trap this expensive case
      0;
    } else {
      $x = ($lc ? $lc->($a) : lc($a));
      $x =~ s/\W+//s;
      $y = ($lc ? $lc->($b) : lc($b));
      $y =~ s/\W+//s;
  
  ~COMPARATOR~
  
  
      # Tiebreakers...
      DEBUG > 1 and print " -<$a> cmp <$b> is $rv ($ORD[$rv])\n";
      $rv ||= (length($x) <=> length($y))  # shorter is always first
          ||  ($cmp and $cmp->($x,$y) || $cmp->($a,$b))
          ||  ($x cmp $y)
          ||  ($a cmp $b)
      ;
  
      DEBUG > 1 and print "  <$a> cmp <$b> is $rv\n";
      $rv;
    }
  }
  EONCMP
  
  # clean up:
  undef $guts;
  undef &maker;
  
  #-----------------------------------------------------------------------------
  1;
  
  ############### END OF MAIN SOURCE ###########################################
  __END__
  
  =head1 NAME
  
  Sort::Naturally -- sort lexically, but sort numeral parts numerically
  
  =head1 SYNOPSIS
  
    @them = nsort(qw(
     foo12a foo12z foo13a foo 14 9x foo12 fooa foolio Foolio Foo12a
    ));
    print join(' ', @them), "\n";
  
  Prints:
  
    9x 14 foo fooa foolio Foolio foo12 foo12a Foo12a foo12z foo13a
  
  (Or "foo12a" + "Foo12a" and "foolio" + "Foolio" and might be
  switched, depending on your locale.)
  
  =head1 DESCRIPTION
  
  This module exports two functions, C<nsort> and C<ncmp>; they are used
  in implementing my idea of a "natural sorting" algorithm.  Under natural
  sorting, numeric substrings are compared numerically, and other
  word-characters are compared lexically.
  
  This is the way I define natural sorting:
  
  =over
  
  =item *
  
  Non-numeric word-character substrings are sorted lexically,
  case-insensitively: "Foo" comes between "fish" and "fowl".
  
  =item *
  
  Numeric substrings are sorted numerically:
  "100" comes after "20", not before.
  
  =item *
  
  \W substrings (neither words-characters nor digits) are I<ignored>.
  
  =item *
  
  Our use of \w, \d, \D, and \W is locale-sensitive:  Sort::Naturally
  uses a C<use locale> statement.
  
  =item *
  
  When comparing two strings, where a numeric substring in one
  place is I<not> up against a numeric substring in another,
  the non-numeric always comes first.  This is fudged by
  reading pretending that the lack of a number substring has
  the value -1, like so:
  
    foo       =>  "foo",  -1
    foobar    =>  "foo",  -1,  "bar"
    foo13     =>  "foo",  13,
    foo13xyz  =>  "foo",  13,  "xyz"
  
  That's so that "foo" will come before "foo13", which will come
  before "foobar".
  
  =item *
  
  The start of a string is exceptional: leading non-\W (non-word,
  non-digit)
  components are are ignored, and numbers come I<before> letters.
  
  =item *
  
  I define "numeric substring" just as sequences matching m/\d+/ --
  scientific notation, commas, decimals, etc., are not seen.  If
  your data has thousands separators in numbers
  ("20,000 Leagues Under The Sea" or "20.000 lieues sous les mers"),
  consider stripping them before feeding them to C<nsort> or
  C<ncmp>.
  
  =back
  
  =head2 The nsort function
  
  This function takes a list of strings, and returns a copy of the list,
  sorted.
  
  This is what most people will want to use:
  
    @stuff = nsort(...list...);
  
  When nsort needs to compare non-numeric substrings, it
  uses Perl's C<lc> function in scope of a <use locale>.
  And when nsort needs to lowercase things, it uses Perl's
  C<lc> function in scope of a <use locale>.  If you want nsort
  to use other functions instead, you can specify them in
  an arrayref as the first argument to nsort:
  
    @stuff = nsort( [
                      \&string_comparator,   # optional
                      \&lowercaser_function  # optional
                    ],
                    ...list...
                  );
  
  If you want to specify a string comparator but no lowercaser,
  then the options list is C<[\&comparator, '']> or
  C<[\&comparator]>.  If you want to specify no string comparator
  but a lowercaser, then the options list is
  C<['', \&lowercaser]>.
  
  Any comparator you specify is called as
  C<$comparator-E<gt>($left, $right)>,
  and, like a normal Perl C<cmp> replacement, must return
  -1, 0, or 1 depending on whether the left argument is stringwise
  less than, equal to, or greater than the right argument.
  
  Any lowercaser function you specify is called as
  C<$lowercased = $lowercaser-E<gt>($original)>.  The routine
  must not modify its C<$_[0]>.
  
  =head2 The ncmp function
  
  Often, when sorting non-string values like this:
  
     @objects_sorted = sort { $a->tag cmp $b->tag } @objects;
  
  ...or even in a Schwartzian transform, like this:
  
     @strings =
       map $_->[0]
       sort { $a->[1] cmp $b->[1] }
       map { [$_, make_a_sort_key_from($_) ]
       @_
     ;
  
  ...you wight want something that replaces not C<sort>, but C<cmp>.
  That's what Sort::Naturally's C<ncmp> function is for.  Call it with
  the syntax C<ncmp($left,$right)> instead of C<$left cmp $right>,
  but otherwise it's a fine replacement:
  
     @objects_sorted = sort { ncmp($a->tag,$b->tag) } @objects;
  
     @strings =
       map $_->[0]
       sort { ncmp($a->[1], $b->[1]) }
       map { [$_, make_a_sort_key_from($_) ]
       @_
     ;
  
  Just as with C<nsort> can take different a string-comparator
  and/or lowercaser, you can do the same with C<ncmp>, by passing
  an arrayref as the first argument:
  
    ncmp( [
            \&string_comparator,   # optional
            \&lowercaser_function  # optional
          ],
          $left, $right
        )
  
  You might get string comparators from L<Sort::ArbBiLex|Sort::ArbBiLex>.
  
  =head1 NOTES
  
  =over
  
  =item *
  
  This module is not a substitute for
  L<Sort::Versions|Sort::Versions>!  If
  you just need proper version sorting, use I<that!>
  
  =item *
  
  If you need something that works I<sort of> like this module's
  functions, but not quite the same, consider scouting thru this
  module's source code, and adapting what you see.  Besides
  the functions that actually compile in this module, after the POD,
  there's several alternate attempts of mine at natural sorting
  routines, which are not compiled as part of the module, but which you
  might find useful.  They should all be I<working> implementations of
  slightly different algorithms
  (all of them based on Martin Pool's C<nsort>) which I eventually
  discarded in favor of my algorithm.  If you are having to
  naturally-sort I<very large> data sets, and sorting is getting
  ridiculously slow, you might consider trying one of those
  discarded functions -- I have a feeling they might be faster on
  large data sets.  Benchmark them on your data and see.  (Unless
  you I<need> the speed, don't bother.  Hint: substitute C<sort>
  for C<nsort> in your code, and unless your program speeds up
  drastically, it's not the sorting that's slowing things down.
  But if it I<is> C<nsort> that's slowing things down, consider
  just:
  
        if(@set >= SOME_VERY_BIG_NUMBER) {
          no locale; # vroom vroom
          @sorted = sort(@set);  # feh, good enough
        } elsif(@set >= SOME_BIG_NUMBER) {
          use locale;
          @sorted = sort(@set);  # feh, good enough
        } else {
          # but keep it pretty for normal cases
          @sorted = nsort(@set);
        }
  
  =item *
  
  If you do adapt the routines in this module, email me; I'd
  just be interested in hearing about it.
  
  =item *
  
  Thanks to the EFNet #perl people for encouraging this module,
  especially magister and a-mused.
  
  =back
  
  =head1 COPYRIGHT AND DISCLAIMER
  
  Copyright 2001, Sean M. Burke C<sburke@cpan.org>, all rights
  reserved.  This program is free software; you can redistribute it
  and/or modify it under the same terms as Perl itself.
  
  This program is distributed in the hope that it will be useful, but
  without any warranty; without even the implied warranty of
  merchantability or fitness for a particular purpose.
  
  =head1 AUTHOR
  
  Sean M. Burke C<sburke@cpan.org>
  
  =cut
  
  ############   END OF DOCS   ############
  
  ############################################################################
  ############################################################################
  
  ############ BEGIN OLD STUFF ############
  
  # We can't have "use integer;", or else (5 <=> 5.1) comes out "0" !
  
  #-----------------------------------------------------------------------------
  sub nsort {
    my($cmp, $lc);
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      if($x =~ m/^[+-]?(?=\d|\.\d)\d*(?:\.\d*)?(?:[Ee](?:[+-]?\d+))?\z/s) {
        # It's entirely purely numeric, so treat it specially:
        push @bit, '', $x;
      } else {
        # Consume the string.
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          push @bit, ($x =~ s/^(\d+)//s) ?    $1  :  0;
        }
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      # End result: [original bit         , (text, number), (text, number), ...]
      # Minimally:  [0-length original bit,]
      # Examples:
      #    ['10'         => ''   ,  10,              ]
      #    ['fo900'      => 'fo' , 900,              ]
      #    ['foo10'      => 'foo',  10,              ]
      #    ['foo9.pl'    => 'foo',   9,   , '.pl', 0 ]
      #    ['foo32.pl'   => 'foo',  32,   , '.pl', 0 ]
      #    ['foo325.pl'  => 'foo', 325,   , '.pl', 0 ]
      #  Yes, always an ODD number of elements.
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Same as before, except without the pure-number trap.
  
  sub nsorts {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      while(length $x) {
        push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
        push @bit, ($x =~ s/^(\d+)//s) ?    $1  :  0;
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      # End result: [original bit         , (text, number), (text, number), ...]
      # Minimally:  [0-length original bit,]
      # Examples:
      #    ['10'         => ''   ,  10,              ]
      #    ['fo900'      => 'fo' , 900,              ]
      #    ['foo10'      => 'foo',  10,              ]
      #    ['foo9.pl'    => 'foo',   9,   , '.pl', 0 ]
      #    ['foo32.pl'   => 'foo',  32,   , '.pl', 0 ]
      #    ['foo325.pl'  => 'foo', 325,   , '.pl', 0 ]
      #  Yes, always an ODD number of elements.
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Same as before, except for the sort-key-making
  
  sub nsort0 {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 1;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a <=> @$b) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use cmp
        #  on the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ($x = defined($_) ? $_ : '');
  
      if($x =~ m/^[+-]?(?=\d|\.\d)\d*(?:\.\d*)?(?:[Ee](?:[+-]?\d+))?\z/s) {
        # It's entirely purely numeric, so treat it specially:
        push @bit, '', $x;
      } else {
        # Consume the string.
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          # Secret sauce:
          if($x =~ s/^(\d+)//s) {
            if(substr($1,0,1) eq '0' and $1 != 0) {
              push @bit, $1 / (10 ** length($1));
            } else {
              push @bit, $1;
            }
          } else {
            push @bit, 0;
          }
        }
      }
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      \@bit;
    }
    @_;
  }
  
  #-----------------------------------------------------------------------------
  # Like nsort0, but WITHOUT pure number handling, and WITH special treatment
  # of pulling off extensions and version numbers.
  
  sub nsortf {
    return @_ if @_ < 2;   # Just to be CLEVER.
  
    my($x, $i);  # scratch vars
  
    # And now, the GREAT BIG Schwartzian transform:
  
    map
      $_->[0],
  
    sort {
      # Uses $i as the index variable, $x as the result.
      $x = 0;
      $i = 3;
      DEBUG and print "\nComparing ", map("{$_}", @$a),
                   ' : ', map("{$_}", @$b), , "...\n";
  
      while($i < @$a and $i < @$b) {
        DEBUG and print "  comparing $i: {$a->[$i]} cmp {$b->[$i]} => ",
          $a->[$i] cmp $b->[$i], "\n";
        last if ($x = ($a->[$i] cmp $b->[$i])); # lexicographic
        ++$i;
  
        DEBUG and print "  comparing $i: {$a->[$i]} <=> {$b->[$i]} => ",
          $a->[$i] <=> $b->[$i], "\n";
        last if ($x = ($a->[$i] <=> $b->[$i])); # numeric
        ++$i;
      }
  
      DEBUG and print "{$a->[0]} : {$b->[0]} is ",
        $x || (@$a <=> @$b) || 0
        ,"\n"
      ;
      $x || (@$a     <=> @$b    ) || ($a->[1] cmp $b->[1])
         || ($a->[2] <=> $b->[2]) || ($a->[0] cmp $b->[0]);
        # unless we found a result for $x in the while loop,
        #  use length as a tiebreaker, otherwise use the
        #  lc'd extension, otherwise the verison, otherwise use
        #  the original string as a fallback tiebreaker.
    }
  
    map {
      my @bit = ( ($x = defined($_) ? $_ : ''), '',0 );
  
      {
        # Consume the string.
  
        # First, pull off any VAX-style version
        $bit[2] = $1 if $x =~ s/;(\d+)$//;
  
        # Then pull off any apparent extension
        if( $x !~ m/^\.+$/s and     # don't mangle ".", "..", or "..."
            $x =~ s/(\.[^\.\;]*)$//sg
            # We could try to avoid catching all-digit extensions,
            #  but I think that's getting /too/ clever.
        ) {
          $i = $1;
          if($x =~ m<[^\\\://]$>s) {
            # We didn't take the whole basename.
            $bit[1] = lc $i;
            DEBUG and print "Consuming extension \"$1\"\n";
          } else {
            # We DID take the whole basename.  Fix it.
            $x = $1;  # Repair it.
          }
        }
  
        push @bit, '', -1   if $x =~ m/^\./s;
         # A hack to make .-initial filenames sort first, regardless of locale.
         # And -1 is always a sort-firster, since in the code below, there's
         # no allowance for filenames containing negative numbers: -1.dat
         # will be read as string '-' followed by number 1.
  
        while(length $x) {
          push @bit, ($x =~ s/^(\D+)//s) ? lc($1) : '';
          # Secret sauce:
          if($x =~ s/^(\d+)//s) {
            if(substr($1,0,1) eq '0' and $1 != 0) {
              push @bit, $1 / (10 ** length($1));
            } else {
              push @bit, $1;
            }
          } else {
            push @bit, 0;
          }
        }
      }
  
      DEBUG and print "$bit[0] => ", map("{$_} ", @bit), "\n";
  
      \@bit;
    }
    @_;
  }
  
  # yowza yowza yowza.
  
SORT_NATURALLY

$fatpacked{"Test/YAML.pm"} = <<'TEST_YAML';
  package Test::YAML;
  
  use Test::Base 0.47 -Base;
  use lib 'lib';
  
  our $VERSION = '0.84';
  
  our $YAML    = 'YAML';
  our @EXPORT  = qw(
      no_diff
      run_yaml_tests
      run_roundtrip_nyn roundtrip_nyn
      run_load_passes load_passes
      dumper Load Dump LoadFile DumpFile
      XXX
  );
  
  delimiters('===', '+++');
  
  sub Dump     () { YAML(Dump => @_)     }
  sub Load     () { YAML(Load => @_)     }
  sub DumpFile () { YAML(DumpFile => @_) }
  sub LoadFile () { YAML(LoadFile => @_) }
  
  sub YAML () {
      load_yaml_pm();
      my $meth = shift;
      my $code = $YAML->can($meth) or die "$YAML cannot do $meth";
      goto &$code;
  }
  
  sub load_yaml_pm {
      my $file = "$YAML.pm";
      $file =~ s{::}{/}g;
      require $file;
  }
  
  sub run_yaml_tests() {
      run {
          my $block = shift;
          &{_get_function($block)}($block) unless 
            _skip_tests_for_now($block) or
            _skip_yaml_tests($block);
      };
  }
  
  sub run_roundtrip_nyn() {
      my @options = @_;
      run {
          my $block = shift;
          roundtrip_nyn($block, @options);
      };
  }
  
  sub roundtrip_nyn() {
      my $block = shift;
      my $option = shift || '';
      die "'perl' data section required"
          unless exists $block->{perl};
      my @values = eval $block->perl;
      die "roundtrip_nyn eval perl error: $@" if $@;
      my $config = $block->config || '';
      my $result = eval "$config; Dump(\@values)";
      die "roundtrip_nyn YAML::Dump error: $@" if $@;
      if (exists $block->{yaml}) {
          is $result, $block->yaml,
              $block->description . ' (n->y)';
      }
      else {
          pass $block->description . ' (n->y)';
      }
          
      return if exists $block->{no_round_trip} or
          not exists $block->{yaml};
  
      if ($option eq 'dumper') {
          is dumper(Load($block->yaml)), dumper(@values),
              $block->description . ' (y->n)';
      }
      else {
          is_deeply [Load($block->yaml)], [@values],
              $block->description . ' (y->n)';
      }
  }
  
  sub count_roundtrip_nyn() {
      my $block = shift or die "Bad call to count_roundtrip_nyn";
      return 1 if exists $block->{skip_this_for_now};
      my $count = 0;
      $count++ if exists $block->{perl};
      $count++ unless exists $block->{no_round_trip} or
          not exists $block->{yaml};
      die "Invalid test definition" unless $count;
      return $count;
  }
  
  sub run_load_passes() {
      run {
          my $block = shift;
          my $yaml = $block->yaml;
          eval { YAML(Load => $yaml) };
          is("$@", "");
      };
  }
  
  sub load_passes() {
      my $block = shift;
      my $yaml = $block->yaml;
      eval { YAML(Load => $yaml) };
      is "$@", "", $block->description;
  }
  
  sub count_load_passes() {1}
  
  sub dumper() {
      require Data::Dumper;
      $Data::Dumper::Sortkeys = 1;
      $Data::Dumper::Terse = 1;
      $Data::Dumper::Indent = 1;
      return Data::Dumper::Dumper(@_);
  }
  
  sub _count_tests() {
      my $block = shift or die "Bad call to _count_tests";
      no strict 'refs';
      &{'count_' . _get_function_name($block)}($block);
  }
  
  sub _get_function_name() {
      my $block = shift;
      return $block->function || 'roundtrip_nyn';
  }
  
  sub _get_function() {
      my $block = shift;
      no strict 'refs';
      \ &{_get_function_name($block)};
  }
  
  sub _skip_tests_for_now() {
      my $block = shift;
      if (exists $block->{skip_this_for_now}) {
          _skip_test(
              $block->description,
              _count_tests($block),
          );
          return 1;
      }
      return 0;
  }
  
  sub _skip_yaml_tests() {
      my $block = shift;
      if ($block->skip_unless_modules) {
          my @modules = split /[\s\,]+/, $block->skip_unless_modules;
          for my $module (@modules) {
              eval "require $module";
              if ($@) {
                  _skip_test(
                      "This test requires the '$module' module",
                      _count_tests($block),
                  );
                  return 1;
              }
          }
      }
      return 0;
  }
  
  sub _skip_test() {
      my ($message, $count) = @_;
      SKIP: {
          skip($message, $count);
      }
  }
  
  #-------------------------------------------------------------------------------
  package Test::YAML::Filter;
  
  use Test::Base::Filter ();
  
  our @ISA = 'Test::Base::Filter';
  
  sub yaml_dump {
      Test::YAML::Dump(@_);
  }
  
  sub yaml_load {
      Test::YAML::Load(@_);
  }
  
  sub Dump { goto &Test::YAML::Dump }
  sub Load { goto &Test::YAML::Load }
  sub DumpFile { goto &Test::YAML::DumpFile }
  sub LoadFile { goto &Test::YAML::LoadFile }
  
  sub yaml_load_or_fail {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $result;
  }
  
  sub yaml_load_error_or_warning {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub perl_eval_error_or_warning {
      my ($result, $error, $warning) =
        $self->_perl_eval_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub _yaml_load_result_error_warning {
      $self->assert_scalar(@_);
      my $yaml = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval {
          $self->yaml_load($yaml);
      };
      return ($result, $@, $warning);
  }
  
  sub _perl_eval_result_error_warning {
      $self->assert_scalar(@_);
      my $perl = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval $perl;
      return ($result, $@, $warning);
  }
  
  1;
  
  =head1 NAME
  
  Test::YAML - Testing Module for YAML Implementations
  
  =head1 SYNOPSIS
  
      use Test::YAML tests => 1;
  
      pass;
  
  =head1 DESCRIPTION
  
  Test::YAML is a subclass of Test::Base with YAML specific support.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
TEST_YAML

$fatpacked{"YAML.pm"} = <<'YAML';
  use 5.008001;
  package YAML;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use Exporter;
  push @YAML::ISA, 'Exporter';
  our @EXPORT = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  
  use YAML::Node; # XXX This is a temp fix for Module::Build
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  has dumper_class => default => sub {'YAML::Dumper'};
  has loader_class => default => sub {'YAML::Loader'};
  has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
  has loader_object => default => sub {$_[0]->init_action_object("loader")};
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, $!);
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, $!);
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  YAML - YAML Ain't Markup Language (tm)
  
  =head1 NOTE
  
  This module has been released to CPAN as YAML::Old, and soon YAML.pm
  will be changed to just be a frontend interface module for all the
  various Perl YAML implementation modules, including YAML::Old.
  
  If you want robust and fast YAML processing using the normal Dump/Load
  API, please consider switching to YAML::XS. It is by far the best Perl
  module for YAML at this time. It requires that you have a C compiler,
  since it is written in C.
  
  If you really need to use this version of YAML.pm it will always be
  available as YAML::Old.
  
  If you don't care which YAML module use, as long as it's the best one
  installed on your system, use YAML::Any.
  
  The rest of this documentation is left unchanged, until YAML.pm is
  switched over to the new UI-only version.
  
  =head1 SYNOPSIS
  
      use YAML;
      
      # Load a YAML stream of 3 YAML documents into Perl data structures.
      my ($hashref, $arrayref, $string) = Load(<<'...');
      ---
      name: ingy
      age: old
      weight: heavy
      # I should comment that I also like pink, but don't tell anybody.
      favorite colors:
          - red
          - green
          - blue
      ---
      - Clark Evans
      - Oren Ben-Kiki
      - Ingy dt Net
      --- >
      You probably think YAML stands for "Yet Another Markup Language". It
      ain't! YAML is really a data serialization language. But if you want
      to think of it as a markup, that's OK with me. A lot of people try
      to use XML as a serialization format.
      
      "YAML" is catchy and fun to say. Try it. "YAML, YAML, YAML!!!"
      ...
      
      # Dump the Perl data structures back into YAML.
      print Dump($string, $arrayref, $hashref);
      
      # YAML::Dump is used the same way you'd use Data::Dumper::Dumper
      use Data::Dumper;
      print Dumper($string, $arrayref, $hashref);
  
  =head1 DESCRIPTION
  
  The YAML.pm module implements a YAML Loader and Dumper based on the YAML
  1.0 specification. L<http://www.yaml.org/spec/>
  
  YAML is a generic data serialization language that is optimized for
  human readability. It can be used to express the data structures of most
  modern programming languages. (Including Perl!!!)
  
  For information on the YAML syntax, please refer to the YAML
  specification.
  
  =head1 WHY YAML IS COOL
  
  =over 4
  
  =item YAML is readable for people.
  
  It makes clear sense out of complex data structures. You should find
  that YAML is an exceptional data dumping tool. Structure is shown
  through indentation, YAML supports recursive data, and hash keys are
  sorted by default. In addition, YAML supports several styles of scalar
  formatting for different types of data.
  
  =item YAML is editable.
  
  YAML was designed from the ground up to be an excellent syntax for
  configuration files. Almost all programs need configuration files, so
  why invent a new syntax for each one? And why subject users to the
  complexities of XML or native Perl code?
  
  =item YAML is multilingual.
  
  Yes, YAML supports Unicode. But I'm actually referring to programming
  languages. YAML was designed to meet the serialization needs of Perl,
  Python, Ruby, Tcl, PHP, Javascript and Java. It was also designed to be
  interoperable between those languages. That means YAML serializations
  produced by Perl can be processed by Python.
  
  =item YAML is taint safe.
  
  Using modules like Data::Dumper for serialization is fine as long as you
  can be sure that nobody can tamper with your data files or
  transmissions. That's because you need to use Perl's C<eval()> built-in
  to deserialize the data. Somebody could add a snippet of Perl to erase
  your files.
  
  YAML's parser does not need to eval anything.
  
  =item YAML is full featured.
  
  YAML can accurately serialize all of the common Perl data structures and
  deserialize them again without losing data relationships. Although it is
  not 100% perfect (no serializer is or can be perfect), it fares as well
  as the popular current modules: Data::Dumper, Storable, XML::Dumper and
  Data::Denter.
  
  YAML.pm also has the ability to handle code (subroutine) references and
  typeglobs. (Still experimental) These features are not found in Perl's
  other serialization modules.
  
  =item YAML is extensible.
  
  The YAML language has been designed to be flexible enough to solve it's
  own problems. The markup itself has 3 basic construct which resemble
  Perl's hash, array and scalar. By default, these map to their Perl
  equivalents. But each YAML node also supports a tagging mechanism (type
  system) which can cause that node to be interpreted in a completely
  different manner. That's how YAML can support object serialization and
  oddball structures like Perl's typeglob.
  
  =back
  
  =head1 YAML IMPLEMENTATIONS IN PERL
  
  This module, YAML.pm, is really just the interface module for YAML
  modules written in Perl. The basic interface for YAML consists of two
  functions: C<Dump> and C<Load>. The real work is done by the modules
  YAML::Dumper and YAML::Loader.
  
  Different YAML module distributions can be created by subclassing
  YAML.pm and YAML::Loader and YAML::Dumper. For example, YAML-Simple
  consists of YAML::Simple YAML::Dumper::Simple and YAML::Loader::Simple.
  
  Why would there be more than one implementation of YAML? Well, despite
  YAML's offering of being a simple data format, YAML is actually very
  deep and complex. Implementing the entirety of the YAML specification is
  a daunting task.
  
  For this reason I am currently working on 3 different YAML implementations.
  
  =over
  
  =item YAML
  
  The main YAML distribution will keeping evolving to support the entire
  YAML specification in pure Perl. This may not be the fastest or most
  stable module though. Currently, YAML.pm has lots of known bugs. It is
  mostly a great tool for dumping Perl data structures to a readable form.
  
  =item YAML::Tiny
  
  The point of YAML::Tiny is to strip YAML down to the 90% that people
  use most and offer that in a small, fast, stable, pure Perl form.
  YAML::Tiny will simply die when it is asked to do something it can't.
  
  =item YAML::Syck
  
  C<libsyck> is the C based YAML processing library used by the Ruby
  programming language (and also Python, PHP and Pugs). YAML::Syck is the
  Perl binding to C<libsyck>. It should be very fast, but may have
  problems of its own. It will also require C compilation.
  
  NOTE: Audrey Tang has actually completed this module and it works great
        and is 10 times faster than YAML.pm.
  
  =back
  
  In the future, there will likely be even more YAML modules. Remember,
  people other than Ingy are allowed to write YAML modules!
  
  =head1 FUNCTIONAL USAGE
  
  YAML is completely OO under the hood. Still it exports a few useful top
  level functions so that it is dead simple to use. These functions just
  do the OO stuff for you. If you want direct access to the OO API see the
  documentation for YAML::Dumper and YAML::Loader.
  
  =head2 Exported Functions
  
  The following functions are exported by YAML.pm by default. The reason
  they are exported is so that YAML works much like Data::Dumper. If you
  don't want functions to be imported, just use YAML with an empty
  import list:
  
      use YAML ();
  
  =over 4
  
  =item Dump(list-of-Perl-data-structures)
  
  Turn Perl data into YAML. This function works very much like
  Data::Dumper::Dumper(). It takes a list of Perl data strucures and
  dumps them into a serialized form. It returns a string containing the
  YAML stream. The structures can be references or plain scalars.
  
  =item Load(string-containing-a-YAML-stream)
  
  Turn YAML into Perl data. This is the opposite of Dump. Just like
  Storable's thaw() function or the eval() function in relation to
  Data::Dumper. It parses a string containing a valid YAML stream into a
  list of Perl data structures.
  
  =back
  
  =head2 Exportable Functions
  
  These functions are not exported by default but you can request them in
  an import list like this:
  
      use YAML qw'freeze thaw Bless';
  
  =over 4
  
  =item freeze() and thaw()
  
  Aliases to Dump() and Load() for Storable fans. This will also allow
  YAML.pm to be plugged directly into modules like POE.pm, that use the
  freeze/thaw API for internal serialization.
  
  =item DumpFile(filepath, list)
  
  Writes the YAML stream to a file instead of just returning a string.
  
  =item LoadFile(filepath)
  
  Reads the YAML stream from a file instead of a string.
  
  =item Bless(perl-node, [yaml-node | class-name])
  
  Associate a normal Perl node, with a yaml node. A yaml node is an object
  tied to the YAML::Node class. The second argument is either a yaml node
  that you've already created or a class (package) name that supports a
  yaml_dump() function. A yaml_dump() function should take a perl node and
  return a yaml node. If no second argument is provided, Bless will create
  a yaml node. This node is not returned, but can be retrieved with the
  Blessed() function.
  
  Here's an example of how to use Bless. Say you have a hash containing
  three keys, but you only want to dump two of them. Furthermore the keys
  must be dumped in a certain order. Here's how you do that:
  
      use YAML qw(Dump Bless);
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash)->keys(['banana', 'apple']);
      print Dump $hash;
  
  produces:
  
      ---
      apple: good
      banana: bad
      cauliflower: ugly
      ---
      banana: bad
      apple: good
  
  Bless returns the tied part of a yaml-node, so that you can call the
  YAML::Node methods. This is the same thing that YAML::Node::ynode()
  returns. So another way to do the above example is:
  
      use YAML qw(Dump Bless);
      use YAML::Node;
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash);
      $ynode = ynode(Blessed($hash));
      $ynode->keys(['banana', 'apple']);
      print Dump $hash;
  
  Note that Blessing a Perl data structure does not change it anyway. The
  extra information is stored separately and looked up by the Blessed
  node's memory address.
  
  =item Blessed(perl-node)
  
  Returns the yaml node that a particular perl node is associated with
  (see above). Returns undef if the node is not (YAML) Blessed.
  
  =back
  
  =head1 GLOBAL OPTIONS
  
  YAML options are set using a group of global variables in the YAML
  namespace. This is similar to how Data::Dumper works.
  
  For example, to change the indentation width, do something like:
  
      local $YAML::Indent = 3;
  
  The current options are:
  
  =over 4
  
  =item DumperClass
  
  You can override which module/class YAML uses for Dumping data.
  
  =item LoaderClass
  
  You can override which module/class YAML uses for Loading data.
  
  =item Indent
  
  This is the number of space characters to use for each indentation level
  when doing a Dump(). The default is 2.
  
  By the way, YAML can use any number of characters for indentation at any
  level. So if you are editing YAML by hand feel free to do it anyway that
  looks pleasing to you; just be consistent for a given level.
  
  =item SortKeys
  
  Default is 1. (true)
  
  Tells YAML.pm whether or not to sort hash keys when storing a document.
  
  YAML::Node objects can have their own sort order, which is usually what
  you want. To override the YAML::Node order and sort the keys anyway, set
  SortKeys to 2.
  
  =item Stringify
  
  Default is 0. (false)
  
  Objects with string overloading should honor the overloading and dump the
  stringification of themselves, rather than the actual object's guts.
  
  =item UseHeader
  
  Default is 1. (true)
  
  This tells YAML.pm whether to use a separator string for a Dump
  operation. This only applies to the first document in a stream.
  Subsequent documents must have a YAML header by definition.
  
  =item UseVersion
  
  Default is 0. (false)
  
  Tells YAML.pm whether to include the YAML version on the
  separator/header.
  
      --- %YAML:1.0
  
  =item AnchorPrefix
  
  Default is ''.
  
  Anchor names are normally numeric. YAML.pm simply starts with '1' and
  increases by one for each new anchor. This option allows you to specify a
  string to be prepended to each anchor number.
  
  =item UseCode
  
  Setting the UseCode option is a shortcut to set both the DumpCode and
  LoadCode options at once. Setting UseCode to '1' tells YAML.pm to dump
  Perl code references as Perl (using B::Deparse) and to load them back
  into memory using eval(). The reason this has to be an option is that
  using eval() to parse untrusted code is, well, untrustworthy.
  
  =item DumpCode
  
  Determines if and how YAML.pm should serialize Perl code references. By
  default YAML.pm will dump code references as dummy placeholders (much
  like Data::Dumper). If DumpCode is set to '1' or 'deparse', code
  references will be dumped as actual Perl code.
  
  DumpCode can also be set to a subroutine reference so that you can
  write your own serializing routine. YAML.pm passes you the code ref. You
  pass back the serialization (as a string) and a format indicator. The
  format indicator is a simple string like: 'deparse' or 'bytecode'.
  
  =item LoadCode
  
  LoadCode is the opposite of DumpCode. It tells YAML if and how to
  deserialize code references. When set to '1' or 'deparse' it will use
  C<eval()>. Since this is potentially risky, only use this option if you
  know where your YAML has been.
  
  LoadCode can also be set to a subroutine reference so that you can write
  your own deserializing routine. YAML.pm passes the serialization (as a
  string) and a format indicator. You pass back the code reference.
  
  =item UseBlock
  
  YAML.pm uses heuristics to guess which scalar style is best for a given
  node. Sometimes you'll want all multiline scalars to use the 'block'
  style. If so, set this option to 1.
  
  NOTE: YAML's block style is akin to Perl's here-document.
  
  =item UseFold
  
  If you want to force YAML to use the 'folded' style for all multiline
  scalars, then set $UseFold to 1.
  
  NOTE: YAML's folded style is akin to the way HTML folds text,
        except smarter.
  
  =item UseAliases
  
  YAML has an alias mechanism such that any given structure in memory gets
  serialized once. Any other references to that structure are serialized
  only as alias markers. This is how YAML can serialize duplicate and
  recursive structures.
  
  Sometimes, when you KNOW that your data is nonrecursive in nature, you
  may want to serialize such that every node is expressed in full. (ie as
  a copy of the original). Setting $YAML::UseAliases to 0 will allow you
  to do this. This also may result in faster processing because the lookup
  overhead is by bypassed.
  
  THIS OPTION CAN BE DANGEROUS. *If* your data is recursive, this option
  *will* cause Dump() to run in an endless loop, chewing up your computers
  memory. You have been warned.
  
  =item CompressSeries
  
  Default is 1.
  
  Compresses the formatting of arrays of hashes:
  
      -
        foo: bar
      - 
        bar: foo
  
  becomes:
  
      - foo: bar
      - bar: foo
  
  Since this output is usually more desirable, this option is turned on by
  default.
  
  =back
  
  =head1 YAML TERMINOLOGY
  
  YAML is a full featured data serialization language, and thus has its
  own terminology.
  
  It is important to remember that although YAML is heavily influenced by
  Perl and Python, it is a language in its own right, not merely just a
  representation of Perl structures.
  
  YAML has three constructs that are conspicuously similar to Perl's hash,
  array, and scalar. They are called mapping, sequence, and string
  respectively. By default, they do what you would expect. But each
  instance may have an explicit or implicit tag (type) that makes it
  behave differently. In this manner, YAML can be extended to represent
  Perl's Glob or Python's tuple, or Ruby's Bigint.
  
  =over 4
  
  =item stream
  
  A YAML stream is the full sequence of unicode characters that a YAML
  parser would read or a YAML emitter would write. A stream may contain
  one or more YAML documents separated by YAML headers.
  
      ---
      a: mapping
      foo: bar
      ---
      - a
      - sequence
  
  =item document
  
  A YAML document is an independent data structure representation within a
  stream. It is a top level node. Each document in a YAML stream must
  begin with a YAML header line. Actually the header is optional on the
  first document.
  
      ---
      This: top level mapping
      is:
          - a
          - YAML
          - document
  
  =item header
  
  A YAML header is a line that begins a YAML document. It consists of
  three dashes, possibly followed by more info. Another purpose of the
  header line is that it serves as a place to put top level tag and anchor
  information.
  
      --- !recursive-sequence &001
      - * 001
      - * 001
  
  =item node
  
  A YAML node is the representation of a particular data stucture. Nodes
  may contain other nodes. (In Perl terms, nodes are like scalars.
  Strings, arrayrefs and hashrefs. But this refers to the serialized
  format, not the in-memory structure.)
  
  =item tag
  
  This is similar to a type. It indicates how a particular YAML node
  serialization should be transferred into or out of memory. For instance
  a Foo::Bar object would use the tag 'perl/Foo::Bar':
  
      - !perl/Foo::Bar
          foo: 42
          bar: stool
  
  =item collection
  
  A collection is the generic term for a YAML data grouping. YAML has two
  types of collections: mappings and sequences. (Similar to hashes and arrays)
  
  =item mapping
  
  A mapping is a YAML collection defined by unordered key/value pairs with
  unique keys. By default YAML mappings are loaded into Perl hashes.
  
      a mapping:
          foo: bar
          two: times two is 4
  
  =item sequence
  
  A sequence is a YAML collection defined by an ordered list of elements. By
  default YAML sequences are loaded into Perl arrays.
  
      a sequence:
          - one bourbon
          - one scotch
          - one beer
  
  =item scalar
  
  A scalar is a YAML node that is a single value. By default YAML scalars
  are loaded into Perl scalars.
  
      a scalar key: a scalar value
  
  YAML has many styles for representing scalars. This is important because
  varying data will have varying formatting requirements to retain the
  optimum human readability.
  
  =item plain scalar
  
  A plain scalar is unquoted. All plain scalars are automatic candidates
  for "implicit tagging". This means that their tag may be determined
  automatically by examination. The typical uses for this are plain alpha
  strings, integers, real numbers, dates, times and currency.
  
      - a plain string
      - -42
      - 3.1415
      - 12:34
      - 123 this is an error
  
  =item single quoted scalar
  
  This is similar to Perl's use of single quotes. It means no escaping
  except for single quotes which are escaped by using two adjacent
  single quotes.
  
      - 'When I say ''\n'' I mean "backslash en"'
  
  =item double quoted scalar
  
  This is similar to Perl's use of double quotes. Character escaping can
  be used.
  
      - "This scalar\nhas two lines, and a bell -->\a"
  
  =item folded scalar
  
  This is a multiline scalar which begins on the next line. It is
  indicated by a single right angle bracket. It is unescaped like the
  single quoted scalar. Line folding is also performed.
  
      - > 
       This is a multiline scalar which begins on
       the next line. It is indicated by a single
       carat. It is unescaped like the single
       quoted scalar. Line folding is also
       performed.
  
  =item block scalar
  
  This final multiline form is akin to Perl's here-document except that
  (as in all YAML data) scope is indicated by indentation. Therefore, no
  ending marker is required. The data is verbatim. No line folding.
  
      - |
          QTY  DESC          PRICE  TOTAL
          ---  ----          -----  -----
            1  Foo Fighters  $19.95 $19.95
            2  Bar Belles    $29.95 $59.90
  
  =item parser
  
  A YAML processor has four stages: parse, load, dump, emit.
  
  A parser parses a YAML stream. YAML.pm's Load() function contains a
  parser.
  
  =item loader
  
  The other half of the Load() function is a loader. This takes the
  information from the parser and loads it into a Perl data structure.
  
  =item dumper
  
  The Dump() function consists of a dumper and an emitter. The dumper
  walks through each Perl data structure and gives info to the emitter.
  
  =item emitter
  
  The emitter takes info from the dumper and turns it into a YAML stream.
  
  NOTE:
  In YAML.pm the parser/loader and the dumper/emitter code are currently
  very closely tied together. In the future they may be broken into
  separate stages.
  
  =back
  
  For more information please refer to the immensely helpful YAML
  specification available at L<http://www.yaml.org/spec/>.
  
  =head1 ysh - The YAML Shell
  
  The YAML distribution ships with a script called 'ysh', the YAML shell.
  ysh provides a simple, interactive way to play with YAML. If you type in
  Perl code, it displays the result in YAML. If you type in YAML it turns
  it into Perl code.
  
  To run ysh, (assuming you installed it along with YAML.pm) simply type:
  
      ysh [options]
  
  Please read the C<ysh> documentation for the full details. There are
  lots of options.
  
  =head1 BUGS & DEFICIENCIES
  
  If you find a bug in YAML, please try to recreate it in the YAML Shell
  with logging turned on ('ysh -L'). When you have successfully reproduced
  the bug, please mail the LOG file to the author (ingy@cpan.org).
  
  WARNING: This is still *ALPHA* code. Well, most of this code has been
  around for years...
  
  BIGGER WARNING: YAML.pm has been slow in the making, but I am committed
  to having top notch YAML tools in the Perl world. The YAML team is close
  to finalizing the YAML 1.1 spec. This version of YAML.pm is based off of
  a very old pre 1.0 spec. In actuality there isn't a ton of difference,
  and this YAML.pm is still fairly useful. Things will get much better in
  the future.
  
  =head1 RESOURCES
  
  L<http://lists.sourceforge.net/lists/listinfo/yaml-core> is the mailing
  list. This is where the language is discussed and designed.
  
  L<http://www.yaml.org> is the official YAML website.
  
  L<http://www.yaml.org/spec/> is the YAML 1.0 specification.
  
  L<http://yaml.kwiki.org> is the official YAML wiki.
  
  =head1 SEE ALSO
  
  See YAML::XS. Fast!
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  is resonsible for YAML.pm.
  
  The YAML serialization language is the result of years of collaboration
  between Oren Ben-Kiki, Clark Evans and Ingy dt Net. Several others
  have added help along the way.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005, 2006, 2008, 2011-2012. Ingy dt Net.
  
  Copyright (c) 2001, 2002, 2005. Brian Ingerson.
  
  Some parts copyright (c) 2009 - 2010 Adam Kennedy
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML

$fatpacked{"YAML/Any.pm"} = <<'YAML_ANY';
  package YAML::Any;
  
  our $VERSION = '0.84';
  
  use strict;
  use Exporter ();
  
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::Croak(@_);
  }
  
  1;
  
  =head1 NAME
  
  YAML::Any - Pick a YAML implementation and use it.
  
  =head1 SYNOPSIS
  
      use YAML::Any;
      $YAML::Indent = 3;
      my $yaml = Dump(@objects);
  
  =head1 DESCRIPTION
  
  There are several YAML implementations that support the Dump/Load API.
  This module selects the best one available and uses it.
  
  =head1 ORDER
  
  Currently, YAML::Any will choose the first one of these YAML
  implementations that is installed on your system:
  
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  
  =head1 OPTIONS
  
  If you specify an option like:
  
      $YAML::Indent = 4;
  
  And YAML::Any is using YAML::XS, it will use the proper variable:
  $YAML::XS::Indent.
  
  =head1 SUBROUTINES
  
  Like all the YAML modules that YAML::Any uses, the following subroutines
  are exported by default:
  
      Dump
      Load
  
  and the following subroutines are exportable by request:
  
      DumpFile
      LoadFile
  
  =head1 METHODS
  
  YAML::Any provides the following class methods.
  
  =over
  
  =item YAML::Any->order;
  
  This method returns a list of the current possible implementations that
  YAML::Any will search for.
  
  =item YAML::Any->implementation;
  
  This method returns the implementation the YAML::Any will use. This
  result is obtained by finding the first member of YAML::Any->order that
  is either already loaded in C<%INC> or that can be loaded using
  C<require>. If no implementation is found, an error will be thrown.
  
  =back
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008. Ingy dt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = <<'YAML_DUMPER';
  package YAML::Dumper;
  use YAML::Mo;
  extends 'YAML::Dumper::Base';
  
  our $VERSION = '0.84';
  
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';    
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo); 
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and 
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {  
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0], 
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) = 
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} = 
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) = 
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash. 
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
          
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last 
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Dumper - YAML class for dumping Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Dumper;
      my $dumper = YAML::Dumper->new;
      $dumper->indent_width(4);
      print $dumper->dump({foo => 'bar'});
  
  =head1 DESCRIPTION
  
  YAML::Dumper is the module that YAML.pm used to serialize Perl objects to
  YAML. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = <<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use YAML::Node;
  
  # YAML Dumping options
  has spec_version    => default => sub {'1.0'};
  has indent_width    => default => sub {2};
  has use_header      => default => sub {1};
  has use_version     => default => sub {0};
  has sort_keys       => default => sub {1};
  has anchor_prefix   => default => sub {''};
  has dump_code       => default => sub {0};
  has use_block       => default => sub {0};
  has use_fold        => default => sub {0};
  has compress_series => default => sub {1};
  has inline_series   => default => sub {0};
  has use_aliases     => default => sub {1};
  has purity          => default => sub {0};
  has stringify       => default => sub {0};
  
  # Properties
  has stream      => default => sub {''};
  has document    => default => sub {0};
  has transferred => default => sub {{}};
  has id_refcnt   => default => sub {{}};
  has id_anchor   => default => sub {{}};
  has anchor      => default => sub {1};
  has level       => default => sub {0};
  has offset      => default => sub {[]};
  has headless    => default => sub {0};
  has blessed_map => default => sub {{}};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
      
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Dumper::Base - Base class for YAML Dumper classes
  
  =head1 SYNOPSIS
  
      package YAML::Dumper::Something;
      use YAML::Dumper::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Dumper::Base is a base class for creating YAML dumper classes.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = <<'YAML_ERROR';
  package YAML::Error;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  has 'code';
  has 'type' => default => sub {'Error'};
  has 'line';
  has 'document';
  has 'arguments' => default => sub {[]};
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)} 
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION 
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR 
       YAML_PARSE_ERR_NO_ANCHOR 
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  
  our @ISA = 'YAML::Error';
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Error - Error formatting class for YAML modules
  
  =head1 SYNOPSIS
  
      $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias);
      $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
  
  =head1 DESCRIPTION
  
  This module provides a C<die> and a C<warn> facility.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = <<'YAML_LOADER';
  package YAML::Loader;
  use YAML::Mo;
  extends 'YAML::Loader::Base';
  
  our $VERSION = '0.84';
  
  use YAML::Loader::Base;
  use YAML::Types;
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';    
  my $LIT_CHAR_RX = "\\$LIT_CHAR";    
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS') 
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE') 
        if length($self->stream) and 
           $self->{stream} !~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) = 
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) = 
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) { 
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line]; 
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE'); 
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--; 
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR') 
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface); 
  }
  
  # Morph a node to it's explicit type  
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
          
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign) 
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
              
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
          if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) = 
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line]; 
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE') 
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^"((?:\\"|[^"])*)"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:''|[^'])*)'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`\^]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately  
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      return if $self->eos;
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/ or die;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and 
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or die;
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
          
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos; 
      
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and 
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION') 
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
     
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Loader - YAML class for loading Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Loader;
      my $loader = YAML::Loader->new;
      my $hash = $loader->load(<<'...');
      foo: bar
      ...
  
  =head1 DESCRIPTION
  
  YAML::Loader is the module that YAML.pm used to deserialize YAML to Perl
  objects. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = <<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  has load_code     => default => sub {0};
  has stream        => default => sub {''};
  has document      => default => sub {0};
  has line          => default => sub {0};
  has documents     => default => sub {[]};
  has lines         => default => sub {[]};
  has eos           => default => sub {0};
  has done          => default => sub {0};
  has anchor2node   => default => sub {{}};
  has level         => default => sub {0};
  has offset        => default => sub {[]};
  has preface       => default => sub {''};
  has content       => default => sub {''};
  has indent        => default => sub {0};
  has major_version => default => sub {0};
  has minor_version => default => sub {0};
  has inline        => default => sub {''};
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Loader::Base - Base class for YAML Loader classes
  
  =head1 SYNOPSIS
  
      package YAML::Loader::Something;
      use YAML::Loader::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Loader::Base is a base class for creating YAML loader classes.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = <<'YAML_MARSHALL';
  use strict;
  use warnings;
  package YAML::Marshall;
  
  our $VERSION = '0.84';
  
  use YAML::Node ();
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Marshall - YAML marshalling class you can mixin to your classes
  
  =head1 SYNOPSIS
  
      package Bar;
      use Foo -base;
      use YAML::Marshall -mixin;
  
  =head1 DESCRIPTION
  
  For classes that want to handle their own YAML serialization.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = <<'YAML_MO';
  package YAML::Mo; $VERSION = '0.84';
  # use Mo qw[builder default import];
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version 0.31
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{bless{@_[1..$#_]},$_[0]};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;$a{default}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$a{default}->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not $_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
  
  our $DumperModule = 'Data::Dumper';
  
  my ($_new_error, $_info, $_scalar_info);
  
  no strict 'refs';
  *{$M.'Object::die'} = sub {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  };
  
  *{$M.'Object::warn'} = sub {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  };
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  *{$M.'Object::node_info'} = sub {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  };
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
  
  1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = <<'YAML_NODE';
  use strict;
  use warnings;
  package YAML::Node;
  
  our $VERSION = '0.84';
  
  use YAML::Tag;
  require YAML::Mo;
  
  use Exporter;
  our @ISA     = qw(Exporter YAML::Mo::Object);
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
  	$self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
  	$self = tied(@{$_[0]});
      }
      elsif (ref(\$_[0]) eq 'GLOB') {
  	$self = tied(*{$_[0]});
      }
      else {
  	$self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = YAML::Mo::Object->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
  		    ($type eq 'HASH') ? 'mapping' :
  		    $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
  	yaml_scalar->new($self, $_[1]);
  	return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};    
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{TAG} = YAML::Tag->new($value);
  	return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{KEYS} = $value;
  	return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS = 
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS = 
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}}; 
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
  	return (grep {$_ eq $key} @{$self->{KEYS}}) 
  	       ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
  	$self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
  	$self->{HASH}{$key} = $value;
      }
      else {
  	if (not grep {$_ eq $key} @{$self->{KEYS}}) {
  	    push(@{$self->{KEYS}}, $key);
  	}
  	$self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
  	$return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
  	$return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
  	if ($self->{KEYS}[$i] eq $key) {
  	    splice(@{$self->{KEYS}}, $i, 1);
  	}
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Node - A generic data node that encapsulates YAML information
  
  =head1 SYNOPSIS
  
      use YAML;
      use YAML::Node;
      
      my $ynode = YAML::Node->new({}, 'ingerson.com/fruit');
      %$ynode = qw(orange orange apple red grape green);
      print Dump $ynode;
  
  yields:
  
      --- !ingerson.com/fruit
      orange: orange
      apple: red
      grape: green
  
  =head1 DESCRIPTION
  
  A generic node in YAML is similar to a plain hash, array, or scalar node
  in Perl except that it must also keep track of its type. The type is a
  URI called the YAML type tag.
  
  YAML::Node is a class for generating and manipulating these containers.
  A YAML node (or ynode) is a tied hash, array or scalar. In most ways it
  behaves just like the plain thing. But you can assign and retrieve and
  YAML type tag URI to it. For the hash flavor, you can also assign the
  order that the keys will be retrieved in. By default a ynode will offer
  its keys in the same order that they were assigned.
  
  YAML::Node has a class method call new() that will return a ynode. You
  pass it a regular node and an optional type tag. After that you can
  use it like a normal Perl node, but when you YAML::Dump it, the magical
  properties will be honored.
  
  This is how you can control the sort order of hash keys during a YAML
  serialization. By default, YAML sorts keys alphabetically. But notice
  in the above example that the keys were Dumped in the same order they
  were assigned.
  
  YAML::Node exports a function called ynode(). This function returns the tied object so that you can call special methods on it like ->keys().
  
  keys() works like this:
  
      use YAML;
      use YAML::Node;
      
      %$node = qw(orange orange apple red grape green);
      $ynode = YAML::Node->new($node);
      ynode($ynode)->keys(['grape', 'apple']);
      print Dump $ynode;
  
  produces:
  
      ---
      grape: green
      apple: red
  
  It tells the ynode which keys and what order to use.
  
  ynodes will play a very important role in how programs use YAML. They
  are the foundation of how a Perl class can marshall the Loading and
  Dumping of its objects.
  
  The upcoming versions of YAML.pm will have much more information on this.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  Copyright (c) 2002. Brian Ingerson. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = <<'YAML_TAG';
  use strict;
  use warnings;
  package YAML::Tag;
  
  our $VERSION = '0.84';
  
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Tag - Tag URI object class for YAML
  
  =head1 SYNOPSIS
  
      use YAML::Tag;
  
  =head1 DESCRIPTION
  
  Used by YAML::Node.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TAG

$fatpacked{"YAML/Types.pm"} = <<'YAML_TYPES';
  package YAML::Types;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use YAML::Node;
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  use YAML::Mo; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  
  sub yaml_dump {
      my $self = shift;
      my $ynode = YAML::Node->new({}, '!perl/glob:');
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  if ($value->{fileno} = fileno(*{$_[0]})) {
                      local $^W;
                      map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value; 
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  
  my $dummy_warned = 0; 
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { use B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }    
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      $flags =~ s/^\^//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Types - Marshall Perl internal data types to/from YAML
  
  =head1 SYNOPSIS
  
      $::foo = 42;
      print YAML::Dump(*::foo);
  
      print YAML::Dump(qr{match me});
  
  =head1 DESCRIPTION
  
  This module has the helper classes for transferring objects,
  subroutines, references, globs, regexps and file handles to and
  from YAML.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TYPES

$fatpacked{"autodie.pm"} = <<'AUTODIE';
  package autodie;
  use 5.008;
  use strict;
  use warnings;
  
  use Fatal ();
  our @ISA = qw(Fatal);
  our $VERSION;
  
  # ABSTRACT: Replace functions with ones that succeed or die with lexical scope
  
  BEGIN {
      our $VERSION = '2.20'; # VERSION: Generated by DZP::OurPkg::Version
  }
  
  use constant ERROR_WRONG_FATAL => q{
  Incorrect version of Fatal.pm loaded by autodie.
  
  The autodie pragma uses an updated version of Fatal to do its
  heavy lifting.  We seem to have loaded Fatal version %s, which is
  probably the version that came with your version of Perl.  However
  autodie needs version %s, which would have come bundled with
  autodie.
  
  You may be able to solve this problem by adding the following
  line of code to your main program, before any use of Fatal or
  autodie.
  
      use lib "%s";
  
  };
  
  # We have to check we've got the right version of Fatal before we
  # try to compile the rest of our code, lest we use a constant
  # that doesn't exist.
  
  BEGIN {
  
      # If we have the wrong Fatal, then we've probably loaded the system
      # one, not our own.  Complain, and give a useful hint. ;)
  
      if ($Fatal::VERSION ne $VERSION) {
          my $autodie_path = $INC{'autodie.pm'};
  
          $autodie_path =~ s/autodie\.pm//;
  
          require Carp;
  
          Carp::croak sprintf(
              ERROR_WRONG_FATAL, $Fatal::VERSION, $VERSION, $autodie_path
          );
      }
  }
  
  # When passing args to Fatal we want to keep the first arg
  # (our package) in place.  Hence the splice.
  
  sub import {
          splice(@_,1,0,Fatal::LEXICAL_TAG);
          goto &Fatal::import;
  }
  
  sub unimport {
          splice(@_,1,0,Fatal::LEXICAL_TAG);
          goto &Fatal::unimport;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie - Replace functions with ones that succeed or die with lexical scope
  
  =head1 SYNOPSIS
  
      use autodie;            # Recommended: implies 'use autodie qw(:default)'
  
      use autodie qw(:all);   # Recommended more: defaults and system/exec.
  
      use autodie qw(open close);   # open/close succeed or die
  
      open(my $fh, "<", $filename); # No need to check!
  
      {
          no autodie qw(open);          # open failures won't die
          open(my $fh, "<", $filename); # Could fail silently!
          no autodie;                   # disable all autodies
      }
  
  =head1 DESCRIPTION
  
          bIlujDI' yIchegh()Qo'; yIHegh()!
  
          It is better to die() than to return() in failure.
  
                  -- Klingon programming proverb.
  
  The C<autodie> pragma provides a convenient way to replace functions
  that normally return false on failure with equivalents that throw
  an exception on failure.
  
  The C<autodie> pragma has I<lexical scope>, meaning that functions
  and subroutines altered with C<autodie> will only change their behaviour
  until the end of the enclosing block, file, or C<eval>.
  
  If C<system> is specified as an argument to C<autodie>, then it
  uses L<IPC::System::Simple> to do the heavy lifting.  See the
  description of that module for more information.
  
  =head1 EXCEPTIONS
  
  Exceptions produced by the C<autodie> pragma are members of the
  L<autodie::exception> class.  The preferred way to work with
  these exceptions under Perl 5.10 is as follows:
  
      use feature qw(switch);
  
      eval {
          use autodie;
  
          open(my $fh, '<', $some_file);
  
          my @records = <$fh>;
  
          # Do things with @records...
  
          close($fh);
  
      };
  
      given ($@) {
          when (undef)   { say "No error";                    }
          when ('open')  { say "Error from open";             }
          when (':io')   { say "Non-open, IO error.";         }
          when (':all')  { say "All other autodie errors."    }
          default        { say "Not an autodie error at all." }
      }
  
  Under Perl 5.8, the C<given/when> structure is not available, so the
  following structure may be used:
  
      eval {
          use autodie;
  
          open(my $fh, '<', $some_file);
  
          my @records = <$fh>;
  
          # Do things with @records...
  
          close($fh);
      };
  
      if ($@ and $@->isa('autodie::exception')) {
          if ($@->matches('open')) { print "Error from open\n";   }
          if ($@->matches(':io' )) { print "Non-open, IO error."; }
      } elsif ($@) {
          # A non-autodie exception.
      }
  
  See L<autodie::exception> for further information on interrogating
  exceptions.
  
  =head1 CATEGORIES
  
  Autodie uses a simple set of categories to group together similar
  built-ins.  Requesting a category type (starting with a colon) will
  enable autodie for all built-ins beneath that category.  For example,
  requesting C<:file> will enable autodie for C<close>, C<fcntl>,
  C<fileno>, C<open> and C<sysopen>.
  
  The categories are currently:
  
      :all
          :default
              :io
                  read
                  seek
                  sysread
                  sysseek
                  syswrite
                  :dbm
                      dbmclose
                      dbmopen
                  :file
                      binmode
                      close
                      chmod
                      chown
                      fcntl
                      fileno
                      flock
                      ioctl
                      open
                      sysopen
                      truncate
                  :filesys
                      chdir
                      closedir
                      opendir
                      link
                      mkdir
                      readlink
                      rename
                      rmdir
                      symlink
                      unlink
                  :ipc
                      pipe
                      :msg
                          msgctl
                          msgget
                          msgrcv
                          msgsnd
                      :semaphore
                          semctl
                          semget
                          semop
                      :shm
                          shmctl
                          shmget
                          shmread
                  :socket
                      accept
                      bind
                      connect
                      getsockopt
                      listen
                      recv
                      send
                      setsockopt
                      shutdown
                      socketpair
              :threads
                  fork
          :system
              system
              exec
  
  
  Note that while the above category system is presently a strict
  hierarchy, this should not be assumed.
  
  A plain C<use autodie> implies C<use autodie qw(:default)>.  Note that
  C<system> and C<exec> are not enabled by default.  C<system> requires
  the optional L<IPC::System::Simple> module to be installed, and enabling
  C<system> or C<exec> will invalidate their exotic forms.  See L</BUGS>
  below for more details.
  
  The syntax:
  
      use autodie qw(:1.994);
  
  allows the C<:default> list from a particular version to be used.  This
  provides the convenience of using the default methods, but the surety
  that no behavioral changes will occur if the C<autodie> module is
  upgraded.
  
  C<autodie> can be enabled for all of Perl's built-ins, including
  C<system> and C<exec> with:
  
      use autodie qw(:all);
  
  =head1 FUNCTION SPECIFIC NOTES
  
  =head2 flock
  
  It is not considered an error for C<flock> to return false if it fails
  due to an C<EWOULDBLOCK> (or equivalent) condition.  This means one can
  still use the common convention of testing the return value of
  C<flock> when called with the C<LOCK_NB> option:
  
      use autodie;
  
      if ( flock($fh, LOCK_EX | LOCK_NB) ) {
          # We have a lock
      }
  
  Autodying C<flock> will generate an exception if C<flock> returns
  false with any other error.
  
  =head2 system/exec
  
  The C<system> built-in is considered to have failed in the following
  circumstances:
  
  =over 4
  
  =item *
  
  The command does not start.
  
  =item *
  
  The command is killed by a signal.
  
  =item *
  
  The command returns a non-zero exit value (but see below).
  
  =back
  
  On success, the autodying form of C<system> returns the I<exit value>
  rather than the contents of C<$?>.
  
  Additional allowable exit values can be supplied as an optional first
  argument to autodying C<system>:
  
      system( [ 0, 1, 2 ], $cmd, @args);  # 0,1,2 are good exit values
  
  C<autodie> uses the L<IPC::System::Simple> module to change C<system>.
  See its documentation for further information.
  
  Applying C<autodie> to C<system> or C<exec> causes the exotic
  forms C<system { $cmd } @args > or C<exec { $cmd } @args>
  to be considered a syntax error until the end of the lexical scope.
  If you really need to use the exotic form, you can call C<CORE::system>
  or C<CORE::exec> instead, or use C<no autodie qw(system exec)> before
  calling the exotic form.
  
  =head1 GOTCHAS
  
  Functions called in list context are assumed to have failed if they
  return an empty list, or a list consisting only of a single undef
  element.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item :void cannot be used with lexical scope
  
  The C<:void> option is supported in L<Fatal>, but not
  C<autodie>.  To workaround this, C<autodie> may be explicitly disabled until
  the end of the current block with C<no autodie>.
  To disable autodie for only a single function (eg, open)
  use C<no autodie qw(open)>.
  
  C<autodie> performs no checking of called context to determine whether to throw
  an exception; the explicitness of error handling with C<autodie> is a deliberate
  feature.
  
  =item No user hints defined for %s
  
  You've insisted on hints for user-subroutines, either by pre-pending
  a C<!> to the subroutine name itself, or earlier in the list of arguments
  to C<autodie>.  However the subroutine in question does not have
  any hints available.
  
  =back
  
  See also L<Fatal/DIAGNOSTICS>.
  
  =head1 BUGS
  
  "Used only once" warnings can be generated when C<autodie> or C<Fatal>
  is used with package filehandles (eg, C<FILE>).  Scalar filehandles are
  strongly recommended instead.
  
  When using C<autodie> or C<Fatal> with user subroutines, the
  declaration of those subroutines must appear before the first use of
  C<Fatal> or C<autodie>, or have been exported from a module.
  Attempting to use C<Fatal> or C<autodie> on other user subroutines will
  result in a compile-time error.
  
  Due to a bug in Perl, C<autodie> may "lose" any format which has the
  same name as an autodying built-in or function.
  
  C<autodie> may not work correctly if used inside a file with a
  name that looks like a string eval, such as F<eval (3)>.
  
  =head2 autodie and string eval
  
  Due to the current implementation of C<autodie>, unexpected results
  may be seen when used near or with the string version of eval.
  I<None of these bugs exist when using block eval>.
  
  Under Perl 5.8 only, C<autodie> I<does not> propagate into string C<eval>
  statements, although it can be explicitly enabled inside a string
  C<eval>.
  
  Under Perl 5.10 only, using a string eval when C<autodie> is in
  effect can cause the autodie behaviour to leak into the surrounding
  scope.  This can be worked around by using a C<no autodie> at the
  end of the scope to explicitly remove autodie's effects, or by
  avoiding the use of string eval.
  
  I<None of these bugs exist when using block eval>.  The use of
  C<autodie> with block eval is considered good practice.
  
  =head2 REPORTING BUGS
  
  Please report bugs via the CPAN Request Tracker at
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie>.
  
  =head1 FEEDBACK
  
  If you find this module useful, please consider rating it on the
  CPAN Ratings service at
  L<http://cpanratings.perl.org/rate?distribution=autodie> .
  
  The module author loves to hear how C<autodie> has made your life
  better (or worse).  Feedback can be sent to
  E<lt>pjf@perltraining.com.auE<gt>.
  
  =head1 AUTHOR
  
  Copyright 2008-2009, Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Fatal>, L<autodie::exception>, L<autodie::hints>, L<IPC::System::Simple>
  
  I<Perl tips, autodie> at
  L<http://perltraining.com.au/tips/2008-08-20.html>
  
  =head1 ACKNOWLEDGEMENTS
  
  Mark Reed and Roland Giersig -- Klingon translators.
  
  See the F<AUTHORS> file for full credits.  The latest version of this
  file can be found at
  L<https://github.com/pjf/autodie/tree/master/AUTHORS> .
  
  =cut
AUTODIE

$fatpacked{"autodie/exception.pm"} = <<'AUTODIE_EXCEPTION';
  package autodie::exception;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '2.20'; # VERSION: Generated by DZP::OurPkg:Version
  # ABSTRACT: Exceptions from autodying functions.
  
  our $DEBUG = 0;
  
  use overload
      q{""} => "stringify"
  ;
  
  # Overload smart-match only if we're using 5.10
  
  use if ($] >= 5.010), overload => '~~'  => "matches";
  
  my $PACKAGE = __PACKAGE__;  # Useful to have a scalar for hash keys.
  
  =head1 NAME
  
  autodie::exception - Exceptions from autodying functions.
  
  =head1 SYNOPSIS
  
      eval {
          use autodie;
  
          open(my $fh, '<', 'some_file.txt');
  
          ...
      };
  
      if (my $E = $@) {
          say "Ooops!  ",$E->caller," had problems: $@";
      }
  
  
  =head1 DESCRIPTION
  
  When an L<autodie> enabled function fails, it generates an
  C<autodie::exception> object.  This can be interrogated to
  determine further information about the error that occurred.
  
  This document is broken into two sections; those methods that
  are most useful to the end-developer, and those methods for
  anyone wishing to subclass or get very familiar with
  C<autodie::exception>.
  
  =head2 Common Methods
  
  These methods are intended to be used in the everyday dealing
  of exceptions.
  
  The following assume that the error has been copied into
  a separate scalar:
  
      if ($E = $@) {
          ...
      }
  
  This is not required, but is recommended in case any code
  is called which may reset or alter C<$@>.
  
  =cut
  
  =head3 args
  
      my $array_ref = $E->args;
  
  Provides a reference to the arguments passed to the subroutine
  that died.
  
  =cut
  
  sub args        { return $_[0]->{$PACKAGE}{args}; }
  
  =head3 function
  
      my $sub = $E->function;
  
  The subroutine (including package) that threw the exception.
  
  =cut
  
  sub function   { return $_[0]->{$PACKAGE}{function};  }
  
  =head3 file
  
      my $file = $E->file;
  
  The file in which the error occurred (eg, C<myscript.pl> or
  C<MyTest.pm>).
  
  =cut
  
  sub file        { return $_[0]->{$PACKAGE}{file};  }
  
  =head3 package
  
      my $package = $E->package;
  
  The package from which the exceptional subroutine was called.
  
  =cut
  
  sub package     { return $_[0]->{$PACKAGE}{package}; }
  
  =head3 caller
  
      my $caller = $E->caller;
  
  The subroutine that I<called> the exceptional code.
  
  =cut
  
  sub caller      { return $_[0]->{$PACKAGE}{caller};  }
  
  =head3 line
  
      my $line = $E->line;
  
  The line in C<< $E->file >> where the exceptional code was called.
  
  =cut
  
  sub line        { return $_[0]->{$PACKAGE}{line};  }
  
  =head3 context
  
      my $context = $E->context;
  
  The context in which the subroutine was called by autodie; usually
  the same as the context in which you called the autodying subroutine.
  This can be 'list', 'scalar', or undefined (unknown).  It will never
  be 'void', as C<autodie> always captures the return value in one way
  or another.
  
  For some core functions that always return a scalar value regardless
  of their context (eg, C<chown>), this may be 'scalar', even if you
  used a list context.
  
  =cut
  
  # TODO: The comments above say this can be undefined. Is that actually
  # the case? (With 'system', perhaps?)
  
  sub context     { return $_[0]->{$PACKAGE}{context} }
  
  =head3 return
  
      my $return_value = $E->return;
  
  The value(s) returned by the failed subroutine.  When the subroutine
  was called in a list context, this will always be a reference to an
  array containing the results.  When the subroutine was called in
  a scalar context, this will be the actual scalar returned.
  
  =cut
  
  sub return      { return $_[0]->{$PACKAGE}{return} }
  
  =head3 errno
  
      my $errno = $E->errno;
  
  The value of C<$!> at the time when the exception occurred.
  
  B<NOTE>: This method will leave the main C<autodie::exception> class
  and become part of a role in the future.  You should only call
  C<errno> for exceptions where C<$!> would reasonably have been
  set on failure.
  
  =cut
  
  # TODO: Make errno part of a role.  It doesn't make sense for
  # everything.
  
  sub errno       { return $_[0]->{$PACKAGE}{errno}; }
  
  =head3 eval_error
  
      my $old_eval_error = $E->eval_error;
  
  The contents of C<$@> immediately after autodie triggered an
  exception.  This may be useful when dealing with modules such
  as L<Text::Balanced> that set (but do not throw) C<$@> on error.
  
  =cut
  
  sub eval_error { return $_[0]->{$PACKAGE}{eval_error}; }
  
  =head3 matches
  
      if ( $e->matches('open') ) { ... }
  
      if ( $e ~~ 'open' ) { ... }
  
  C<matches> is used to determine whether a
  given exception matches a particular role.  On Perl 5.10,
  using smart-match (C<~~>) with an C<autodie::exception> object
  will use C<matches> underneath.
  
  An exception is considered to match a string if:
  
  =over 4
  
  =item *
  
  For a string not starting with a colon, the string exactly matches the
  package and subroutine that threw the exception.  For example,
  C<MyModule::log>.  If the string does not contain a package name,
  C<CORE::> is assumed.
  
  =item *
  
  For a string that does start with a colon, if the subroutine
  throwing the exception I<does> that behaviour.  For example, the
  C<CORE::open> subroutine does C<:file>, C<:io> and C<:all>.
  
  See L<autodie/CATEGORIES> for further information.
  
  =back
  
  =cut
  
  {
      my (%cache);
  
      sub matches {
          my ($this, $that) = @_;
  
          # TODO - Handle references
          croak "UNIMPLEMENTED" if ref $that;
  
          my $sub = $this->function;
  
          if ($DEBUG) {
              my $sub2 = $this->function;
              warn "Smart-matching $that against $sub / $sub2\n";
          }
  
          # Direct subname match.
          return 1 if $that eq $sub;
          return 1 if $that !~ /:/ and "CORE::$that" eq $sub;
          return 0 if $that !~ /^:/;
  
          # Cached match / check tags.
          require Fatal;
  
          if (exists $cache{$sub}{$that}) {
              return $cache{$sub}{$that};
          }
  
          # This rather awful looking line checks to see if our sub is in the
          # list of expanded tags, caches it, and returns the result.
  
          return $cache{$sub}{$that} = grep { $_ eq $sub } @{ $this->_expand_tag($that) };
      }
  }
  
  # This exists primarily so that child classes can override or
  # augment it if they wish.
  
  sub _expand_tag {
      my ($this, @args) = @_;
  
      return Fatal->_expand_tag(@args);
  }
  
  =head2 Advanced methods
  
  The following methods, while usable from anywhere, are primarily
  intended for developers wishing to subclass C<autodie::exception>,
  write code that registers custom error messages, or otherwise
  work closely with the C<autodie::exception> model.
  
  =cut
  
  # The table below records customer formatters.
  # TODO - Should this be a package var instead?
  # TODO - Should these be in a completely different file, or
  #        perhaps loaded on demand?  Most formatters will never
  #        get used in most programs.
  
  my %formatter_of = (
      'CORE::close'   => \&_format_close,
      'CORE::open'    => \&_format_open,
      'CORE::dbmopen' => \&_format_dbmopen,
      'CORE::flock'   => \&_format_flock,
  );
  
  # TODO: Our tests only check LOCK_EX | LOCK_NB is properly
  # formatted.  Try other combinations and ensure they work
  # correctly.
  
  sub _format_flock {
      my ($this) = @_;
  
      require Fcntl;
  
      my $filehandle = $this->args->[0];
      my $raw_mode   = $this->args->[1];
  
      my $mode_type;
      my $lock_unlock;
  
      if ($raw_mode & Fcntl::LOCK_EX() ) {
          $lock_unlock = "lock";
          $mode_type = "for exclusive access";
      }
      elsif ($raw_mode & Fcntl::LOCK_SH() ) {
          $lock_unlock = "lock";
          $mode_type = "for shared access";
      }
      elsif ($raw_mode & Fcntl::LOCK_UN() ) {
          $lock_unlock = "unlock";
          $mode_type = "";
      }
      else {
          # I've got no idea what they're trying to do.
          $lock_unlock = "lock";
          $mode_type = "with mode $raw_mode";
      }
  
      my $cooked_filehandle;
  
      if ($filehandle and not ref $filehandle) {
  
          # A package filehandle with a name!
  
          $cooked_filehandle = " $filehandle";
      }
      else {
          # Otherwise we have a scalar filehandle.
  
          $cooked_filehandle = '';
  
      }
  
      local $! = $this->errno;
  
      return "Can't $lock_unlock filehandle$cooked_filehandle $mode_type: $!";
  
  }
  
  # Default formatter for CORE::dbmopen
  sub _format_dbmopen {
      my ($this) = @_;
      my @args   = @{$this->args};
  
      # TODO: Presently, $args flattens out the (usually empty) hash
      # which is passed as the first argument to dbmopen.  This is
      # a bug in our args handling code (taking a reference to it would
      # be better), but for the moment we'll just examine the end of
      # our arguments list for message formatting.
  
      my $mode = $args[-1];
      my $file = $args[-2];
  
      # If we have a mask, then display it in octal, not decimal.
      # We don't do this if it already looks octalish, or doesn't
      # look like a number.
  
      if ($mode =~ /^[^\D0]\d+$/) {
          $mode = sprintf("0%lo", $mode);
      };
  
      local $! = $this->errno;
  
      return "Can't dbmopen(%hash, '$file', $mode): '$!'";
  }
  
  # Default formatter for CORE::close
  
  sub _format_close {
      my ($this) = @_;
      my $close_arg = $this->args->[0];
  
      local $! = $this->errno;
  
      # If we've got an old-style filehandle, mention it.
      if ($close_arg and not ref $close_arg) {
          return "Can't close filehandle '$close_arg': '$!'";
      }
  
      # TODO - This will probably produce an ugly error.  Test and fix.
      return "Can't close($close_arg) filehandle: '$!'";
  
  }
  
  # Default formatter for CORE::open
  
  use constant _FORMAT_OPEN => "Can't open '%s' for %s: '%s'";
  
  sub _format_open_with_mode {
      my ($this, $mode, $file, $error) = @_;
  
      my $wordy_mode;
  
      if    ($mode eq '<')  { $wordy_mode = 'reading';   }
      elsif ($mode eq '>')  { $wordy_mode = 'writing';   }
      elsif ($mode eq '>>') { $wordy_mode = 'appending'; }
  
      return sprintf _FORMAT_OPEN, $file, $wordy_mode, $error if $wordy_mode;
  
      Carp::confess("Internal autodie::exception error: Don't know how to format mode '$mode'.");
  
  }
  
  sub _format_open {
      my ($this) = @_;
  
      my @open_args = @{$this->args};
  
      # Use the default formatter for single-arg and many-arg open
      if (@open_args <= 1 or @open_args >= 4) {
          return $this->format_default;
      }
  
      # For two arg open, we have to extract the mode
      if (@open_args == 2) {
          my ($fh, $file) = @open_args;
  
          if (ref($fh) eq "GLOB") {
              $fh = '$fh';
          }
  
          my ($mode) = $file =~ m{
              ^\s*                # Spaces before mode
              (
                  (?>             # Non-backtracking subexp.
                      <           # Reading
                      |>>?        # Writing/appending
                  )
              )
              [^&]                # Not an ampersand (which means a dup)
          }x;
  
          if (not $mode) {
              # Maybe it's a 2-arg open without any mode at all?
              # Detect the most simple case for this, where our
              # file consists only of word characters.
  
              if ( $file =~ m{^\s*\w+\s*$} ) {
                  $mode = '<'
              }
              else {
                  # Otherwise, we've got no idea what's going on.
                  # Use the default.
                  return $this->format_default;
              }
          }
  
          # Localising $! means perl makes it a pretty error for us.
          local $! = $this->errno;
  
          return $this->_format_open_with_mode($mode, $file, $!);
      }
  
      # Here we must be using three arg open.
  
      my $file = $open_args[2];
  
      local $! = $this->errno;
  
      my $mode = $open_args[1];
  
      local $@;
  
      my $msg = eval { $this->_format_open_with_mode($mode, $file, $!); };
  
      return $msg if $msg;
  
      # Default message (for pipes and odd things)
  
      return "Can't open '$file' with mode '$open_args[1]': '$!'";
  }
  
  =head3 register
  
      autodie::exception->register( 'CORE::open' => \&mysub );
  
  The C<register> method allows for the registration of a message
  handler for a given subroutine.  The full subroutine name including
  the package should be used.
  
  Registered message handlers will receive the C<autodie::exception>
  object as the first parameter.
  
  =cut
  
  sub register {
      my ($class, $symbol, $handler) = @_;
  
      croak "Incorrect call to autodie::register" if @_ != 3;
  
      $formatter_of{$symbol} = $handler;
  
  }
  
  =head3 add_file_and_line
  
      say "Problem occurred",$@->add_file_and_line;
  
  Returns the string C< at %s line %d>, where C<%s> is replaced with
  the filename, and C<%d> is replaced with the line number.
  
  Primarily intended for use by format handlers.
  
  =cut
  
  # Simply produces the file and line number; intended to be added
  # to the end of error messages.
  
  sub add_file_and_line {
      my ($this) = @_;
  
      return sprintf(" at %s line %d\n", $this->file, $this->line);
  }
  
  =head3 stringify
  
      say "The error was: ",$@->stringify;
  
  Formats the error as a human readable string.  Usually there's no
  reason to call this directly, as it is used automatically if an
  C<autodie::exception> object is ever used as a string.
  
  Child classes can override this method to change how they're
  stringified.
  
  =cut
  
  sub stringify {
      my ($this) = @_;
  
      my $call        =  $this->function;
  
      if ($DEBUG) {
          my $dying_pkg   = $this->package;
          my $sub   = $this->function;
          my $caller = $this->caller;
          warn "Stringifing exception for $dying_pkg :: $sub / $caller / $call\n";
      }
  
      # TODO - This isn't using inheritance.  Should it?
      if ( my $sub = $formatter_of{$call} ) {
          return $sub->($this) . $this->add_file_and_line;
      }
  
      return $this->format_default . $this->add_file_and_line;
  
  }
  
  =head3 format_default
  
      my $error_string = $E->format_default;
  
  This produces the default error string for the given exception,
  I<without using any registered message handlers>.  It is primarily
  intended to be called from a message handler when they have
  been passed an exception they don't want to format.
  
  Child classes can override this method to change how default
  messages are formatted.
  
  =cut
  
  # TODO: This produces ugly errors.  Is there any way we can
  # dig around to find the actual variable names?  I know perl 5.10
  # does some dark and terrible magicks to find them for undef warnings.
  
  sub format_default {
      my ($this) = @_;
  
      my $call        =  $this->function;
  
      local $! = $this->errno;
  
      # TODO: This is probably a good idea for CORE, is it
      # a good idea for other subs?
  
      # Trim package name off dying sub for error messages.
      $call =~ s/.*:://;
  
      # Walk through all our arguments, and...
      #
      #   * Replace undef with the word 'undef'
      #   * Replace globs with the string '$fh'
      #   * Quote all other args.
  
      my @args = @{ $this->args() };
  
      foreach my $arg (@args) {
         if    (not defined($arg))   { $arg = 'undef' }
         elsif (ref($arg) eq "GLOB") { $arg = '$fh'   }
         else                        { $arg = qq{'$arg'} }
      }
  
      # Format our beautiful error.
  
      return "Can't $call(".  join(q{, }, @args) . "): $!" ;
  
      # TODO - Handle user-defined errors from hash.
  
      # TODO - Handle default error messages.
  
  }
  
  =head3 new
  
      my $error = autodie::exception->new(
          args => \@_,
          function => "CORE::open",
          errno => $!,
          context => 'scalar',
          return => undef,
      );
  
  
  Creates a new C<autodie::exception> object.  Normally called
  directly from an autodying function.  The C<function> argument
  is required, its the function we were trying to call that
  generated the exception.  The C<args> parameter is optional.
  
  The C<errno> value is optional.  In versions of C<autodie::exception>
  1.99 and earlier the code would try to automatically use the
  current value of C<$!>, but this was unreliable and is no longer
  supported.
  
  Atrributes such as package, file, and caller are determined
  automatically, and cannot be specified.
  
  =cut
  
  sub new {
      my ($class, @args) = @_;
  
      my $this = {};
  
      bless($this,$class);
  
      # I'd love to use EVERY here, but it causes our code to die
      # because it wants to stringify our objects before they're
      # initialised, causing everything to explode.
  
      $this->_init(@args);
  
      return $this;
  }
  
  sub _init {
  
      my ($this, %args) = @_;
  
      # Capturing errno here is not necessarily reliable.
      my $original_errno = $!;
  
      our $init_called = 1;
  
      my $class = ref $this;
  
      # We're going to walk up our call stack, looking for the
      # first thing that doesn't look like our exception
      # code, autodie/Fatal, or some whacky eval.
  
      my ($package, $file, $line, $sub);
  
      my $depth = 0;
  
      while (1) {
          $depth++;
  
          ($package, $file, $line, $sub) = CORE::caller($depth);
  
          # Skip up the call stack until we find something outside
          # of the Fatal/autodie/eval space.
  
          next if $package->isa('Fatal');
          next if $package->isa($class);
          next if $package->isa(__PACKAGE__);
  
          # Anything with the 'autodie::skip' role wants us to skip it.
          # https://github.com/pjf/autodie/issues/15
  
          next if ($package->can('DOES') and $package->DOES('autodie::skip'));
  
          next if $file =~ /^\(eval\s\d+\)$/;
  
          last;
  
      }
  
      # We now have everything correct, *except* for our subroutine
      # name.  If it's __ANON__ or (eval), then we need to keep on
      # digging deeper into our stack to find the real name.  However we
      # don't update our other information, since that will be correct
      # for our current exception.
  
      my $first_guess_subroutine = $sub;
  
      while (defined $sub and $sub =~ /^\(eval\)$|::__ANON__$/) {
          $depth++;
  
          $sub = (CORE::caller($depth))[3];
      }
  
      # If we end up falling out the bottom of our stack, then our
      # __ANON__ guess is the best we can get.  This includes situations
      # where we were called from the top level of a program.
  
      if (not defined $sub) {
          $sub = $first_guess_subroutine;
      }
  
      $this->{$PACKAGE}{package} = $package;
      $this->{$PACKAGE}{file}    = $file;
      $this->{$PACKAGE}{line}    = $line;
      $this->{$PACKAGE}{caller}  = $sub;
      $this->{$PACKAGE}{package} = $package;
  
      $this->{$PACKAGE}{errno}   = $args{errno} || 0;
  
      $this->{$PACKAGE}{context} = $args{context};
      $this->{$PACKAGE}{return}  = $args{return};
      $this->{$PACKAGE}{eval_error}  = $args{eval_error};
  
      $this->{$PACKAGE}{args}    = $args{args} || [];
      $this->{$PACKAGE}{function}= $args{function} or
                croak("$class->new() called without function arg");
  
      return $this;
  
  }
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<autodie>, L<autodie::exception::system>
  
  =head1 LICENSE
  
  Copyright (C)2008 Paul Fenwick
  
  This is free software.  You may modify and/or redistribute this
  code under the same terms as Perl 5.10 itself, or, at your option,
  any later version of Perl 5.
  
  =head1 AUTHOR
  
  Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
AUTODIE_EXCEPTION

$fatpacked{"autodie/exception/system.pm"} = <<'AUTODIE_EXCEPTION_SYSTEM';
  package autodie::exception::system;
  use 5.008;
  use strict;
  use warnings;
  use base 'autodie::exception';
  use Carp qw(croak);
  
  our $VERSION = '2.20'; # VERSION: Generated by DZP::OurPkg:Version
  
  # ABSTRACT: Exceptions from autodying system().
  
  my $PACKAGE = __PACKAGE__;
  
  =head1 NAME
  
  autodie::exception::system - Exceptions from autodying system().
  
  =head1 SYNOPSIS
  
      eval {
          use autodie qw(system);
  
          system($cmd, @args);
  
      };
  
      if (my $E = $@) {
          say "Ooops!  ",$E->caller," had problems: $@";
      }
  
  
  =head1 DESCRIPTION
  
  This is a L<autodie::exception> class for failures from the
  C<system> command.
  
  Presently there is no way to interrogate an C<autodie::exception::system>
  object for the command, exit status, and other information you'd expect
  such an object to hold.  The interface will be expanded to accommodate
  this in the future.
  
  =cut
  
  sub _init {
      my ($this, %args) = @_;
  
      $this->{$PACKAGE}{message} = $args{message}
          || croak "'message' arg not supplied to autodie::exception::system->new";
  
      return $this->SUPER::_init(%args);
  
  }
  
  =head2 stringify
  
  When stringified, C<autodie::exception::system> objects currently
  use the message generated by L<IPC::System::Simple>.
  
  =cut
  
  sub stringify {
  
      my ($this) = @_;
  
      return $this->{$PACKAGE}{message} . $this->add_file_and_line;
  
  }
  
  1;
  
  __END__
  
  =head1 LICENSE
  
  Copyright (C)2008 Paul Fenwick
  
  This is free software.  You may modify and/or redistribute this
  code under the same terms as Perl 5.10 itself, or, at your option,
  any later version of Perl 5.
  
  =head1 AUTHOR
  
  Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
AUTODIE_EXCEPTION_SYSTEM

$fatpacked{"autodie/hints.pm"} = <<'AUTODIE_HINTS';
  package autodie::hints;
  
  use strict;
  use warnings;
  
  use constant PERL58 => ( $] < 5.009 );
  
  our $VERSION = '2.20'; # VERSION: Generated by DZP::OurPkg:Version
  
  # ABSTRACT: Provide hints about user subroutines to autodie
  
  =head1 NAME
  
  autodie::hints - Provide hints about user subroutines to autodie
  
  =head1 SYNOPSIS
  
      package Your::Module;
  
      our %DOES = ( 'autodie::hints::provider' => 1 );
  
      sub AUTODIE_HINTS {
          return {
              foo => { scalar => HINTS, list => SOME_HINTS },
              bar => { scalar => HINTS, list => MORE_HINTS },
          }
      }
  
      # Later, in your main program...
  
      use Your::Module qw(foo bar);
      use autodie      qw(:default foo bar);
  
      foo();         # succeeds or dies based on scalar hints
  
      # Alternatively, hints can be set on subroutines we've
      # imported.
  
      use autodie::hints;
      use Some::Module qw(think_positive);
  
      BEGIN {
          autodie::hints->set_hints_for(
              \&think_positive,
              {
                  fail => sub { $_[0] <= 0 }
              }
          )
      }
      use autodie qw(think_positive);
  
      think_positive(...);    # Returns positive or dies.
  
  
  =head1 DESCRIPTION
  
  =head2 Introduction
  
  The L<autodie> pragma is very smart when it comes to working with
  Perl's built-in functions.  The behaviour for these functions are
  fixed, and C<autodie> knows exactly how they try to signal failure.
  
  But what about user-defined subroutines from modules?  If you use
  C<autodie> on a user-defined subroutine then it assumes the following
  behaviour to demonstrate failure:
  
  =over
  
  =item *
  
  A false value, in scalar context
  
  =item * 
  
  An empty list, in list context
  
  =item *
  
  A list containing a single undef, in list context
  
  =back
  
  All other return values (including the list of the single zero, and the
  list containing a single empty string) are considered successful.  However,
  real-world code isn't always that easy.  Perhaps the code you're working
  with returns a string containing the word "FAIL" upon failure, or a
  two element list containing C<(undef, "human error message")>.  To make
  autodie work with these sorts of subroutines, we have
  the I<hinting interface>.
  
  The hinting interface allows I<hints> to be provided to C<autodie>
  on how it should detect failure from user-defined subroutines.  While
  these I<can> be provided by the end-user of C<autodie>, they are ideally
  written into the module itself, or into a helper module or sub-class
  of C<autodie> itself.
  
  =head2 What are hints?
  
  A I<hint> is a subroutine or value that is checked against the
  return value of an autodying subroutine.  If the match returns true,
  C<autodie> considers the subroutine to have failed.
  
  If the hint provided is a subroutine, then C<autodie> will pass
  the complete return value to that subroutine.  If the hint is
  any other value, then C<autodie> will smart-match against the
  value provided.  In Perl 5.8.x there is no smart-match operator, and as such
  only subroutine hints are supported in these versions.
  
  Hints can be provided for both scalar and list contexts.  Note
  that an autodying subroutine will never see a void context, as
  C<autodie> always needs to capture the return value for examination.
  Autodying subroutines called in void context act as if they're called
  in a scalar context, but their return value is discarded after it
  has been checked.
  
  =head2 Example hints
  
  Hints may consist of scalars, array references, regular expressions and
  subroutine references.  You can specify different hints for how
  failure should be identified in scalar and list contexts.
  
  These examples apply for use in the C<AUTODIE_HINTS> subroutine and when
  calling C<autodie::hints->set_hints_for()>.
  
  The most common context-specific hints are:
  
          # Scalar failures always return undef:
              {  scalar => undef  }
  
          # Scalar failures return any false value [default expectation]:
              {  scalar => sub { ! $_[0] }  }
  
          # Scalar failures always return zero explicitly:
              {  scalar => '0'  }
  
          # List failures always return an empty list:
              {  list => []  }
  
          # List failures return () or (undef) [default expectation]:
              {  list => sub { ! @_ || @_ == 1 && !defined $_[0] }  }
  
          # List failures return () or a single false value:
              {  list => sub { ! @_ || @_ == 1 && !$_[0] }  }
  
          # List failures return (undef, "some string")
              {  list => sub { @_ == 2 && !defined $_[0] }  }
  
          # Unsuccessful foo() returns 'FAIL' or '_FAIL' in scalar context,
          #                    returns (-1) in list context...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  scalar => qr/^ _? FAIL $/xms,
                  list   => [-1],
              }
          );
  
          # Unsuccessful foo() returns 0 in all contexts...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  scalar => 0,
                  list   => [0],
              }
          );
  
  This "in all contexts" construction is very common, and can be
  abbreviated, using the 'fail' key.  This sets both the C<scalar>
  and C<list> hints to the same value:
  
          # Unsuccessful foo() returns 0 in all contexts...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  fail => sub { @_ == 1 and defined $_[0] and $_[0] == 0 }
              }
  	);
  
          # Unsuccessful think_positive() returns negative number on failure...
          autodie::hints->set_hints_for(
              \&think_positive,
              {
                  fail => sub { $_[0] < 0 }
              }
  	);
  
          # Unsuccessful my_system() returns non-zero on failure...
          autodie::hints->set_hints_for(
              \&my_system,
              {
                  fail => sub { $_[0] != 0 }
              }
  	);
  
  =head1 Manually setting hints from within your program
  
  If you are using a module which returns something special on failure, then
  you can manually create hints for each of the desired subroutines.  Once
  the hints are specified, they are available for all files and modules loaded
  thereafter, thus you can move this work into a module and it will still
  work.
  
  	use Some::Module qw(foo bar);
  	use autodie::hints;
  
  	autodie::hints->set_hints_for(
  		\&foo,
  		{
  			scalar => SCALAR_HINT,
  			list   => LIST_HINT,
  		}
  	);
  	autodie::hints->set_hints_for(
  		\&bar,
                  { fail => SOME_HINT, }
  	);
  
  It is possible to pass either a subroutine reference (recommended) or a fully
  qualified subroutine name as the first argument.  This means you can set hints
  on modules that I<might> get loaded:
  
  	use autodie::hints;
  	autodie::hints->set_hints_for(
  		'Some::Module:bar', { fail => SCALAR_HINT, }
  	);
  
  This technique is most useful when you have a project that uses a
  lot of third-party modules.  You can define all your possible hints
  in one-place.  This can even be in a sub-class of autodie.  For
  example:
  
          package my::autodie;
  
          use parent qw(autodie);
          use autodie::hints;
  
          autodie::hints->set_hints_for(...);
  
          1;
  
  You can now C<use my::autodie>, which will work just like the standard
  C<autodie>, but is now aware of any hints that you've set.
  
  =head1 Adding hints to your module
  
  C<autodie> provides a passive interface to allow you to declare hints for
  your module.  These hints will be found and used by C<autodie> if it
  is loaded, but otherwise have no effect (or dependencies) without autodie.
  To set these, your module needs to declare that it I<does> the
  C<autodie::hints::provider> role.  This can be done by writing your
  own C<DOES> method, using a system such as C<Class::DOES> to handle
  the heavy-lifting for you, or declaring a C<%DOES> package variable
  with a C<autodie::hints::provider> key and a corresponding true value.
  
  Note that checking for a C<%DOES> hash is an C<autodie>-only
  short-cut.  Other modules do not use this mechanism for checking
  roles, although you can use the C<Class::DOES> module from the
  CPAN to allow it.
  
  In addition, you must define a C<AUTODIE_HINTS> subroutine that returns
  a hash-reference containing the hints for your subroutines:
  
          package Your::Module;
  
          # We can use the Class::DOES from the CPAN to declare adherence
          # to a role.
  
          use Class::DOES 'autodie::hints::provider' => 1;
  
          # Alternatively, we can declare the role in %DOES.  Note that
          # this is an autodie specific optimisation, although Class::DOES
          # can be used to promote this to a true role declaration.
  
          our %DOES = ( 'autodie::hints::provider' => 1 );
  
          # Finally, we must define the hints themselves.
  
  	sub AUTODIE_HINTS {
  	    return {
  	        foo => { scalar => HINTS, list => SOME_HINTS },
  	        bar => { scalar => HINTS, list => MORE_HINTS },
  	        baz => { fail => HINTS },
  	    }
  	}
  
  This allows your code to set hints without relying on C<autodie> and
  C<autodie::hints> being loaded, or even installed.  In this way your
  code can do the right thing when C<autodie> is installed, but does not
  need to depend upon it to function.
  
  =head1 Insisting on hints
  
  When a user-defined subroutine is wrapped by C<autodie>, it will
  use hints if they are available, and otherwise reverts to the
  I<default behaviour> described in the introduction of this document.
  This can be problematic if we expect a hint to exist, but (for
  whatever reason) it has not been loaded.
  
  We can ask autodie to I<insist> that a hint be used by prefixing
  an exclamation mark to the start of the subroutine name.  A lone
  exclamation mark indicates that I<all> subroutines after it must
  have hints declared.
  
  	# foo() and bar() must have their hints defined
  	use autodie qw( !foo !bar baz );
  
  	# Everything must have hints (recommended).
  	use autodie qw( ! foo bar baz );
  
  	# bar() and baz() must have their hints defined
  	use autodie qw( foo ! bar baz );
  
          # Enable autodie for all of Perl's supported built-ins,
          # as well as for foo(), bar() and baz().  Everything must
          # have hints.
          use autodie qw( ! :all foo bar baz );
  
  If hints are not available for the specified subroutines, this will cause a
  compile-time error.  Insisting on hints for Perl's built-in functions
  (eg, C<open> and C<close>) is always successful.
  
  Insisting on hints is I<strongly> recommended.
  
  =cut
  
  # TODO: implement regular expression hints
  
  use constant UNDEF_ONLY       => sub { not defined $_[0] };
  use constant EMPTY_OR_UNDEF   => sub {
      ! @_ or
      @_==1 && !defined $_[0]
  };
  
  use constant EMPTY_ONLY     => sub { @_ == 0 };
  use constant EMPTY_OR_FALSE => sub {
      ! @_ or
      @_==1 && !$_[0]
  };
  
  use constant SINGLE_TRUE => sub { @_ == 1 and not $_[0] };
  
  use constant DEFAULT_HINTS => {
      scalar => UNDEF_ONLY,
      list   => EMPTY_OR_UNDEF,
  };
  
  
  use constant HINTS_PROVIDER => 'autodie::hints::provider';
  
  use base qw(Exporter);
  
  our $DEBUG = 0;
  
  # Only ( undef ) is a strange but possible situation for very
  # badly written code.  It's not supported yet.
  
  my %Hints = (
      'File::Copy::copy' => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::move' => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::cp'   => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::mv'   => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
  );
  
  # Start by using Sub::Identify if it exists on this system.
  
  eval { require Sub::Identify; Sub::Identify->import('get_code_info'); };
  
  # If it doesn't exist, we'll define our own.  This code is directly
  # taken from Rafael Garcia's Sub::Identify 0.04, used under the same
  # license as Perl itself.
  
  if ($@) {
      require B;
  
      no warnings 'once';
  
      *get_code_info = sub ($) {
  
          my ($coderef) = @_;
          ref $coderef or return;
          my $cv = B::svref_2object($coderef);
          $cv->isa('B::CV') or return;
          # bail out if GV is undefined
          $cv->GV->isa('B::SPECIAL') and return;
  
          return ($cv->GV->STASH->NAME, $cv->GV->NAME);
      };
  
  }
  
  sub sub_fullname {
      return join( '::', get_code_info( $_[1] ) );
  }
  
  my %Hints_loaded = ();
  
  sub load_hints {
      my ($class, $sub) = @_;
  
      my ($package) = ( $sub =~ /(.*)::/ );
  
      if (not defined $package) {
          require Carp;
          Carp::croak(
              "Internal error in autodie::hints::load_hints - no package found.
          ");
      }
  
      # Do nothing if we've already tried to load hints for
      # this package.
      return if $Hints_loaded{$package}++;
  
      my $hints_available = 0;
  
      {
          no strict 'refs';   ## no critic
  
          if ($package->can('DOES') and $package->DOES(HINTS_PROVIDER) ) {
              $hints_available = 1;
          }
          elsif ( PERL58 and $package->isa(HINTS_PROVIDER) ) {
              $hints_available = 1;
          }
          elsif ( ${"${package}::DOES"}{HINTS_PROVIDER.""} ) {
              $hints_available = 1;
          }
      }
  
      return if not $hints_available;
  
      my %package_hints = %{ $package->AUTODIE_HINTS };
  
      foreach my $sub (keys %package_hints) {
  
          my $hint = $package_hints{$sub};
  
          # Ensure we have a package name.
          $sub = "${package}::$sub" if $sub !~ /::/;
  
          # TODO - Currently we don't check for conflicts, should we?
          $Hints{$sub} = $hint;
  
          $class->normalise_hints(\%Hints, $sub);
      }
  
      return;
  
  }
  
  sub normalise_hints {
      my ($class, $hints, $sub) = @_;
  
      if ( exists $hints->{$sub}->{fail} ) {
  
          if ( exists $hints->{$sub}->{scalar} or
               exists $hints->{$sub}->{list}
          ) {
              # TODO: Turn into a proper diagnostic.
              require Carp;
              local $Carp::CarpLevel = 1;
              Carp::croak("fail hints cannot be provided with either scalar or list hints for $sub");
          }
  
          # Set our scalar and list hints.
  
          $hints->{$sub}->{scalar} = 
          $hints->{$sub}->{list} = delete $hints->{$sub}->{fail};
  
          return;
  
      }
  
      # Check to make sure all our hints exist.
  
      foreach my $hint (qw(scalar list)) {
          if ( not exists $hints->{$sub}->{$hint} ) {
              # TODO: Turn into a proper diagnostic.
              require Carp;
              local $Carp::CarpLevel = 1;
              Carp::croak("$hint hint missing for $sub");
          }
      }
  
      return;
  }
  
  sub get_hints_for {
      my ($class, $sub) = @_;
  
      my $subname = $class->sub_fullname( $sub );
  
      # If we have hints loaded for a sub, then return them.
  
      if ( exists $Hints{ $subname } ) {
          return $Hints{ $subname };
      }
  
      # If not, we try to load them...
  
      $class->load_hints( $subname );
  
      # ...and try again!
  
      if ( exists $Hints{ $subname } ) {
          return $Hints{ $subname };
      }
  
      # It's the caller's responsibility to use defaults if desired.
      # This allows on autodie to insist on hints if needed.
  
      return;
  
  }
  
  sub set_hints_for {
      my ($class, $sub, $hints) = @_;
  
      if (ref $sub) {
          $sub = $class->sub_fullname( $sub );
  
          require Carp;
  
          $sub or Carp::croak("Attempts to set_hints_for unidentifiable subroutine");
      }
  
      if ($DEBUG) {
          warn "autodie::hints: Setting $sub to hints: $hints\n";
      }
  
      $Hints{ $sub } = $hints;
  
      $class->normalise_hints(\%Hints, $sub);
  
      return;
  }
  
  1;
  
  __END__
  
  
  =head1 Diagnostics
  
  =over 4
  
  =item Attempts to set_hints_for unidentifiable subroutine
  
  You've called C<< autodie::hints->set_hints_for() >> using a subroutine
  reference, but that reference could not be resolved back to a
  subroutine name.  It may be an anonymous subroutine (which can't
  be made autodying), or may lack a name for other reasons.
  
  If you receive this error with a subroutine that has a real name,
  then you may have found a bug in autodie.  See L<autodie/BUGS>
  for how to report this.
  
  =item fail hints cannot be provided with either scalar or list hints for %s
  
  When defining hints, you can either supply both C<list> and
  C<scalar> keywords, I<or> you can provide a single C<fail> keyword.
  You can't mix and match them.
  
  =item %s hint missing for %s
  
  You've provided either a C<scalar> hint without supplying
  a C<list> hint, or vice-versa.  You I<must> supply both C<scalar>
  and C<list> hints, I<or> a single C<fail> hint.
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 
  
  =item *
  
  Dr Damian Conway for suggesting the hinting interface and providing the
  example usage.
  
  =item *
  
  Jacinta Richardson for translating much of my ideas into this
  documentation.
  
  =back
  
  =head1 AUTHOR
  
  Copyright 2009, Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie>, L<Class::DOES>
  
  =for Pod::Coverage get_hints_for load_hints normalise_hints sub_fullname
  
  =cut
AUTODIE_HINTS

$fatpacked{"autodie/skip.pm"} = <<'AUTODIE_SKIP';
  package autodie::skip;
  use strict;
  use warnings;
  
  our $VERSION = '2.20'; # VERSION
  
  # This package exists purely so people can inherit from it,
  # which isn't at all how roles are supposed to work, but it's
  # how people will use them anyway.
  
  if ($] < 5.010) {
      # Older Perls don't have a native ->DOES.  Let's provide a cheap
      # imitation here.
  
      *DOES = sub { return shift->isa(@_); };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie::skip - Skip a package when throwing autodie exceptions
  
  =head1 SYNPOSIS
  
      use parent qw(autodie::skip);
  
  =head1 DESCRIPTION
  
  This dummy class exists to signal that the class inheriting it should
  be skipped when reporting exceptions from autodie.  This is useful
  for utility classes like L<Path::Tiny> that wish to report the location
  of where they were called on failure.
  
  If your class has a better way of doing roles, then you should not
  load this class and instead simply say that your class I<DOES>
  C<autodie::skip> instead.
  
  =head1 AUTHOR
  
  Copyright 2013, Paul Fenwick <pjf@cpan.org>
  
  =head1 LICENSE
  
  This module is free software. You may distribute it under the same
  terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie>, L<autodie::exception>
  
  =cut
AUTODIE_SKIP

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    if ($] < 5.008) {
      return sub {
        return 0 unless length $fat;
        $fat =~ s/^([^\n]*\n?)//;
        $_ = $1;
        return 1;
      };
    }
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE


use strict;
use warnings;
use 5.014;
use YAML;
use Data::Printer;
use File::chdir;
use Path::Tiny;

sub initialize {
	my ($conf) = @_;
	die("you need to remove .vim to proceed.") unless ! path("~/.vim")->is_dir;
	foreach (@{$conf->{script}}) {
		say "running: $_";
		`$_`;
	}
	local $CWD = $ENV{HOME}.'/.vim/bundle';
	foreach (@{$conf->{plugins}}) {
		`git clone -q $_`;
	}
	path("~/.vimrc")->spew_raw($conf->{config});
}

###############################################################################
# YAML Configuration
###############################################################################
my $vim_conf = YAML::Load << '...';
---
name: vim
description: VIM Text Editor and plugins
config: |
  execute pathogen#infect()
  syntax on
  filetype plugin indent on
  
  set background=dark
  colorscheme jellybeans
  set textwidth=79
  set formatoptions=qrn1
  if exists('+colorcolumn')
    set colorcolumn=80
  endif
  set list
  set listchars=tab:.\ ,trail:.,extends:#,nbsp:.
  if has("gui_running")
    set guifont=Ubuntu\ Mono\ 13
    set list
    set listchars=tab:\ ,eol:,extends:#,nbsp:.,trail:.
    set guioptions-=r
    set go-=L
    set go-=T
  endif
  
  set numberwidth=5
  set cursorline
  set cursorcolumn
  set guicursor+=a:blinkon0
  nmap <c-up> ddkP
  nmap <c-down> dd
  nmap + <c-w>+
  nmap _ <c-w>-
  nmap > <c-w>>
  nmap < <c-w><
  vmap <c-up> xkP`[V`]
  vmap <c-down> xp`[V`]
  
  au BufEnter * silent! lcd %:p:h " auto change directory of current file
  au WinLeave * set nocursorline nocursorcolumn
  au WinEnter * set cursorline cursorcolumn
  set cursorline cursorcolumn
  if ! has('gui_running')
      set ttimeoutlen=10
      augroup FastEscape
  	autocmd!
  	au InsertEnter * set timeoutlen=0
  	au InsertLeave * set timeoutlen=1000
      augroup END
  endif
  autocmd GUIEnter * set vb t_vb= " for your GUI
  autocmd VimEnter * set vb t_vb=
packages:
  - vim
  - vim-gtk
plugins:
  - git://github.com/antono/html.vim
  - git://github.com/juvenn/mustache.vim
  - git://github.com/kien/ctrlp.vim
  - git://github.com/klen/python-mode
  - git://github.com/nanotech/jellybeans.vim
  - git://github.com/othree/html5.vim
  - git://github.com/pangloss/vim-javascript
  - git://github.com/rodjek/vim-puppet
  - git://github.com/sickill/vim-pasta
  - git://github.com/tpope/vim-bundler
  - git://github.com/tpope/vim-endwise
  - git://github.com/tpope/vim-eunuch
  - git://github.com/tpope/vim-fugitive
  - git://github.com/tpope/vim-haml
  - git://github.com/tpope/vim-markdown
  - git://github.com/tpope/vim-rails
  - git://github.com/tpope/vim-scriptease
  - git://github.com/tpope/vim-sensible
  - git://github.com/tpope/vim-surround
  - git://github.com/tpope/vim-unimpaired
  - git://github.com/vim-perl/vim-perl
  - git://github.com/vim-ruby/vim-ruby
  - git://github.com/vim-scripts/taglist.vim
  - git://github.com/vimoutliner/vimoutliner
  - git://github.com/bling/vim-airline
  - git://github.com/Yggdroot/indentLine
script:
  - mkdir -p ~/.vim/autoload ~/.vim/bundle
  - curl -Sso ~/.vim/autoload/pathogen.vim https://raw.github.com/tpope/vim-pathogen/master/autoload/pathogen.vim
  - sudo apt-add-repository -y ppa:nmi/vim-snapshots
  - sudo apt-get update
  - sudo apt-get -y install vim vim-gtk ctags vim-doc vim-scripts cscope ttf-dejavu indent
...

###############################################################################
# start this up
###############################################################################
initialize($vim_conf);

__END__

No futher.
