#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Fatal.pm"} = <<'FATAL';
  package Fatal;
  
  # ABSTRACT: Replace functions with equivalents which succeed or die
  
  use 5.008;  # 5.8.x needed for autodie
  use Carp;
  use strict;
  use warnings;
  use Tie::RefHash;   # To cache subroutine refs
  use Config;
  use Scalar::Util qw(set_prototype);
  
  use constant PERL510     => ( $] >= 5.010 );
  
  use constant LEXICAL_TAG => q{:lexical};
  use constant VOID_TAG    => q{:void};
  use constant INSIST_TAG  => q{!};
  
  use constant ERROR_NOARGS    => 'Cannot use lexical %s with no arguments';
  use constant ERROR_VOID_LEX  => VOID_TAG.' cannot be used with lexical scope';
  use constant ERROR_LEX_FIRST => LEXICAL_TAG.' must be used as first argument';
  use constant ERROR_NO_LEX    => "no %s can only start with ".LEXICAL_TAG;
  use constant ERROR_BADNAME   => "Bad subroutine name for %s: %s";
  use constant ERROR_NOTSUB    => "%s is not a Perl subroutine";
  use constant ERROR_NOT_BUILT => "%s is neither a builtin, nor a Perl subroutine";
  use constant ERROR_NOHINTS   => "No user hints defined for %s";
  
  use constant ERROR_CANT_OVERRIDE => "Cannot make the non-overridable builtin %s fatal";
  
  use constant ERROR_NO_IPC_SYS_SIMPLE => "IPC::System::Simple required for Fatalised/autodying system()";
  
  use constant ERROR_IPC_SYS_SIMPLE_OLD => "IPC::System::Simple version %f required for Fatalised/autodying system().  We only have version %f";
  
  use constant ERROR_AUTODIE_CONFLICT => q{"no autodie '%s'" is not allowed while "use Fatal '%s'" is in effect};
  
  use constant ERROR_FATAL_CONFLICT => q{"use Fatal '%s'" is not allowed while "no autodie '%s'" is in effect};
  
  use constant ERROR_58_HINTS => q{Non-subroutine %s hints for %s are not supported under Perl 5.8.x};
  
  # Older versions of IPC::System::Simple don't support all the
  # features we need.
  
  use constant MIN_IPC_SYS_SIMPLE_VER => 0.12;
  
  our $VERSION = '2.20'; # VERSION: Generated by DZP::OurPkg::Version
  
  our $Debug ||= 0;
  
  # EWOULDBLOCK values for systems that don't supply their own.
  # Even though this is defined with our, that's to help our
  # test code.  Please don't rely upon this variable existing in
  # the future.
  
  our %_EWOULDBLOCK = (
      MSWin32 => 33,
  );
  
  # the linux parisc port has separate EAGAIN and EWOULDBLOCK,
  # and the kernel returns EAGAIN
  my $try_EAGAIN = ($^O eq 'linux' and $Config{archname} =~ /hppa|parisc/) ? 1 : 0;
  
  # We have some tags that can be passed in for use with import.
  # These are all assumed to be CORE::
  
  my %TAGS = (
      ':io'      => [qw(:dbm :file :filesys :ipc :socket
                         read seek sysread syswrite sysseek )],
      ':dbm'     => [qw(dbmopen dbmclose)],
      ':file'    => [qw(open close flock sysopen fcntl fileno binmode
                       ioctl truncate)],
      ':filesys' => [qw(opendir closedir chdir link unlink rename mkdir
                        symlink rmdir readlink umask chmod chown utime)],
      ':ipc'     => [qw(:msg :semaphore :shm pipe kill)],
      ':msg'     => [qw(msgctl msgget msgrcv msgsnd)],
      ':threads' => [qw(fork)],
      ':semaphore'=>[qw(semctl semget semop)],
      ':shm'     => [qw(shmctl shmget shmread)],
      ':system'  => [qw(system exec)],
  
      # Can we use qw(getpeername getsockname)? What do they do on failure?
      # TODO - Can socket return false?
      ':socket'  => [qw(accept bind connect getsockopt listen recv send
                     setsockopt shutdown socketpair)],
  
      # Our defaults don't include system(), because it depends upon
      # an optional module, and it breaks the exotic form.
      #
      # This *may* change in the future.  I'd love IPC::System::Simple
      # to be a dependency rather than a recommendation, and hence for
      # system() to be autodying by default.
  
      ':default' => [qw(:io :threads)],
  
      # Everything in v2.07 and brefore. This was :default less chmod and chown
      ':v207'    => [qw(:threads :dbm :socket read seek sysread
                     syswrite sysseek open close flock sysopen fcntl fileno
                     binmode ioctl truncate opendir closedir chdir link unlink
                     rename mkdir symlink rmdir readlink umask
                     :msg :semaphore :shm pipe)],
  
      # Chmod was added in 2.13
      ':v213'    => [qw(:v207 chmod)],
  
      # chown, utime, kill were added in 2.14
      ':v214'    => [qw(:v213 chown utime kill)],
  
      # Version specific tags.  These allow someone to specify
      # use autodie qw(:1.994) and know exactly what they'll get.
  
      ':1.994' => [qw(:v207)],
      ':1.995' => [qw(:v207)],
      ':1.996' => [qw(:v207)],
      ':1.997' => [qw(:v207)],
      ':1.998' => [qw(:v207)],
      ':1.999' => [qw(:v207)],
      ':1.999_01' => [qw(:v207)],
      ':2.00'  => [qw(:v207)],
      ':2.01'  => [qw(:v207)],
      ':2.02'  => [qw(:v207)],
      ':2.03'  => [qw(:v207)],
      ':2.04'  => [qw(:v207)],
      ':2.05'  => [qw(:v207)],
      ':2.06'  => [qw(:v207)],
      ':2.06_01' => [qw(:v207)],
      ':2.07'  => [qw(:v207)],     # Last release without chmod
      ':2.08'  => [qw(:v213)],
      ':2.09'  => [qw(:v213)],
      ':2.10'  => [qw(:v213)],
      ':2.11'  => [qw(:v213)],
      ':2.12'  => [qw(:v213)],
      ':2.13'  => [qw(:v213)],
      ':2.14'  => [qw(:default)],
      ':2.15'  => [qw(:default)],
      ':2.16'  => [qw(:default)],
      ':2.17'  => [qw(:default)],
      ':2.18'  => [qw(:default)],
      ':2.19'  => [qw(:default)],
      ':2.20'  => [qw(:default)],
  );
  
  # chmod was only introduced in 2.07
  # chown was only introduced in 2.14
  
  $TAGS{':all'}  = [ keys %TAGS ];
  
  # This hash contains subroutines for which we should
  # subroutine() // die() rather than subroutine() || die()
  
  my %Use_defined_or;
  
  # CORE::open returns undef on failure.  It can legitimately return
  # 0 on success, eg: open(my $fh, '-|') || exec(...);
  
  @Use_defined_or{qw(
      CORE::fork
      CORE::recv
      CORE::send
      CORE::open
      CORE::fileno
      CORE::read
      CORE::readlink
      CORE::sysread
      CORE::syswrite
      CORE::sysseek
      CORE::umask
  )} = ();
  
  # Some functions can return true because they changed *some* things, but
  # not all of them.  This is a list of offending functions, and how many
  # items to subtract from @_ to determine the "success" value they return.
  
  my %Returns_num_things_changed = (
      'CORE::chmod'  => 1,
      'CORE::chown'  => 2,
      'CORE::kill'   => 1,  # TODO: Could this return anything on negative args?
      'CORE::unlink' => 0,
      'CORE::utime'  => 2,
  );
  
  # Optional actions to take on the return value before returning it.
  
  my %Retval_action = (
      "CORE::open"        => q{
  
      # apply the open pragma from our caller
      if( defined $retval ) {
          # Get the caller's hint hash
          my $hints = (caller 0)[10];
  
          # Decide if we're reading or writing and apply the appropriate encoding
          # These keys are undocumented.
          # Match what PerlIO_context_layers() does.  Read gets the read layer,
          # everything else gets the write layer.
          my $encoding = $_[1] =~ /^\+?>/ ? $hints->{"open>"} : $hints->{"open<"};
  
          # Apply the encoding, if any.
          if( $encoding ) {
              binmode $_[0], $encoding;
          }
      }
  
  },
      "CORE::sysopen"     => q{
  
      # apply the open pragma from our caller
      if( defined $retval ) {
          # Get the caller's hint hash
          my $hints = (caller 0)[10];
  
          require Fcntl;
  
          # Decide if we're reading or writing and apply the appropriate encoding.
          # Match what PerlIO_context_layers() does.  Read gets the read layer,
          # everything else gets the write layer.
          my $open_read_only = !($_[2] ^ Fcntl::O_RDONLY());
          my $encoding = $open_read_only ? $hints->{"open<"} : $hints->{"open>"};
  
          # Apply the encoding, if any.
          if( $encoding ) {
              binmode $_[0], $encoding;
          }
      }
  
  },
  );
  
  my %reusable_builtins;
  
  # "Wait!" I hear you cry, "truncate() and chdir() are not reuseable! They can
  # take file and directory handles, which are package depedent."
  #
  # You would be correct, except that prototype() returns signatures which don't
  # allow for passing of globs, and nobody's complained about that. You can
  # still use \*FILEHANDLE, but that results in a reference coming through,
  # and it's already pointing to the filehandle in the caller's packge, so
  # it's all okay.
  
  @reusable_builtins{qw(
      CORE::fork
      CORE::kill
      CORE::truncate
      CORE::chdir
      CORE::link
      CORE::unlink
      CORE::rename
      CORE::mkdir
      CORE::symlink
      CORE::rmdir
      CORE::readlink
      CORE::umask
      CORE::chmod
      CORE::chown
      CORE::utime
      CORE::msgctl
      CORE::msgget
      CORE::msgrcv
      CORE::msgsnd
      CORE::semctl
      CORE::semget
      CORE::semop
      CORE::shmctl
      CORE::shmget
      CORE::shmread
  )} = ();
  
  # Cached_fatalised_sub caches the various versions of our
  # fatalised subs as they're produced.  This means we don't
  # have to build our own replacement of CORE::open and friends
  # for every single package that wants to use them.
  
  my %Cached_fatalised_sub = ();
  
  # Every time we're called with package scope, we record the subroutine
  # (including package or CORE::) in %Package_Fatal.  This allows us
  # to detect illegal combinations of autodie and Fatal, and makes sure
  # we don't accidently make a Fatal function autodying (which isn't
  # very useful).
  
  my %Package_Fatal = ();
  
  # The first time we're called with a user-sub, we cache it here.
  # In the case of a "no autodie ..." we put back the cached copy.
  
  my %Original_user_sub = ();
  
  # Is_fatalised_sub simply records a big map of fatalised subroutine
  # refs.  It means we can avoid repeating work, or fatalising something
  # we've already processed.
  
  my  %Is_fatalised_sub = ();
  tie %Is_fatalised_sub, 'Tie::RefHash';
  
  # Our trampoline cache allows us to cache trampolines which are used to
  # bounce leaked wrapped core subroutines to their actual core counterparts.
  
  my %Trampoline_cache;
  
  # We use our package in a few hash-keys.  Having it in a scalar is
  # convenient.  The "guard $PACKAGE" string is used as a key when
  # setting up lexical guards.
  
  my $PACKAGE       = __PACKAGE__;
  my $PACKAGE_GUARD = "guard $PACKAGE";
  my $NO_PACKAGE    = "no $PACKAGE";      # Used to detect 'no autodie'
  
  # Here's where all the magic happens when someone write 'use Fatal'
  # or 'use autodie'.
  
  sub import {
      my $class        = shift(@_);
      my @original_args = @_;
      my $void         = 0;
      my $lexical      = 0;
      my $insist_hints = 0;
  
      my ($pkg, $filename) = caller();
  
      @_ or return;   # 'use Fatal' is a no-op.
  
      # If we see the :lexical flag, then _all_ arguments are
      # changed lexically
  
      if ($_[0] eq LEXICAL_TAG) {
          $lexical = 1;
          shift @_;
  
          # If we see no arguments and :lexical, we assume they
          # wanted ':default'.
  
          if (@_ == 0) {
              push(@_, ':default');
          }
  
          # Don't allow :lexical with :void, it's needlessly confusing.
          if ( grep { $_ eq VOID_TAG } @_ ) {
              croak(ERROR_VOID_LEX);
          }
      }
  
      if ( grep { $_ eq LEXICAL_TAG } @_ ) {
          # If we see the lexical tag as the non-first argument, complain.
          croak(ERROR_LEX_FIRST);
      }
  
      my @fatalise_these =  @_;
  
      # Thiese subs will get unloaded at the end of lexical scope.
      my %unload_later;
  
      # Use _translate_import_args to expand tags for us.  It will
      # pass-through unknown tags (i.e. we have to manually handle
      # VOID_TAG).
      #
      # TODO: Consider how to handle stuff like:
      #   use autodie qw(:defaults ! :io);
      #   use Fatal qw(:defaults :void :io);
      #
      # The ! and :void is currently not applied to anything in the
      # example above since duplicates are filtered out.  This has been
      # autodie's behaviour for quite a while, but it might make sense
      # to change it so "!" or ":void" applies to stuff after they
      # appear (even if they are all duplicates).
      for my $func ($class->_translate_import_args(@fatalise_these)) {
  
          if ($func eq VOID_TAG) {
  
              # When we see :void, set the void flag.
              $void = 1;
  
          } elsif ($func eq INSIST_TAG) {
  
              $insist_hints = 1;
  
          } else {
  
              # Otherwise, fatalise it.
  
              # Check to see if there's an insist flag at the front.
              # If so, remove it, and insist we have hints for this sub.
              my $insist_this;
  
              if ($func =~ s/^!//) {
                  $insist_this = 1;
              }
  
              # We're going to make a subroutine fatalistic.
              # However if we're being invoked with 'use Fatal qw(x)'
              # and we've already been called with 'no autodie qw(x)'
              # in the same scope, we consider this to be an error.
              # Mixing Fatal and autodie effects was considered to be
              # needlessly confusing on p5p.
  
              my $sub = $func;
              $sub = "${pkg}::$sub" unless $sub =~ /::/;
  
              # If we're being called as Fatal, and we've previously
              # had a 'no X' in scope for the subroutine, then complain
              # bitterly.
  
              if (! $lexical and $^H{$NO_PACKAGE}{$sub}) {
                   croak(sprintf(ERROR_FATAL_CONFLICT, $func, $func));
              }
  
              # We're not being used in a confusing way, so make
              # the sub fatal.  Note that _make_fatal returns the
              # old (original) version of the sub, or undef for
              # built-ins.
  
              my $sub_ref = $class->_make_fatal(
                  $func, $pkg, $void, $lexical, $filename,
                  ( $insist_this || $insist_hints )
              );
  
              $Original_user_sub{$sub} ||= $sub_ref;
  
              # If we're making lexical changes, we need to arrange
              # for them to be cleaned at the end of our scope, so
              # record them here.
  
              $unload_later{$func} = $sub_ref if $lexical;
          }
      }
  
      if ($lexical) {
  
          # Dark magic to have autodie work under 5.8
          # Copied from namespace::clean, that copied it from
          # autobox, that found it on an ancient scroll written
          # in blood.
  
          # This magic bit causes %^H to be lexically scoped.
  
          $^H |= 0x020000;
  
          # Our package guard gets invoked when we leave our lexical
          # scope.
  
          push(@ { $^H{$PACKAGE_GUARD} }, autodie::Scope::Guard->new(sub {
              $class->_install_subs($pkg, \%unload_later);
          }));
  
          # To allow others to determine when autodie was in scope,
          # and with what arguments, we also set a %^H hint which
          # is how we were called.
  
          # This feature should be considered EXPERIMENTAL, and
          # may change without notice.  Please e-mail pjf@cpan.org
          # if you're actually using it.
  
          $^H{autodie} = "$PACKAGE @original_args";
  
      }
  
      return;
  
  }
  
  # The code here is originally lifted from namespace::clean,
  # by Robert "phaylon" Sedlacek.
  #
  # It's been redesigned after feedback from ikegami on perlmonks.
  # See http://perlmonks.org/?node_id=693338 .  Ikegami rocks.
  #
  # Given a package, and hash of (subname => subref) pairs,
  # we install the given subroutines into the package.  If
  # a subref is undef, the subroutine is removed.  Otherwise
  # it replaces any existing subs which were already there.
  
  sub _install_subs {
      my ($class, $pkg, $subs_to_reinstate) = @_;
  
      my $pkg_sym = "${pkg}::";
  
      # It does not hurt to do this in a predictable order, and might help debugging.
      foreach my $sub_name (sort keys %$subs_to_reinstate) {
          my $sub_ref= $subs_to_reinstate->{$sub_name};
  
          my $full_path = $pkg_sym.$sub_name;
  
          # Copy symbols across to temp area.
  
          no strict 'refs';   ## no critic
  
          local *__tmp = *{ $full_path };
  
          # Nuke the old glob.
          { no strict; delete $pkg_sym->{$sub_name}; }    ## no critic
  
          # Copy innocent bystanders back.  Note that we lose
          # formats; it seems that Perl versions up to 5.10.0
          # have a bug which causes copying formats to end up in
          # the scalar slot.  Thanks to Ben Morrow for spotting this.
  
          foreach my $slot (qw( SCALAR ARRAY HASH IO ) ) {
              next unless defined *__tmp{ $slot };
              *{ $full_path } = *__tmp{ $slot };
          }
  
          # Put back the old sub (if there was one).
  
          if ($sub_ref) {
  
              no strict;  ## no critic
              *{ $full_path } = $sub_ref;
          }
      }
  
      return;
  }
  
  sub unimport {
      my $class = shift;
  
      # Calling "no Fatal" must start with ":lexical"
      if ($_[0] ne LEXICAL_TAG) {
          croak(sprintf(ERROR_NO_LEX,$class));
      }
  
      shift @_;   # Remove :lexical
  
      my $pkg = (caller)[0];
  
      # If we've been called with arguments, then the developer
      # has explicitly stated 'no autodie qw(blah)',
      # in which case, we disable Fatalistic behaviour for 'blah'.
  
      my @unimport_these = @_ ? @_ : ':all';
  
      for my $symbol ($class->_translate_import_args(@unimport_these)) {
  
          my $sub = $symbol;
          $sub = "${pkg}::$sub" unless $sub =~ /::/;
  
          # If 'blah' was already enabled with Fatal (which has package
          # scope) then, this is considered an error.
  
          if (exists $Package_Fatal{$sub}) {
              croak(sprintf(ERROR_AUTODIE_CONFLICT,$symbol,$symbol));
          }
  
          # Record 'no autodie qw($sub)' as being in effect.
          # This is to catch conflicting semantics elsewhere
          # (eg, mixing Fatal with no autodie)
  
          $^H{$NO_PACKAGE}{$sub} = 1;
  
          if (my $original_sub = $Original_user_sub{$sub}) {
              # Hey, we've got an original one of these, put it back.
              $class->_install_subs($pkg, { $symbol => $original_sub });
              next;
          }
  
          # We don't have an original copy of the sub, on the assumption
          # it's core (or doesn't exist), we'll just nuke it.
  
          $class->_install_subs($pkg,{ $symbol => undef });
  
      }
  
      return;
  
  }
  
  sub _translate_import_args {
      my ($class, @args) = @_;
      my @result;
      for my $a (@args){
          if (exists $TAGS{$a}) {
              my $expanded = $class->_expand_tag($a);
              # Strip "CORE::" from all elements in the list as import and
              # unimport does not handle the "CORE::" prefix too well.
              #
              # NB: we use substr as it is faster than s/^CORE::// and
              # it does not change the elements.
              push @result, map { substr($_, 6) } @{$expanded};
          } else {
              #pass through
              push @result, $a;
          }
      }
      # If @args < 2, then we have no duplicates (because _expand_tag
      # does not have duplicates and if it is not a tag, it is just a
      # single value).  We optimize for this because it is a fairly
      # common case (e.g. use autodie; or use autodie qw(:all); both
      # trigger this).
      return @result if @args < 2;
  
      my %seen = ();
      # Yes, this is basically List::MoreUtils's uniq/distinct, but
      # List::MoreUtils is not in the Perl core and autodie is
      return grep { !$seen{$_}++ } @result;
  }
  
  
  # NB: Perl::Critic's dump-autodie-tag-contents depends upon this
  # continuing to work.
  
  {
      my %tag_cache;
  
      # Expand a given tag (e.g. ":default") into a listref containing
      # all sub names covered by that tag.  Each sub is returned as
      # "CORE::<name>" (i.e. "CORE::open" rather than "open").
      #
      # NB: the listref must not be modified.
      sub _expand_tag {
          my ($class, $tag) = @_;
  
          if (my $cached = $tag_cache{$tag}) {
              return $cached;
          }
  
          if (not exists $TAGS{$tag}) {
              croak "Invalid exception class $tag";
          }
  
          my @to_process = @{$TAGS{$tag}};
  
          # If the tag is basically an alias of another tag (like e.g. ":2.11"),
          # then just share the resulting reference with the original content (so
          # we only pay for an extra reference for the alias memory-wise).
          if (@to_process == 1 && substr($to_process[0], 0, 1) eq ':') {
              # We could do this for "non-tags" as well, but that only occurs
              # once at the time of writing (":threads" => ["fork"]), so
              # probably not worth it.
              my $expanded = $class->_expand_tag($to_process[0]);
              $tag_cache{$tag} = $expanded;
              return $expanded;
          }
  
          my %seen = ();
          my @taglist = ();
  
          for my $item (@to_process) {
              # substr is more efficient than m/^:/ for stuff like this,
              # at the price of being a bit more verbose/low-level.
              if (substr($item, 0, 1) eq ':') {
                  # Use recursion here to ensure we expand a tag at most once.
                  #
                  # TODO: Improve handling of :all so we don't expand
                  # all those aliases (e.g :2.00..:2.07 are all aliases
                  # of v2.07).
  
                  my $expanded = $class->_expand_tag($item);
                  push @taglist, grep { !$seen{$_}++ } @{$expanded};
              } else {
                  my $subname = "CORE::$item";
                  push @taglist, $subname
                      unless $seen{$subname}++;
              }
          }
  
          $tag_cache{$tag} = \@taglist;
  
          return \@taglist;
  
      }
  
  }
  
  # This code is from the original Fatal.  It scares me.
  # It is 100% compatible with the 5.10.0 Fatal module, right down
  # to the scary 'XXXX' comment.  ;)
  
  sub fill_protos {
      my $proto = shift;
      my ($n, $isref, @out, @out1, $seen_semi) = -1;
      if ($proto =~ m{^\s* (?: [;] \s*)? \@}x) {
          # prototype is entirely slurp - special case that does not
          # require any handling.
          return ([0, '@_']);
      }
  
      while ($proto =~ /\S/) {
          $n++;
          push(@out1,[$n,@out]) if $seen_semi;
          push(@out, $1 . "{\$_[$n]}"), next if $proto =~ s/^\s*\\([\@%\$\&])//;
          push(@out, "\$_[$n]"),        next if $proto =~ s/^\s*([_*\$&])//;
          push(@out, "\@_[$n..\$#_]"),  last if $proto =~ s/^\s*(;\s*)?\@//;
          $seen_semi = 1, $n--,         next if $proto =~ s/^\s*;//; # XXXX ????
          die "Internal error: Unknown prototype letters: \"$proto\"";
      }
      push(@out1,[$n+1,@out]);
      return @out1;
  }
  
  # This is a backwards compatible version of _write_invocation.  It's
  # recommended you don't use it.
  
  sub write_invocation {
      my ($core, $call, $name, $void, @args) = @_;
  
      return Fatal->_write_invocation(
          $core, $call, $name, $void,
          0,      # Lexical flag
          undef,  # Sub, unused in legacy mode
          undef,  # Subref, unused in legacy mode.
          @args
      );
  }
  
  # This version of _write_invocation is used internally.  It's not
  # recommended you call it from external code, as the interface WILL
  # change in the future.
  
  sub _write_invocation {
  
      my ($class, $core, $call, $name, $void, $lexical, $sub, $sref, @argvs) = @_;
  
      if (@argvs == 1) {        # No optional arguments
  
          my @argv = @{$argvs[0]};
          shift @argv;
  
          return $class->_one_invocation($core,$call,$name,$void,$sub,! $lexical, $sref, @argv);
  
      } else {
          my $else = "\t";
          my (@out, @argv, $n);
          while (@argvs) {
              @argv = @{shift @argvs};
              $n = shift @argv;
  
              my $condition = "\@_ == $n";
  
              if (@argv and $argv[-1] =~ /[#@]_/) {
                  # This argv ends with '@' in the prototype, so it matches
                  # any number of args >= the number of expressions in the
                  # argv.
                  $condition = "\@_ >= $n";
              }
  
              push @out, "${else}if ($condition) {\n";
  
              $else = "\t} els";
  
          push @out, $class->_one_invocation($core,$call,$name,$void,$sub,! $lexical, $sref, @argv);
          }
          push @out, qq[
              }
              die "Internal error: $name(\@_): Do not expect to get ", scalar(\@_), " arguments";
      ];
  
          return join '', @out;
      }
  }
  
  
  # This is a slim interface to ensure backward compatibility with
  # anyone doing very foolish things with old versions of Fatal.
  
  sub one_invocation {
      my ($core, $call, $name, $void, @argv) = @_;
  
      return Fatal->_one_invocation(
          $core, $call, $name, $void,
          undef,   # Sub.  Unused in back-compat mode.
          1,       # Back-compat flag
          undef,   # Subref, unused in back-compat mode.
          @argv
      );
  
  }
  
  # This is the internal interface that generates code.
  # NOTE: This interface WILL change in the future.  Please do not
  # call this subroutine directly.
  
  # TODO: Whatever's calling this code has already looked up hints.  Pass
  # them in, rather than look them up a second time.
  
  sub _one_invocation {
      my ($class, $core, $call, $name, $void, $sub, $back_compat, $sref, @argv) = @_;
  
  
      # If someone is calling us directly (a child class perhaps?) then
      # they could try to mix void without enabling backwards
      # compatibility.  We just don't support this at all, so we gripe
      # about it rather than doing something unwise.
  
      if ($void and not $back_compat) {
          Carp::confess("Internal error: :void mode not supported with $class");
      }
  
      # @argv only contains the results of the in-built prototype
      # function, and is therefore safe to interpolate in the
      # code generators below.
  
      # TODO - The following clobbers context, but that's what the
      #        old Fatal did.  Do we care?
  
      if ($back_compat) {
  
          # Use Fatal qw(system) will never be supported.  It generated
          # a compile-time error with legacy Fatal, and there's no reason
          # to support it when autodie does a better job.
  
          if ($call eq 'CORE::system') {
              return q{
                  croak("UNIMPLEMENTED: use Fatal qw(system) not supported.");
              };
          }
  
          local $" = ', ';
  
          if ($void) {
              return qq/return (defined wantarray)?$call(@argv):
                     $call(@argv) || Carp::croak("Can't $name(\@_)/ .
                     ($core ? ': $!' : ', \$! is \"$!\"') . '")'
          } else {
              return qq{return $call(@argv) || Carp::croak("Can't $name(\@_)} .
                     ($core ? ': $!' : ', \$! is \"$!\"') . '")';
          }
      }
  
      # The name of our original function is:
      #   $call if the function is CORE
      #   $sub if our function is non-CORE
  
      # The reason for this is that $call is what we're actually
      # calling.  For our core functions, this is always
      # CORE::something.  However for user-defined subs, we're about to
      # replace whatever it is that we're calling; as such, we actually
      # calling a subroutine ref.
  
      my $human_sub_name = $core ? $call : $sub;
  
      # Should we be testing to see if our result is defined, or
      # just true?
  
      my $use_defined_or;
  
      my $hints;      # All user-sub hints, including list hints.
  
      if ( $core ) {
  
          # Core hints are built into autodie.
  
          $use_defined_or = exists ( $Use_defined_or{$call} );
  
      }
      else {
  
          # User sub hints are looked up using autodie::hints,
          # since users may wish to add their own hints.
  
          require autodie::hints;
  
          $hints = autodie::hints->get_hints_for( $sref );
  
          # We'll look up the sub's fullname.  This means we
          # get better reports of where it came from in our
          # error messages, rather than what imported it.
  
          $human_sub_name = autodie::hints->sub_fullname( $sref );
  
      }
  
      # Checks for special core subs.
  
      if ($call eq 'CORE::system') {
  
          # Leverage IPC::System::Simple if we're making an autodying
          # system.
  
          local $" = ", ";
  
          # We need to stash $@ into $E, rather than using
          # local $@ for the whole sub.  If we don't then
          # any exceptions from internal errors in autodie/Fatal
          # will mysteriously disappear before propagating
          # upwards.
  
          return qq{
              my \$retval;
              my \$E;
  
  
              {
                  local \$@;
  
                  eval {
                      \$retval = IPC::System::Simple::system(@argv);
                  };
  
                  \$E = \$@;
              }
  
              if (\$E) {
  
                  # TODO - This can't be overridden in child
                  # classes!
  
                  die autodie::exception::system->new(
                      function => q{CORE::system}, args => [ @argv ],
                      message => "\$E", errno => \$!,
                  );
              }
  
              return \$retval;
          };
  
      }
  
      local $" = ', ';
  
      # If we're going to throw an exception, here's the code to use.
      my $die = qq{
          die $class->throw(
              function => q{$human_sub_name}, args => [ @argv ],
              pragma => q{$class}, errno => \$!,
              context => \$context, return => \$retval,
              eval_error => \$@
          )
      };
  
      if ($call eq 'CORE::flock') {
  
          # flock needs special treatment.  When it fails with
          # LOCK_UN and EWOULDBLOCK, then it's not really fatal, it just
          # means we couldn't get the lock right now.
  
          require POSIX;      # For POSIX::EWOULDBLOCK
  
          local $@;   # Don't blat anyone else's $@.
  
          # Ensure that our vendor supports EWOULDBLOCK.  If they
          # don't (eg, Windows), then we use known values for its
          # equivalent on other systems.
  
          my $EWOULDBLOCK = eval { POSIX::EWOULDBLOCK(); }
                            || $_EWOULDBLOCK{$^O}
                            || _autocroak("Internal error - can't overload flock - EWOULDBLOCK not defined on this system.");
          my $EAGAIN = $EWOULDBLOCK;
          if ($try_EAGAIN) {
              $EAGAIN = eval { POSIX::EAGAIN(); }
                            || _autocroak("Internal error - can't overload flock - EAGAIN not defined on this system.");
          }
  
          require Fcntl;      # For Fcntl::LOCK_NB
  
          return qq{
  
              my \$context = wantarray() ? "list" : "scalar";
  
              # Try to flock.  If successful, return it immediately.
  
              my \$retval = $call(@argv);
              return \$retval if \$retval;
  
              # If we failed, but we're using LOCK_NB and
              # returned EWOULDBLOCK, it's not a real error.
  
              if (\$_[1] & Fcntl::LOCK_NB() and
                  (\$! == $EWOULDBLOCK or
                  ($try_EAGAIN and \$! == $EAGAIN ))) {
                  return \$retval;
              }
  
              # Otherwise, we failed.  Die noisily.
  
              $die;
  
          };
      }
  
      if (exists $Returns_num_things_changed{$call}) {
  
          # Some things return the number of things changed (like
          # chown, kill, chmod, etc). We only consider these successful
          # if *all* the things are changed.
  
          return qq[
              my \$num_things = \@_ - $Returns_num_things_changed{$call};
              my \$retval = $call(@argv);
  
              if (\$retval != \$num_things) {
  
                  # We need \$context to throw an exception.
                  # It's *always* set to scalar, because that's how
                  # autodie calls chown() above.
  
                  my \$context = "scalar";
                  $die;
              }
  
              return \$retval;
          ];
      }
  
      # AFAIK everything that can be given an unopned filehandle
      # will fail if it tries to use it, so we don't really need
      # the 'unopened' warning class here.  Especially since they
      # then report the wrong line number.
  
      # Other warnings are disabled because they produce excessive
      # complaints from smart-match hints under 5.10.1.
  
      my $code = qq[
          no warnings qw(unopened uninitialized numeric);
          no if \$\] >= 5.017011, warnings => "experimental::smartmatch";
  
          if (wantarray) {
              my \@results = $call(@argv);
              my \$retval  = \\\@results;
              my \$context = "list";
  
      ];
  
      my $retval_action = $Retval_action{$call} || '';
  
      if ( $hints and ( ref($hints->{list} ) || "" ) eq 'CODE' ) {
  
          # NB: Subroutine hints are passed as a full list.
          # This differs from the 5.10.0 smart-match behaviour,
          # but means that context unaware subroutines can use
          # the same hints in both list and scalar context.
  
          $code .= qq{
              if ( \$hints->{list}->(\@results) ) { $die };
          };
      }
      elsif ( PERL510 and $hints ) {
          $code .= qq{
              if ( \@results ~~ \$hints->{list} ) { $die };
          };
      }
      elsif ( $hints ) {
          croak sprintf(ERROR_58_HINTS, 'list', $sub);
      }
      else {
          $code .= qq{
              # An empty list, or a single undef is failure
              if (! \@results or (\@results == 1 and ! defined \$results[0])) {
                  $die;
              }
          }
      }
  
      # Tidy up the end of our wantarray call.
  
      $code .= qq[
              return \@results;
          }
      ];
  
  
      # Otherwise, we're in scalar context.
      # We're never in a void context, since we have to look
      # at the result.
  
      $code .= qq{
          my \$retval  = $call(@argv);
          my \$context = "scalar";
      };
  
      if ( $hints and ( ref($hints->{scalar} ) || "" ) eq 'CODE' ) {
  
          # We always call code refs directly, since that always
          # works in 5.8.x, and always works in 5.10.1
  
          return $code .= qq{
              if ( \$hints->{scalar}->(\$retval) ) { $die };
              $retval_action
              return \$retval;
          };
  
      }
      elsif (PERL510 and $hints) {
          return $code . qq{
  
              if ( \$retval ~~ \$hints->{scalar} ) { $die };
              $retval_action
              return \$retval;
          };
      }
      elsif ( $hints ) {
          croak sprintf(ERROR_58_HINTS, 'scalar', $sub);
      }
  
      return $code .
      ( $use_defined_or ? qq{
  
          $die if not defined \$retval;
          $retval_action
          return \$retval;
  
      } : qq{
  
          $retval_action
          return \$retval || $die;
  
      } ) ;
  
  }
  
  # This returns the old copy of the sub, so we can
  # put it back at end of scope.
  
  # TODO : Check to make sure prototypes are restored correctly.
  
  # TODO: Taking a huge list of arguments is awful.  Rewriting to
  #       take a hash would be lovely.
  
  # TODO - BACKCOMPAT - This is not yet compatible with 5.10.0
  
  sub _make_fatal {
      my($class, $sub, $pkg, $void, $lexical, $filename, $insist) = @_;
      my($name, $code, $sref, $real_proto, $proto, $core, $call, $hints);
      my $ini = $sub;
  
      $sub = "${pkg}::$sub" unless $sub =~ /::/;
  
      # Figure if we're using lexical or package semantics and
      # twiddle the appropriate bits.
  
      if (not $lexical) {
          $Package_Fatal{$sub} = 1;
      }
  
      # TODO - We *should* be able to do skipping, since we know when
      # we've lexicalised / unlexicalised a subroutine.
  
      $name = $sub;
      $name =~ s/.*::// or $name =~ s/^&//;
  
      warn  "# _make_fatal: sub=$sub pkg=$pkg name=$name void=$void\n" if $Debug;
      croak(sprintf(ERROR_BADNAME, $class, $name)) unless $name =~ /^\w+$/;
  
      if (defined(&$sub)) {   # user subroutine
  
          # NOTE: Previously we would localise $@ at this point, so
          # the following calls to eval {} wouldn't interfere with anything
          # that's already in $@.  Unfortunately, it would also stop
          # any of our croaks from triggering(!), which is even worse.
  
          # This could be something that we've fatalised that
          # was in core.
  
          if ( $Package_Fatal{$sub} and do { local $@; eval { prototype "CORE::$name" } } ) {
  
              # Something we previously made Fatal that was core.
              # This is safe to replace with an autodying to core
              # version.
  
              $core  = 1;
              $call  = "CORE::$name";
              $proto = prototype $call;
  
              # We return our $sref from this subroutine later
              # on, indicating this subroutine should be placed
              # back when we're finished.
  
              $sref = \&$sub;
  
          } else {
  
              # If this is something we've already fatalised or played with,
              # then look-up the name of the original sub for the rest of
              # our processing.
  
              $sub = $Is_fatalised_sub{\&$sub} || $sub;
  
              # A regular user sub, or a user sub wrapping a
              # core sub.
  
              $sref = \&$sub;
              $proto = prototype $sref;
              $call = '&$sref';
              require autodie::hints;
  
              $hints = autodie::hints->get_hints_for( $sref );
  
              # If we've insisted on hints, but don't have them, then
              # bail out!
  
              if ($insist and not $hints) {
                  croak(sprintf(ERROR_NOHINTS, $name));
              }
  
              # Otherwise, use the default hints if we don't have
              # any.
  
              $hints ||= autodie::hints::DEFAULT_HINTS();
  
          }
  
      } elsif ($sub eq $ini && $sub !~ /^CORE::GLOBAL::/) {
          # Stray user subroutine
          croak(sprintf(ERROR_NOTSUB,$sub));
  
      } elsif ($name eq 'system') {
  
          # If we're fatalising system, then we need to load
          # helper code.
  
          # The business with $E is to avoid clobbering our caller's
          # $@, and to avoid $@ being localised when we croak.
  
          my $E;
  
          {
              local $@;
  
              eval {
                  require IPC::System::Simple; # Only load it if we need it.
                  require autodie::exception::system;
              };
              $E = $@;
          }
  
          if ($E) { croak ERROR_NO_IPC_SYS_SIMPLE; }
  
          # Make sure we're using a recent version of ISS that actually
          # support fatalised system.
          if ($IPC::System::Simple::VERSION < MIN_IPC_SYS_SIMPLE_VER) {
              croak sprintf(
              ERROR_IPC_SYS_SIMPLE_OLD, MIN_IPC_SYS_SIMPLE_VER,
              $IPC::System::Simple::VERSION
              );
          }
  
          $call = 'CORE::system';
          $name = 'system';
          $core = 1;
  
      } elsif ($name eq 'exec') {
          # Exec doesn't have a prototype.  We don't care.  This
          # breaks the exotic form with lexical scope, and gives
          # the regular form a "do or die" behavior as expected.
  
          $call = 'CORE::exec';
          $name = 'exec';
          $core = 1;
  
      } else {            # CORE subroutine
          my $E;
          {
              local $@;
              $proto = eval { prototype "CORE::$name" };
              $E = $@;
          }
          croak(sprintf(ERROR_NOT_BUILT,$name)) if $E;
          croak(sprintf(ERROR_CANT_OVERRIDE,$name)) if not defined $proto;
          $core = 1;
          $call = "CORE::$name";
      }
  
      my $true_name = $core ? $call : $sub;
  
      # TODO: This caching works, but I don't like using $void and
      # $lexical as keys.  In particular, I suspect our code may end up
      # wrapping already wrapped code when autodie and Fatal are used
      # together.
  
      # NB: We must use '$sub' (the name plus package) and not
      # just '$name' (the short name) here.  Failing to do so
      # results code that's in the wrong package, and hence has
      # access to the wrong package filehandles.
  
      if (my $subref = $Cached_fatalised_sub{$class}{$sub}{$void}{$lexical}) {
          $class->_install_subs($pkg, { $name => $subref });
          return $sref;
      }
  
      # If our subroutine is reusable (ie, not package depdendent),
      # then check to see if we've got a cached copy, and use that.
      # See RT #46984. (Thanks to Niels Thykier for being awesome!)
  
      if ($core && exists $reusable_builtins{$call}) {
          # For non-lexical subs, we can just use this cache directly
          # - for lexical variants, we need a leak guard as well.
          $code = $reusable_builtins{$call}{$lexical};
          if (!$lexical && defined($code)) {
              $class->_install_subs($pkg, { $name => $code });
              return $sref;
          }
      }
  
      if (defined $proto) {
          $real_proto = " ($proto)";
      } else {
          $real_proto = '';
          $proto = '@';
      }
  
      if (!defined($code)) {
          # No code available, generate it now.
          my @protos = fill_protos($proto);
  
          $code = qq[
              sub$real_proto {
                local(\$", \$!) = (', ', 0);    # TODO - Why do we do this?
          ];
  
          # Don't have perl whine if exec fails, since we'll be handling
          # the exception now.
          $code .= "no warnings qw(exec);\n" if $call eq "CORE::exec";
  
          $code .= $class->_write_invocation($core, $call, $name, $void, $lexical,
                                             $sub, $sref, @protos);
          $code .= "}\n";
          warn $code if $Debug;
  
          # I thought that changing package was a monumental waste of
          # time for CORE subs, since they'll always be the same.  However
          # that's not the case, since they may refer to package-based
          # filehandles (eg, with open).
          #
          # The %reusable_builtins hash defines ones we can aggressively
          # cache as they never depend upon package-based symbols.
  
          {
              no strict 'refs'; ## no critic # to avoid: Can't use string (...) as a symbol ref ...
  
              my $E;
  
              {
                  local $@;
                  if (!exists($reusable_builtins{$call})) {
                      $code = eval("package $pkg; require Carp; $code");  ## no critic
                  } else {
                      $code = eval("require Carp; $code");  ## no critic
                      if (exists $reusable_builtins{$call}) {
                          # cache it so we don't recompile this part again
                          $reusable_builtins{$call}{$lexical} = $code;
                      }
                  }
                  $E = $@;
              }
  
              if (not $code) {
                  croak("Internal error in autodie/Fatal processing $true_name: $E");
  
              }
          }
      }
  
      # Now we need to wrap our fatalised sub inside an itty bitty
      # closure, which can detect if we've leaked into another file.
      # Luckily, we only need to do this for lexical (autodie)
      # subs.  Fatal subs can leak all they want, it's considered
      # a "feature" (or at least backwards compatible).
  
      # TODO: Cache our leak guards!
  
      # TODO: This is pretty hairy code.  A lot more tests would
      # be really nice for this.
  
      my $leak_guard;
  
      if ($lexical) {
          $leak_guard = _make_leak_guard($filename, $code, $sref, $call,
                                         $pkg, $proto, $real_proto);
      }
  
      my $installed_sub = $leak_guard || $code;
  
      $class->_install_subs($pkg, { $name => $installed_sub });
  
      $Cached_fatalised_sub{$class}{$sub}{$void}{$lexical} = $installed_sub;
  
      # Cache that we've now overridden this sub.  If we get called
      # again, we may need to find that find subroutine again (eg, for hints).
  
      $Is_fatalised_sub{$installed_sub} = $sref;
  
      return $sref;
  
  }
  
  # This subroutine exists primarily so that child classes can override
  # it to point to their own exception class.  Doing this is significantly
  # less complex than overriding throw()
  
  sub exception_class { return "autodie::exception" };
  
  {
      my %exception_class_for;
      my %class_loaded;
  
      sub throw {
          my ($class, @args) = @_;
  
          # Find our exception class if we need it.
          my $exception_class =
               $exception_class_for{$class} ||= $class->exception_class;
  
          if (not $class_loaded{$exception_class}) {
              if ($exception_class =~ /[^\w:']/) {
                  confess "Bad exception class '$exception_class'.\nThe '$class->exception_class' method wants to use $exception_class\nfor exceptions, but it contains characters which are not word-characters or colons.";
              }
  
              # Alas, Perl does turn barewords into modules unless they're
              # actually barewords.  As such, we're left doing a string eval
              # to make sure we load our file correctly.
  
              my $E;
  
              {
                  local $@;   # We can't clobber $@, it's wrong!
                  my $pm_file = $exception_class . ".pm";
                  $pm_file =~ s{ (?: :: | ' ) }{/}gx;
                  eval { require $pm_file };
                  $E = $@;    # Save $E despite ending our local.
              }
  
              # We need quotes around $@ to make sure it's stringified
              # while still in scope.  Without them, we run the risk of
              # $@ having been cleared by us exiting the local() block.
  
              confess "Failed to load '$exception_class'.\nThis may be a typo in the '$class->exception_class' method,\nor the '$exception_class' module may not exist.\n\n $E" if $E;
  
              $class_loaded{$exception_class}++;
  
          }
  
          return $exception_class->new(@args);
      }
  }
  
  # Creates and returns a leak guard (with prototype if needed).
  sub _make_leak_guard {
      my ($filename, $wrapped_sub, $orig_sub, $call, $pkg, $proto, $real_proto) = @_;
  
      # The leak guard is rather lengthly (in fact it makes up the most
      # of _make_leak_guard).  It is possible to split it into a large
      # "generic" part and a small wrapper with call-specific
      # information.  This was done in v2.19 and profiling suggested
      # that we ended up using a substantial amount of runtime in "goto"
      # between the leak guard(s) and the final sub.  Therefore, the two
      # parts were merged into one to reduce the runtime overhead.
  
      my $leak_guard = sub {
          my $caller_level = 0;
          my $caller;
  
          while ( ($caller = (caller $caller_level)[1]) =~ m{^\(eval \d+\)$} ) {
  
              # If our filename is actually an eval, and we
              # reach it, then go to our autodying code immediatately.
  
              last if ($caller eq $filename);
              $caller_level++;
          }
  
          # We're now out of the eval stack.
  
          if ($caller eq $filename) {
              # No leak, call the wrapper.  NB: In this case, it doesn't
              # matter if it is a CORE sub or not.
              goto $wrapped_sub;
          }
  
          # We leaked, time to call the original function.
          # - for non-core functions that will be $orig_sub
          goto $orig_sub if defined($orig_sub);
  
          # We are wrapping a CORE sub
  
          # If we've cached a trampoline, then use it.
          my $trampoline_sub = $Trampoline_cache{$pkg}{$call};
  
          if (not $trampoline_sub) {
              # If we don't have a trampoline, we need to build it.
              #
              # We only generate trampolines when we need them, and
              # we can cache them by subroutine + package.
  
              # TODO: Consider caching on reusable_builtins status as well.
  
              $trampoline_sub = _make_core_trampoline($call, $pkg, $proto);
  
              # Let's cache that, so we don't have to do it again.
              $Trampoline_cache{$pkg}{$call} = $trampoline_sub;
          }
  
          # Bounce to our trampoline, which takes us to our core sub.
          goto \&$trampoline_sub;
      };  # <-- end of leak guard
  
      # If there is a prototype on the original sub, copy it to the leak
      # guard.
      if ($real_proto ne '') {
          # The "\&" may appear to be redundant but set_prototype
          # croaks when it is removed.
          set_prototype(\&$leak_guard, $proto);
      }
  
      return $leak_guard;
  }
  
  # Create a trampoline for calling a core sub.  Essentially, a tiny sub
  # that figures out how we should be calling our core sub, puts in the
  # arguments in the right way, and bounces our control over to it.
  #
  # If we could use `goto &` on core builtins, we wouldn't need this.
  sub _make_core_trampoline {
      my ($call, $pkg, $proto_str) = @_;
      my $trampoline_code = 'sub {';
      my $trampoline_sub;
      my @protos = fill_protos($proto_str);
  
      # TODO: It may be possible to combine this with write_invocation().
  
      foreach my $proto (@protos) {
          local $" = ", ";    # So @args is formatted correctly.
          my ($count, @args) = @$proto;
          if (@args && $args[-1] =~ m/[@#]_/) {
              $trampoline_code .= qq/
                  if (\@_ >= $count) {
                      return $call(@args);
                  }
               /;
          } else {
              $trampoline_code .= qq<
                  if (\@_ == $count) {
                      return $call(@args);
                  }
               >;
          }
      }
  
      $trampoline_code .= qq< Carp::croak("Internal error in Fatal/autodie.  Leak-guard failure"); } >;
      my $E;
  
      {
          local $@;
          $trampoline_sub = eval "package $pkg;\n $trampoline_code"; ## no critic
          $E = $@;
      }
      die "Internal error in Fatal/autodie: Leak-guard installation failure: $E"
          if $E;
  
      return $trampoline_sub;
  }
  
  # For some reason, dying while replacing our subs doesn't
  # kill our calling program.  It simply stops the loading of
  # autodie and keeps going with everything else.  The _autocroak
  # sub allows us to die with a vengeance.  It should *only* ever be
  # used for serious internal errors, since the results of it can't
  # be captured.
  
  sub _autocroak {
      warn Carp::longmess(@_);
      exit(255);  # Ugh!
  }
  
  package autodie::Scope::Guard;
  
  # This code schedules the cleanup of subroutines at the end of
  # scope.  It's directly inspired by chocolateboy's excellent
  # Scope::Guard module.
  
  sub new {
      my ($class, $handler) = @_;
  
      return bless $handler, $class;
  }
  
  sub DESTROY {
      my ($self) = @_;
  
      $self->();
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Fatal - Replace functions with equivalents which succeed or die
  
  =head1 SYNOPSIS
  
      use Fatal qw(open close);
  
      open(my $fh, "<", $filename);  # No need to check errors!
  
      use File::Copy qw(move);
      use Fatal qw(move);
  
      move($file1, $file2); # No need to check errors!
  
      sub juggle { . . . }
      Fatal->import('juggle');
  
  =head1 BEST PRACTICE
  
  B<Fatal has been obsoleted by the new L<autodie> pragma.> Please use
  L<autodie> in preference to C<Fatal>.  L<autodie> supports lexical scoping,
  throws real exception objects, and provides much nicer error messages.
  
  The use of C<:void> with Fatal is discouraged.
  
  =head1 DESCRIPTION
  
  C<Fatal> provides a way to conveniently replace
  functions which normally return a false value when they fail with
  equivalents which raise exceptions if they are not successful.  This
  lets you use these functions without having to test their return
  values explicitly on each call.  Exceptions can be caught using
  C<eval{}>.  See L<perlfunc> and L<perlvar> for details.
  
  The do-or-die equivalents are set up simply by calling Fatal's
  C<import> routine, passing it the names of the functions to be
  replaced.  You may wrap both user-defined functions and overridable
  CORE operators (except C<exec>, C<system>, C<print>, or any other
  built-in that cannot be expressed via prototypes) in this way.
  
  If the symbol C<:void> appears in the import list, then functions
  named later in that import list raise an exception only when
  these are called in void context--that is, when their return
  values are ignored.  For example
  
      use Fatal qw/:void open close/;
  
      # properly checked, so no exception raised on error
      if (not open(my $fh, '<', '/bogotic') {
          warn "Can't open /bogotic: $!";
      }
  
      # not checked, so error raises an exception
      close FH;
  
  The use of C<:void> is discouraged, as it can result in exceptions
  not being thrown if you I<accidentally> call a method without
  void context.  Use L<autodie> instead if you need to be able to
  disable autodying/Fatal behaviour for a small block of code.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item Bad subroutine name for Fatal: %s
  
  You've called C<Fatal> with an argument that doesn't look like
  a subroutine name, nor a switch that this version of Fatal
  understands.
  
  =item %s is not a Perl subroutine
  
  You've asked C<Fatal> to try and replace a subroutine which does not
  exist, or has not yet been defined.
  
  =item %s is neither a builtin, nor a Perl subroutine
  
  You've asked C<Fatal> to replace a subroutine, but it's not a Perl
  built-in, and C<Fatal> couldn't find it as a regular subroutine.
  It either doesn't exist or has not yet been defined.
  
  =item Cannot make the non-overridable %s fatal
  
  You've tried to use C<Fatal> on a Perl built-in that can't be
  overridden, such as C<print> or C<system>, which means that
  C<Fatal> can't help you, although some other modules might.
  See the L</"SEE ALSO"> section of this documentation.
  
  =item Internal error: %s
  
  You've found a bug in C<Fatal>.  Please report it using
  the C<perlbug> command.
  
  =back
  
  =head1 BUGS
  
  C<Fatal> clobbers the context in which a function is called and always
  makes it a scalar context, except when the C<:void> tag is used.
  This problem does not exist in L<autodie>.
  
  "Used only once" warnings can be generated when C<autodie> or C<Fatal>
  is used with package filehandles (eg, C<FILE>).  It's strongly recommended
  you use scalar filehandles instead.
  
  =head1 AUTHOR
  
  Original module by Lionel Cons (CERN).
  
  Prototype updates by Ilya Zakharevich <ilya@math.ohio-state.edu>.
  
  L<autodie> support, bugfixes, extended diagnostics, C<system>
  support, and major overhauling by Paul Fenwick <pjf@perltraining.com.au>
  
  =head1 LICENSE
  
  This module is free software, you may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie> for a nicer way to use lexical Fatal.
  
  L<IPC::System::Simple> for a similar idea for calls to C<system()>
  and backticks.
  
  =for Pod::Coverage exception_class fill_protos one_invocation throw write_invocation
  
  =cut
FATAL

$fatpacked{"File/Basename.pm"} = <<'FILE_BASENAME';
  =head1 NAME
  
  File::Basename - Parse file paths into directory, filename and suffix.
  
  =head1 SYNOPSIS
  
      use File::Basename;
  
      ($name,$path,$suffix) = fileparse($fullname,@suffixlist);
      $name = fileparse($fullname,@suffixlist);
  
      $basename = basename($fullname,@suffixlist);
      $dirname  = dirname($fullname);
  
  
  =head1 DESCRIPTION
  
  These routines allow you to parse file paths into their directory, filename
  and suffix.
  
  B<NOTE>: C<dirname()> and C<basename()> emulate the behaviours, and
  quirks, of the shell and C functions of the same name.  See each
  function's documentation for details.  If your concern is just parsing
  paths it is safer to use L<File::Spec>'s C<splitpath()> and
  C<splitdir()> methods.
  
  It is guaranteed that
  
      # Where $path_separator is / for Unix, \ for Windows, etc...
      dirname($path) . $path_separator . basename($path);
  
  is equivalent to the original path for all systems but VMS.
  
  
  =cut
  
  
  package File::Basename;
  
  # File::Basename is used during the Perl build, when the re extension may
  # not be available, but we only actually need it if running under tainting.
  BEGIN {
    if (${^TAINT}) {
      require re;
      re->import('taint');
    }
  }
  
  
  use strict;
  use 5.006;
  use warnings;
  our(@ISA, @EXPORT, $VERSION, $Fileparse_fstype, $Fileparse_igncase);
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(fileparse fileparse_set_fstype basename dirname);
  $VERSION = "2.84";
  
  fileparse_set_fstype($^O);
  
  
  =over 4
  
  =item C<fileparse>
  X<fileparse>
  
      my($filename, $directories, $suffix) = fileparse($path);
      my($filename, $directories, $suffix) = fileparse($path, @suffixes);
      my $filename                         = fileparse($path, @suffixes);
  
  The C<fileparse()> routine divides a file path into its $directories, $filename
  and (optionally) the filename $suffix.
  
  $directories contains everything up to and including the last
  directory separator in the $path including the volume (if applicable).
  The remainder of the $path is the $filename.
  
       # On Unix returns ("baz", "/foo/bar/", "")
       fileparse("/foo/bar/baz");
  
       # On Windows returns ("baz", 'C:\foo\bar\', "")
       fileparse('C:\foo\bar\baz');
  
       # On Unix returns ("", "/foo/bar/baz/", "")
       fileparse("/foo/bar/baz/");
  
  If @suffixes are given each element is a pattern (either a string or a
  C<qr//>) matched against the end of the $filename.  The matching
  portion is removed and becomes the $suffix.
  
       # On Unix returns ("baz", "/foo/bar/", ".txt")
       fileparse("/foo/bar/baz.txt", qr/\.[^.]*/);
  
  If type is non-Unix (see L</fileparse_set_fstype>) then the pattern
  matching for suffix removal is performed case-insensitively, since
  those systems are not case-sensitive when opening existing files.
  
  You are guaranteed that C<$directories . $filename . $suffix> will
  denote the same location as the original $path.
  
  =cut
  
  
  sub fileparse {
    my($fullname,@suffices) = @_;
  
    unless (defined $fullname) {
        require Carp;
        Carp::croak("fileparse(): need a valid pathname");
    }
  
    my $orig_type = '';
    my($type,$igncase) = ($Fileparse_fstype, $Fileparse_igncase);
  
    my($taint) = substr($fullname,0,0);  # Is $fullname tainted?
  
    if ($type eq "VMS" and $fullname =~ m{/} ) {
      # We're doing Unix emulation
      $orig_type = $type;
      $type = 'Unix';
    }
  
    my($dirpath, $basename);
  
    if (grep { $type eq $_ } qw(MSDOS DOS MSWin32 Epoc)) {
      ($dirpath,$basename) = ($fullname =~ /^((?:.*[:\\\/])?)(.*)/s);
      $dirpath .= '.\\' unless $dirpath =~ /[\\\/]\z/;
    }
    elsif ($type eq "OS2") {
      ($dirpath,$basename) = ($fullname =~ m#^((?:.*[:\\/])?)(.*)#s);
      $dirpath = './' unless $dirpath;	# Can't be 0
      $dirpath .= '/' unless $dirpath =~ m#[\\/]\z#;
    }
    elsif ($type eq "MacOS") {
      ($dirpath,$basename) = ($fullname =~ /^(.*:)?(.*)/s);
      $dirpath = ':' unless $dirpath;
    }
    elsif ($type eq "AmigaOS") {
      ($dirpath,$basename) = ($fullname =~ /(.*[:\/])?(.*)/s);
      $dirpath = './' unless $dirpath;
    }
    elsif ($type eq 'VMS' ) {
      ($dirpath,$basename) = ($fullname =~ /^(.*[:>\]])?(.*)/s);
      $dirpath ||= '';  # should always be defined
    }
    else { # Default to Unix semantics.
      ($dirpath,$basename) = ($fullname =~ m{^(.*/)?(.*)}s);
      if ($orig_type eq 'VMS' and $fullname =~ m{^(/[^/]+/000000(/|$))(.*)}) {
        # dev:[000000] is top of VMS tree, similar to Unix '/'
        # so strip it off and treat the rest as "normal"
        my $devspec  = $1;
        my $remainder = $3;
        ($dirpath,$basename) = ($remainder =~ m{^(.*/)?(.*)}s);
        $dirpath ||= '';  # should always be defined
        $dirpath = $devspec.$dirpath;
      }
      $dirpath = './' unless $dirpath;
    }
        
  
    my $tail   = '';
    my $suffix = '';
    if (@suffices) {
      foreach $suffix (@suffices) {
        my $pat = ($igncase ? '(?i)' : '') . "($suffix)\$";
        if ($basename =~ s/$pat//s) {
          $taint .= substr($suffix,0,0);
          $tail = $1 . $tail;
        }
      }
    }
  
    # Ensure taint is propagated from the path to its pieces.
    $tail .= $taint;
    wantarray ? ($basename .= $taint, $dirpath .= $taint, $tail)
              : ($basename .= $taint);
  }
  
  
  
  =item C<basename>
  X<basename> X<filename>
  
      my $filename = basename($path);
      my $filename = basename($path, @suffixes);
  
  This function is provided for compatibility with the Unix shell command
  C<basename(1)>.  It does B<NOT> always return the file name portion of a
  path as you might expect.  To be safe, if you want the file name portion of
  a path use C<fileparse()>.
  
  C<basename()> returns the last level of a filepath even if the last
  level is clearly directory.  In effect, it is acting like C<pop()> for
  paths.  This differs from C<fileparse()>'s behaviour.
  
      # Both return "bar"
      basename("/foo/bar");
      basename("/foo/bar/");
  
  @suffixes work as in C<fileparse()> except all regex metacharacters are
  quoted.
  
      # These two function calls are equivalent.
      my $filename = basename("/foo/bar/baz.txt",  ".txt");
      my $filename = fileparse("/foo/bar/baz.txt", qr/\Q.txt\E/);
  
  Also note that in order to be compatible with the shell command,
  C<basename()> does not strip off a suffix if it is identical to the
  remaining characters in the filename.
  
  =cut
  
  
  sub basename {
    my($path) = shift;
  
    # From BSD basename(1)
    # The basename utility deletes any prefix ending with the last slash '/'
    # character present in string (after first stripping trailing slashes)
    _strip_trailing_sep($path);
  
    my($basename, $dirname, $suffix) = fileparse( $path, map("\Q$_\E",@_) );
  
    # From BSD basename(1)
    # The suffix is not stripped if it is identical to the remaining 
    # characters in string.
    if( length $suffix and !length $basename ) {
        $basename = $suffix;
    }
    
    # Ensure that basename '/' == '/'
    if( !length $basename ) {
        $basename = $dirname;
    }
  
    return $basename;
  }
  
  
  
  =item C<dirname>
  X<dirname>
  
  This function is provided for compatibility with the Unix shell
  command C<dirname(1)> and has inherited some of its quirks.  In spite of
  its name it does B<NOT> always return the directory name as you might
  expect.  To be safe, if you want the directory name of a path use
  C<fileparse()>.
  
  Only on VMS (where there is no ambiguity between the file and directory
  portions of a path) and AmigaOS (possibly due to an implementation quirk in
  this module) does C<dirname()> work like C<fileparse($path)>, returning just the
  $directories.
  
      # On VMS and AmigaOS
      my $directories = dirname($path);
  
  When using Unix or MSDOS syntax this emulates the C<dirname(1)> shell function
  which is subtly different from how C<fileparse()> works.  It returns all but
  the last level of a file path even if the last level is clearly a directory.
  In effect, it is not returning the directory portion but simply the path one
  level up acting like C<chop()> for file paths.
  
  Also unlike C<fileparse()>, C<dirname()> does not include a trailing slash on
  its returned path.
  
      # returns /foo/bar.  fileparse() would return /foo/bar/
      dirname("/foo/bar/baz");
  
      # also returns /foo/bar despite the fact that baz is clearly a 
      # directory.  fileparse() would return /foo/bar/baz/
      dirname("/foo/bar/baz/");
  
      # returns '.'.  fileparse() would return 'foo/'
      dirname("foo/");
  
  Under VMS, if there is no directory information in the $path, then the
  current default device and directory is used.
  
  =cut
  
  
  sub dirname {
      my $path = shift;
  
      my($type) = $Fileparse_fstype;
  
      if( $type eq 'VMS' and $path =~ m{/} ) {
          # Parse as Unix
          local($File::Basename::Fileparse_fstype) = '';
          return dirname($path);
      }
  
      my($basename, $dirname) = fileparse($path);
  
      if ($type eq 'VMS') { 
          $dirname ||= $ENV{DEFAULT};
      }
      elsif ($type eq 'MacOS') {
  	if( !length($basename) && $dirname !~ /^[^:]+:\z/) {
              _strip_trailing_sep($dirname);
  	    ($basename,$dirname) = fileparse $dirname;
  	}
  	$dirname .= ":" unless $dirname =~ /:\z/;
      }
      elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { 
          _strip_trailing_sep($dirname);
          unless( length($basename) ) {
  	    ($basename,$dirname) = fileparse $dirname;
  	    _strip_trailing_sep($dirname);
  	}
      }
      elsif ($type eq 'AmigaOS') {
          if ( $dirname =~ /:\z/) { return $dirname }
          chop $dirname;
          $dirname =~ s{[^:/]+\z}{} unless length($basename);
      }
      else {
          _strip_trailing_sep($dirname);
          unless( length($basename) ) {
  	    ($basename,$dirname) = fileparse $dirname;
  	    _strip_trailing_sep($dirname);
  	}
      }
  
      $dirname;
  }
  
  
  # Strip the trailing path separator.
  sub _strip_trailing_sep  {
      my $type = $Fileparse_fstype;
  
      if ($type eq 'MacOS') {
          $_[0] =~ s/([^:]):\z/$1/s;
      }
      elsif (grep { $type eq $_ } qw(MSDOS DOS MSWin32 OS2)) { 
          $_[0] =~ s/([^:])[\\\/]*\z/$1/;
      }
      else {
          $_[0] =~ s{(.)/*\z}{$1}s;
      }
  }
  
  
  =item C<fileparse_set_fstype>
  X<filesystem>
  
    my $type = fileparse_set_fstype();
    my $previous_type = fileparse_set_fstype($type);
  
  Normally File::Basename will assume a file path type native to your current
  operating system (ie. /foo/bar style on Unix, \foo\bar on Windows, etc...).
  With this function you can override that assumption.
  
  Valid $types are "MacOS", "VMS", "AmigaOS", "OS2", "RISCOS",
  "MSWin32", "DOS" (also "MSDOS" for backwards bug compatibility),
  "Epoc" and "Unix" (all case-insensitive).  If an unrecognized $type is
  given "Unix" will be assumed.
  
  If you've selected VMS syntax, and the file specification you pass to
  one of these routines contains a "/", they assume you are using Unix
  emulation and apply the Unix syntax rules instead, for that function
  call only.
  
  =back
  
  =cut
  
  
  BEGIN {
  
  my @Ignore_Case = qw(MacOS VMS AmigaOS OS2 RISCOS MSWin32 MSDOS DOS Epoc);
  my @Types = (@Ignore_Case, qw(Unix));
  
  sub fileparse_set_fstype {
      my $old = $Fileparse_fstype;
  
      if (@_) {
          my $new_type = shift;
  
          $Fileparse_fstype = 'Unix';  # default
          foreach my $type (@Types) {
              $Fileparse_fstype = $type if $new_type =~ /^$type/i;
          }
  
          $Fileparse_igncase = 
            (grep $Fileparse_fstype eq $_, @Ignore_Case) ? 1 : 0;
      }
  
      return $old;
  }
  
  }
  
  
  1;
  
  
  =head1 SEE ALSO
  
  L<dirname(1)>, L<basename(1)>, L<File::Spec>
FILE_BASENAME

$fatpacked{"File/CheckTree.pm"} = <<'FILE_CHECKTREE';
  package File::CheckTree;
  
  use 5.006;
  use Cwd;
  use Exporter;
  use File::Spec;
  use warnings;
  use strict;
  
  use if $] > 5.017, 'deprecate';
  
  our $VERSION = '4.42';
  our @ISA     = qw(Exporter);
  our @EXPORT  = qw(validate);
  
  =head1 NAME
  
  File::CheckTree - run many filetest checks on a tree
  
  =head1 SYNOPSIS
  
      use File::CheckTree;
  
      $num_warnings = validate( q{
          /vmunix                 -e || die
          /boot                   -e || die
          /bin                    cd
              csh                 -ex
              csh                 !-ug
              sh                  -ex
              sh                  !-ug
          /usr                    -d || warn "What happened to $file?\n"
      });
  
  =head1 DESCRIPTION
  
  The validate() routine takes a single multiline string consisting of
  directives, each containing a filename plus a file test to try on it.
  (The file test may also be a "cd", causing subsequent relative filenames
  to be interpreted relative to that directory.)  After the file test
  you may put C<|| die> to make it a fatal error if the file test fails.
  The default is C<|| warn>.  The file test may optionally have a "!' prepended
  to test for the opposite condition.  If you do a cd and then list some
  relative filenames, you may want to indent them slightly for readability.
  If you supply your own die() or warn() message, you can use $file to
  interpolate the filename.
  
  Filetests may be bunched:  "-rwx" tests for all of C<-r>, C<-w>, and C<-x>.
  Only the first failed test of the bunch will produce a warning.
  
  The routine returns the number of warnings issued.
  
  =head1 AUTHOR
  
  File::CheckTree was derived from lib/validate.pl which was
  written by Larry Wall.
  Revised by Paul Grassie <F<grassie@perl.com>> in 2002.
  
  =head1 HISTORY
  
  File::CheckTree used to not display fatal error messages.
  It used to count only those warnings produced by a generic C<|| warn>
  (and not those in which the user supplied the message).  In addition,
  the validate() routine would leave the user program in whatever
  directory was last entered through the use of "cd" directives.
  These bugs were fixed during the development of perl 5.8.
  The first fixed version of File::CheckTree was 4.2.
  
  =cut
  
  my $Warnings;
  
  sub validate {
      my ($starting_dir, $file, $test, $cwd, $oldwarnings);
  
      $starting_dir = cwd;
  
      $cwd = "";
      $Warnings = 0;
  
      foreach my $check (split /\n/, $_[0]) {
          my ($testlist, @testlist);
  
          # skip blanks/comments
          next if $check =~ /^\s*#/ || $check =~ /^\s*$/;
  
          # Todo:
          # should probably check for invalid directives and die
          # but earlier versions of File::CheckTree did not do this either
  
          # split a line like "/foo -r || die"
          # so that $file is "/foo", $test is "-r || die"
          # (making special allowance for quoted filenames).
          if ($check =~ m/^\s*"([^"]+)"\s+(.*?)\s*$/ or
              $check =~ m/^\s*'([^']+)'\s+(.*?)\s*$/ or
              $check =~ m/^\s*(\S+?)\s+(\S.*?)\s*$/)
          {
              ($file, $test) = ($1,$2);
          }
          else {
              die "Malformed line: '$check'";
          };
  
          # change a $test like "!-ug || die" to "!-Z || die",
          # capturing the bundled tests (e.g. "ug") in $2
          if ($test =~ s/ ^ (!?-) (\w{2,}) \b /$1Z/x) {
              $testlist = $2;
              # split bundled tests, e.g. "ug" to 'u', 'g'
              @testlist = split(//, $testlist);
          }
          else {
              # put in placeholder Z for stand-alone test
              @testlist = ('Z');
          }
  
          # will compare these two later to stop on 1st warning w/in a bundle
          $oldwarnings = $Warnings;
  
          foreach my $one (@testlist) {
              # examples of $test: "!-Z || die" or "-w || warn"
              my $this = $test;
  
              # expand relative $file to full pathname if preceded by cd directive
              $file = File::Spec->catfile($cwd, $file)
                      if $cwd && !File::Spec->file_name_is_absolute($file);
  
              # put filename in after the test operator
              $this =~ s/(-\w\b)/$1 "\$file"/g;
  
              # change the "-Z" representing a bundle with the $one test
              $this =~ s/-Z/-$one/;
  
              # if it's a "cd" directive...
              if ($this =~ /^cd\b/) {
                  # add "|| die ..."
                  $this .= ' || die "cannot cd to $file\n"';
                  # expand "cd" directive with directory name
                  $this =~ s/\bcd\b/chdir(\$cwd = '$file')/;
              }
              else {
                  # add "|| warn" as a default disposition
                  $this .= ' || warn' unless $this =~ /\|\|/;
  
                  # change a generic ".. || die" or ".. || warn"
                  # to call valmess instead of die/warn directly
                  # valmess will look up the error message from %Val_Message
                  $this =~ s/ ^ ( (\S+) \s+ \S+ ) \s* \|\| \s* (die|warn) \s* $
                            /$1 || valmess('$3', '$2', \$file)/x;
              }
  
              {
                  # count warnings, either from valmess or '-r || warn "my msg"'
                  # also, call any pre-existing signal handler for __WARN__
                  my $orig_sigwarn = $SIG{__WARN__};
                  local $SIG{__WARN__} = sub {
                      ++$Warnings;
                      if ( $orig_sigwarn ) {
                          $orig_sigwarn->(@_);
                      }
                      else {
                          warn "@_";
                      }
                  };
  
                  # do the test
                  eval $this;
  
                  # re-raise an exception caused by a "... || die" test
                  if (my $err = $@) {
                      # in case of any cd directives, return from whence we came
                      if ($starting_dir ne cwd) {
                          chdir($starting_dir) || die "$starting_dir: $!";
                      }
                      die $err;
                  }
              }
  
              # stop on 1st warning within a bundle of tests
              last if $Warnings > $oldwarnings;
          }
      }
  
      # in case of any cd directives, return from whence we came
      if ($starting_dir ne cwd) {
          chdir($starting_dir) || die "chdir $starting_dir: $!";
      }
  
      return $Warnings;
  }
  
  my %Val_Message = (
      'r' => "is not readable by uid $>.",
      'w' => "is not writable by uid $>.",
      'x' => "is not executable by uid $>.",
      'o' => "is not owned by uid $>.",
      'R' => "is not readable by you.",
      'W' => "is not writable by you.",
      'X' => "is not executable by you.",
      'O' => "is not owned by you.",
      'e' => "does not exist.",
      'z' => "does not have zero size.",
      's' => "does not have non-zero size.",
      'f' => "is not a plain file.",
      'd' => "is not a directory.",
      'l' => "is not a symbolic link.",
      'p' => "is not a named pipe (FIFO).",
      'S' => "is not a socket.",
      'b' => "is not a block special file.",
      'c' => "is not a character special file.",
      'u' => "does not have the setuid bit set.",
      'g' => "does not have the setgid bit set.",
      'k' => "does not have the sticky bit set.",
      'T' => "is not a text file.",
      'B' => "is not a binary file."
  );
  
  sub valmess {
      my ($disposition, $test, $file) = @_;
      my $ferror;
  
      if ($test =~ / ^ (!?) -(\w) \s* $ /x) {
          my ($neg, $ftype) = ($1, $2);
  
          $ferror = "$file $Val_Message{$ftype}";
  
          if ($neg eq '!') {
              $ferror =~ s/ is not / should not be / ||
              $ferror =~ s/ does not / should not / ||
              $ferror =~ s/ not / /;
          }
      }
      else {
          $ferror = "Can't do $test $file.\n";
      }
  
      die "$ferror\n" if $disposition eq 'die';
      warn "$ferror\n";
  }
  
  1;
FILE_CHECKTREE

$fatpacked{"File/Compare.pm"} = <<'FILE_COMPARE';
  package File::Compare;
  
  use 5.006;
  use strict;
  use warnings;
  our($VERSION, @ISA, @EXPORT, @EXPORT_OK, $Too_Big);
  
  require Exporter;
  
  $VERSION = '1.1006';
  @ISA = qw(Exporter);
  @EXPORT = qw(compare);
  @EXPORT_OK = qw(cmp compare_text);
  
  $Too_Big = 1024 * 1024 * 2;
  
  sub croak {
      require Carp;
      goto &Carp::croak;
  }
  
  sub compare {
      croak("Usage: compare( file1, file2 [, buffersize]) ")
        unless(@_ == 2 || @_ == 3);
  
      my ($from,$to,$size) = @_;
      my $text_mode = defined($size) && (ref($size) eq 'CODE' || $size < 0);
  
      my ($fromsize,$closefrom,$closeto);
      local (*FROM, *TO);
  
      croak("from undefined") unless (defined $from);
      croak("to undefined") unless (defined $to);
  
      if (ref($from) && 
          (UNIVERSAL::isa($from,'GLOB') || UNIVERSAL::isa($from,'IO::Handle'))) {
  	*FROM = *$from;
      } elsif (ref(\$from) eq 'GLOB') {
  	*FROM = $from;
      } else {
  	open(FROM,"<",$from) or goto fail_open1;
  	unless ($text_mode) {
  	    binmode FROM;
  	    $fromsize = -s FROM;
  	}
  	$closefrom = 1;
      }
  
      if (ref($to) &&
          (UNIVERSAL::isa($to,'GLOB') || UNIVERSAL::isa($to,'IO::Handle'))) {
  	*TO = *$to;
      } elsif (ref(\$to) eq 'GLOB') {
  	*TO = $to;
      } else {
  	open(TO,"<",$to) or goto fail_open2;
  	binmode TO unless $text_mode;
  	$closeto = 1;
      }
  
      if (!$text_mode && $closefrom && $closeto) {
  	# If both are opened files we know they differ if their size differ
  	goto fail_inner if $fromsize != -s TO;
      }
  
      if ($text_mode) {
  	local $/ = "\n";
  	my ($fline,$tline);
  	while (defined($fline = <FROM>)) {
  	    goto fail_inner unless defined($tline = <TO>);
  	    if (ref $size) {
  		# $size contains ref to comparison function
  		goto fail_inner if &$size($fline, $tline);
  	    } else {
  		goto fail_inner if $fline ne $tline;
  	    }
  	}
  	goto fail_inner if defined($tline = <TO>);
      }
      else {
  	unless (defined($size) && $size > 0) {
  	    $size = $fromsize || -s TO || 0;
  	    $size = 1024 if $size < 512;
  	    $size = $Too_Big if $size > $Too_Big;
  	}
  
  	my ($fr,$tr,$fbuf,$tbuf);
  	$fbuf = $tbuf = '';
  	while(defined($fr = read(FROM,$fbuf,$size)) && $fr > 0) {
  	    unless (defined($tr = read(TO,$tbuf,$fr)) && $tbuf eq $fbuf) {
  		goto fail_inner;
  	    }
  	}
  	goto fail_inner if defined($tr = read(TO,$tbuf,$size)) && $tr > 0;
      }
  
      close(TO) || goto fail_open2 if $closeto;
      close(FROM) || goto fail_open1 if $closefrom;
  
      return 0;
      
    # All of these contortions try to preserve error messages...
    fail_inner:
      close(TO) || goto fail_open2 if $closeto;
      close(FROM) || goto fail_open1 if $closefrom;
  
      return 1;
  
    fail_open2:
      if ($closefrom) {
  	my $status = $!;
  	$! = 0;
  	close FROM;
  	$! = $status unless $!;
      }
    fail_open1:
      return -1;
  }
  
  sub cmp;
  *cmp = \&compare;
  
  sub compare_text {
      my ($from,$to,$cmp) = @_;
      croak("Usage: compare_text( file1, file2 [, cmp-function])")
  	unless @_ == 2 || @_ == 3;
      croak("Third arg to compare_text() function must be a code reference")
  	if @_ == 3 && ref($cmp) ne 'CODE';
  
      # Using a negative buffer size puts compare into text_mode too
      $cmp = -1 unless defined $cmp;
      compare($from, $to, $cmp);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Compare - Compare files or filehandles
  
  =head1 SYNOPSIS
  
    	use File::Compare;
  
  	if (compare("file1","file2") == 0) {
  	    print "They're equal\n";
  	}
  
  =head1 DESCRIPTION
  
  The File::Compare::compare function compares the contents of two
  sources, each of which can be a file or a file handle.  It is exported
  from File::Compare by default.
  
  File::Compare::cmp is a synonym for File::Compare::compare.  It is
  exported from File::Compare only by request.
  
  File::Compare::compare_text does a line by line comparison of the two
  files. It stops as soon as a difference is detected. compare_text()
  accepts an optional third argument: This must be a CODE reference to
  a line comparison function, which returns 0 when both lines are considered
  equal. For example:
  
      compare_text($file1, $file2)
  
  is basically equivalent to
  
      compare_text($file1, $file2, sub {$_[0] ne $_[1]} )
  
  =head1 RETURN
  
  File::Compare::compare and its sibling functions return 0 if the files
  are equal, 1 if the files are unequal, or -1 if an error was encountered.
  
  =head1 AUTHOR
  
  File::Compare was written by Nick Ing-Simmons.
  Its original documentation was written by Chip Salzenberg.
  
  =cut
  
FILE_COMPARE

$fatpacked{"File/Copy.pm"} = <<'FILE_COPY';
  # File/Copy.pm. Written in 1994 by Aaron Sherman <ajs@ajs.com>. This
  # source code has been placed in the public domain by the author.
  # Please be kind and preserve the documentation.
  #
  # Additions copyright 1996 by Charles Bailey.  Permission is granted
  # to distribute the revised code under the same terms as Perl itself.
  
  package File::Copy;
  
  use 5.006;
  use strict;
  use warnings; no warnings 'newline';
  use File::Spec;
  use Config;
  # During perl build, we need File::Copy but Scalar::Util might not be built yet
  # And then we need these games to avoid loading overload, as that will
  # confuse miniperl during the bootstrap of perl.
  my $Scalar_Util_loaded = eval q{ require Scalar::Util; require overload; 1 };
  our(@ISA, @EXPORT, @EXPORT_OK, $VERSION, $Too_Big, $Syscopy_is_copy);
  sub copy;
  sub syscopy;
  sub cp;
  sub mv;
  
  $VERSION = '2.26';
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(copy move);
  @EXPORT_OK = qw(cp mv);
  
  $Too_Big = 1024 * 1024 * 2;
  
  sub croak {
      require Carp;
      goto &Carp::croak;
  }
  
  sub carp {
      require Carp;
      goto &Carp::carp;
  }
  
  # Look up the feature settings on VMS using VMS::Feature when available.
  
  my $use_vms_feature = 0;
  BEGIN {
      if ($^O eq 'VMS') {
          if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
              $use_vms_feature = 1;
          }
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _vms_unix_rpt {
      my $unix_rpt;
      if ($use_vms_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i;
      }
      return $unix_rpt;
  }
  
  # Need to look up the EFS character set mode.  This may become a dynamic
  # mode in the future.
  sub _vms_efs {
      my $efs;
      if ($use_vms_feature) {
          $efs = VMS::Feature::current("efs_charset");
      } else {
          my $env_efs = $ENV{'DECC$EFS_CHARSET'} || '';
          $efs = $env_efs =~ /^[ET1]/i;
      }
      return $efs;
  }
  
  
  sub _catname {
      my($from, $to) = @_;
      if (not defined &basename) {
  	require File::Basename;
  	import  File::Basename 'basename';
      }
  
      return File::Spec->catfile($to, basename($from));
  }
  
  # _eq($from, $to) tells whether $from and $to are identical
  sub _eq {
      my ($from, $to) = map {
          $Scalar_Util_loaded && Scalar::Util::blessed($_)
  	    && overload::Method($_, q{""})
              ? "$_"
              : $_
      } (@_);
      return '' if ( (ref $from) xor (ref $to) );
      return $from == $to if ref $from;
      return $from eq $to;
  }
  
  sub copy {
      croak("Usage: copy(FROM, TO [, BUFFERSIZE]) ")
        unless(@_ == 2 || @_ == 3);
  
      my $from = shift;
      my $to = shift;
  
      my $size;
      if (@_) {
  	$size = shift(@_) + 0;
  	croak("Bad buffer size for copy: $size\n") unless ($size > 0);
      }
  
      my $from_a_handle = (ref($from)
  			 ? (ref($from) eq 'GLOB'
  			    || UNIVERSAL::isa($from, 'GLOB')
                              || UNIVERSAL::isa($from, 'IO::Handle'))
  			 : (ref(\$from) eq 'GLOB'));
      my $to_a_handle =   (ref($to)
  			 ? (ref($to) eq 'GLOB'
  			    || UNIVERSAL::isa($to, 'GLOB')
                              || UNIVERSAL::isa($to, 'IO::Handle'))
  			 : (ref(\$to) eq 'GLOB'));
  
      if (_eq($from, $to)) { # works for references, too
  	carp("'$from' and '$to' are identical (not copied)");
          return 0;
      }
  
      if (!$from_a_handle && !$to_a_handle && -d $to && ! -d $from) {
  	$to = _catname($from, $to);
      }
  
      if ((($Config{d_symlink} && $Config{d_readlink}) || $Config{d_link}) &&
  	!($^O eq 'MSWin32' || $^O eq 'os2')) {
  	my @fs = stat($from);
  	if (@fs) {
  	    my @ts = stat($to);
  	    if (@ts && $fs[0] == $ts[0] && $fs[1] == $ts[1] && !-p $from) {
  		carp("'$from' and '$to' are identical (not copied)");
                  return 0;
  	    }
  	}
      }
      elsif (_eq($from, $to)) {
  	carp("'$from' and '$to' are identical (not copied)");
  	return 0;
      }
  
      if (defined &syscopy && !$Syscopy_is_copy
  	&& !$to_a_handle
  	&& !($from_a_handle && $^O eq 'os2' )	# OS/2 cannot handle handles
  	&& !($from_a_handle && $^O eq 'MSWin32')
  	&& !($from_a_handle && $^O eq 'NetWare')
         )
      {
  	my $copy_to = $to;
  
          if ($^O eq 'VMS' && -e $from) {
  
              if (! -d $to && ! -d $from) {
  
                  my $vms_efs = _vms_efs();
                  my $unix_rpt = _vms_unix_rpt();
                  my $unix_mode = 0;
                  my $from_unix = 0;
                  $from_unix = 1 if ($from =~ /^\.\.?$/);
                  my $from_vms = 0;
                  $from_vms = 1 if ($from =~ m#[\[<\]]#);
  
                  # Need to know if we are in Unix mode.
                  if ($from_vms == $from_unix) {
                      $unix_mode = $unix_rpt;
                  } else {
                      $unix_mode = $from_unix;
                  }
  
                  # VMS has sticky defaults on extensions, which means that
                  # if there is a null extension on the destination file, it
                  # will inherit the extension of the source file
                  # So add a '.' for a null extension.
  
                  # In unix_rpt mode, the trailing dot should not be added.
  
                  if ($vms_efs) {
                      $copy_to = $to;
                  } else {
                      $copy_to = VMS::Filespec::vmsify($to);
                  }
                  my ($vol, $dirs, $file) = File::Spec->splitpath($copy_to);
                  $file = $file . '.'
                      unless (($file =~ /(?<!\^)\./) || $unix_rpt);
                  $copy_to = File::Spec->catpath($vol, $dirs, $file);
  
                  # Get rid of the old versions to be like UNIX
                  1 while unlink $copy_to;
              }
          }
  
          return syscopy($from, $copy_to) || 0;
      }
  
      my $closefrom = 0;
      my $closeto = 0;
      my ($status, $r, $buf);
      local($\) = '';
  
      my $from_h;
      if ($from_a_handle) {
         $from_h = $from;
      } else {
         open $from_h, "<", $from or goto fail_open1;
         binmode $from_h or die "($!,$^E)";
         $closefrom = 1;
      }
  
      # Seems most logical to do this here, in case future changes would want to
      # make this croak for some reason.
      unless (defined $size) {
  	$size = tied(*$from_h) ? 0 : -s $from_h || 0;
  	$size = 1024 if ($size < 512);
  	$size = $Too_Big if ($size > $Too_Big);
      }
  
      my $to_h;
      if ($to_a_handle) {
         $to_h = $to;
      } else {
  	$to_h = \do { local *FH }; # XXX is this line obsolete?
  	open $to_h, ">", $to or goto fail_open2;
  	binmode $to_h or die "($!,$^E)";
  	$closeto = 1;
      }
  
      $! = 0;
      for (;;) {
  	my ($r, $w, $t);
         defined($r = sysread($from_h, $buf, $size))
  	    or goto fail_inner;
  	last unless $r;
  	for ($w = 0; $w < $r; $w += $t) {
             $t = syswrite($to_h, $buf, $r - $w, $w)
  		or goto fail_inner;
  	}
      }
  
      close($to_h) || goto fail_open2 if $closeto;
      close($from_h) || goto fail_open1 if $closefrom;
  
      # Use this idiom to avoid uninitialized value warning.
      return 1;
  
      # All of these contortions try to preserve error messages...
    fail_inner:
      if ($closeto) {
  	$status = $!;
  	$! = 0;
         close $to_h;
  	$! = $status unless $!;
      }
    fail_open2:
      if ($closefrom) {
  	$status = $!;
  	$! = 0;
         close $from_h;
  	$! = $status unless $!;
      }
    fail_open1:
      return 0;
  }
  
  sub cp {
      my($from,$to) = @_;
      my(@fromstat) = stat $from;
      my(@tostat) = stat $to;
      my $perm;
  
      return 0 unless copy(@_) and @fromstat;
  
      if (@tostat) {
          $perm = $tostat[2];
      } else {
          $perm = $fromstat[2] & ~(umask || 0);
  	@tostat = stat $to;
      }
      # Might be more robust to look for S_I* in Fcntl, but we're
      # trying to avoid dependence on any XS-containing modules,
      # since File::Copy is used during the Perl build.
      $perm &= 07777;
      if ($perm & 06000) {
  	croak("Unable to check setuid/setgid permissions for $to: $!")
  	    unless @tostat;
  
  	if ($perm & 04000 and                     # setuid
  	    $fromstat[4] != $tostat[4]) {         # owner must match
  	    $perm &= ~06000;
  	}
  
  	if ($perm & 02000 && $> != 0) {           # if not root, setgid
  	    my $ok = $fromstat[5] == $tostat[5];  # group must match
  	    if ($ok) {                            # and we must be in group
                  $ok = grep { $_ == $fromstat[5] } split /\s+/, $)
  	    }
  	    $perm &= ~06000 unless $ok;
  	}
      }
      return 0 unless @tostat;
      return 1 if $perm == ($tostat[2] & 07777);
      return eval { chmod $perm, $to; } ? 1 : 0;
  }
  
  sub _move {
      croak("Usage: move(FROM, TO) ") unless @_ == 3;
  
      my($from,$to,$fallback) = @_;
  
      my($fromsz,$tosz1,$tomt1,$tosz2,$tomt2,$sts,$ossts);
  
      if (-d $to && ! -d $from) {
  	$to = _catname($from, $to);
      }
  
      ($tosz1,$tomt1) = (stat($to))[7,9];
      $fromsz = -s $from;
      if ($^O eq 'os2' and defined $tosz1 and defined $fromsz) {
        # will not rename with overwrite
        unlink $to;
      }
  
      my $rename_to = $to;
      if (-$^O eq 'VMS' && -e $from) {
  
          if (! -d $to && ! -d $from) {
  
              my $vms_efs = _vms_efs();
              my $unix_rpt = _vms_unix_rpt();
              my $unix_mode = 0;
              my $from_unix = 0;
              $from_unix = 1 if ($from =~ /^\.\.?$/);
              my $from_vms = 0;
              $from_vms = 1 if ($from =~ m#[\[<\]]#);
  
              # Need to know if we are in Unix mode.
              if ($from_vms == $from_unix) {
                  $unix_mode = $unix_rpt;
              } else {
                  $unix_mode = $from_unix;
              }
  
              # VMS has sticky defaults on extensions, which means that
              # if there is a null extension on the destination file, it
              # will inherit the extension of the source file
              # So add a '.' for a null extension.
  
              # In unix_rpt mode, the trailing dot should not be added.
  
              if ($vms_efs) {
                  $rename_to = $to;
              } else {
                  $rename_to = VMS::Filespec::vmsify($to);
              }
              my ($vol, $dirs, $file) = File::Spec->splitpath($rename_to);
              $file = $file . '.'
                  unless (($file =~ /(?<!\^)\./) || $unix_rpt);
              $rename_to = File::Spec->catpath($vol, $dirs, $file);
  
              # Get rid of the old versions to be like UNIX
              1 while unlink $rename_to;
          }
      }
  
      return 1 if rename $from, $rename_to;
  
      # Did rename return an error even though it succeeded, because $to
      # is on a remote NFS file system, and NFS lost the server's ack?
      return 1 if defined($fromsz) && !-e $from &&           # $from disappeared
                  (($tosz2,$tomt2) = (stat($to))[7,9]) &&    # $to's there
                    ((!defined $tosz1) ||			   #  not before or
  		   ($tosz1 != $tosz2 or $tomt1 != $tomt2)) &&  #   was changed
                  $tosz2 == $fromsz;                         # it's all there
  
      ($tosz1,$tomt1) = (stat($to))[7,9];  # just in case rename did something
  
      {
          local $@;
          eval {
              local $SIG{__DIE__};
              $fallback->($from,$to) or die;
              my($atime, $mtime) = (stat($from))[8,9];
              utime($atime, $mtime, $to);
              unlink($from)   or die;
          };
          return 1 unless $@;
      }
      ($sts,$ossts) = ($! + 0, $^E + 0);
  
      ($tosz2,$tomt2) = ((stat($to))[7,9],0,0) if defined $tomt1;
      unlink($to) if !defined($tomt1) or $tomt1 != $tomt2 or $tosz1 != $tosz2;
      ($!,$^E) = ($sts,$ossts);
      return 0;
  }
  
  sub move { _move(@_,\&copy); }
  sub mv   { _move(@_,\&cp);   }
  
  # &syscopy is an XSUB under OS/2
  unless (defined &syscopy) {
      if ($^O eq 'VMS') {
  	*syscopy = \&rmscopy;
      } elsif ($^O eq 'MSWin32' && defined &DynaLoader::boot_DynaLoader) {
  	# Win32::CopyFile() fill only work if we can load Win32.xs
  	*syscopy = sub {
  	    return 0 unless @_ == 2;
  	    return Win32::CopyFile(@_, 1);
  	};
      } else {
  	$Syscopy_is_copy = 1;
  	*syscopy = \&copy;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Copy - Copy files or filehandles
  
  =head1 SYNOPSIS
  
  	use File::Copy;
  
  	copy("file1","file2") or die "Copy failed: $!";
  	copy("Copy.pm",\*STDOUT);
  	move("/dev1/fileA","/dev2/fileB");
  
  	use File::Copy "cp";
  
  	$n = FileHandle->new("/a/file","r");
  	cp($n,"x");
  
  =head1 DESCRIPTION
  
  The File::Copy module provides two basic functions, C<copy> and
  C<move>, which are useful for getting the contents of a file from
  one place to another.
  
  =over 4
  
  =item copy
  X<copy> X<cp>
  
  The C<copy> function takes two
  parameters: a file to copy from and a file to copy to. Either
  argument may be a string, a FileHandle reference or a FileHandle
  glob. Obviously, if the first argument is a filehandle of some
  sort, it will be read from, and if it is a file I<name> it will
  be opened for reading. Likewise, the second argument will be
  written to (and created if need be).  Trying to copy a file on top
  of itself is an error.
  
  If the destination (second argument) already exists and is a directory,
  and the source (first argument) is not a filehandle, then the source
  file will be copied into the directory specified by the destination,
  using the same base name as the source file.  It's a failure to have a
  filehandle as the source when the destination is a directory.
  
  B<Note that passing in
  files as handles instead of names may lead to loss of information
  on some operating systems; it is recommended that you use file
  names whenever possible.>  Files are opened in binary mode where
  applicable.  To get a consistent behaviour when copying from a
  filehandle to a file, use C<binmode> on the filehandle.
  
  An optional third parameter can be used to specify the buffer
  size used for copying. This is the number of bytes from the
  first file, that will be held in memory at any given time, before
  being written to the second file. The default buffer size depends
  upon the file, but will generally be the whole file (up to 2MB), or
  1k for filehandles that do not reference files (eg. sockets).
  
  You may use the syntax C<use File::Copy "cp"> to get at the C<cp>
  alias for this function. The syntax is I<exactly> the same.  The
  behavior is nearly the same as well: as of version 2.15, C<cp> will
  preserve the source file's permission bits like the shell utility
  C<cp(1)> would do, while C<copy> uses the default permissions for the
  target file (which may depend on the process' C<umask>, file
  ownership, inherited ACLs, etc.).  If an error occurs in setting
  permissions, C<cp> will return 0, regardless of whether the file was
  successfully copied.
  
  =item move
  X<move> X<mv> X<rename>
  
  The C<move> function also takes two parameters: the current name
  and the intended name of the file to be moved.  If the destination
  already exists and is a directory, and the source is not a
  directory, then the source file will be renamed into the directory
  specified by the destination.
  
  If possible, move() will simply rename the file.  Otherwise, it copies
  the file to the new location and deletes the original.  If an error occurs
  during this copy-and-delete process, you may be left with a (possibly partial)
  copy of the file under the destination name.
  
  You may use the C<mv> alias for this function in the same way that
  you may use the C<cp> alias for C<copy>.
  
  =item syscopy
  X<syscopy>
  
  File::Copy also provides the C<syscopy> routine, which copies the
  file specified in the first parameter to the file specified in the
  second parameter, preserving OS-specific attributes and file
  structure.  For Unix systems, this is equivalent to the simple
  C<copy> routine, which doesn't preserve OS-specific attributes.  For
  VMS systems, this calls the C<rmscopy> routine (see below).  For OS/2
  systems, this calls the C<syscopy> XSUB directly. For Win32 systems,
  this calls C<Win32::CopyFile>.
  
  B<Special behaviour if C<syscopy> is defined (OS/2, VMS and Win32)>:
  
  If both arguments to C<copy> are not file handles,
  then C<copy> will perform a "system copy" of
  the input file to a new output file, in order to preserve file
  attributes, indexed file structure, I<etc.>  The buffer size
  parameter is ignored.  If either argument to C<copy> is a
  handle to an opened file, then data is copied using Perl
  operators, and no effort is made to preserve file attributes
  or record structure.
  
  The system copy routine may also be called directly under VMS and OS/2
  as C<File::Copy::syscopy> (or under VMS as C<File::Copy::rmscopy>, which
  is the routine that does the actual work for syscopy).
  
  =item rmscopy($from,$to[,$date_flag])
  X<rmscopy>
  
  The first and second arguments may be strings, typeglobs, typeglob
  references, or objects inheriting from IO::Handle;
  they are used in all cases to obtain the
  I<filespec> of the input and output files, respectively.  The
  name and type of the input file are used as defaults for the
  output file, if necessary.
  
  A new version of the output file is always created, which
  inherits the structure and RMS attributes of the input file,
  except for owner and protections (and possibly timestamps;
  see below).  All data from the input file is copied to the
  output file; if either of the first two parameters to C<rmscopy>
  is a file handle, its position is unchanged.  (Note that this
  means a file handle pointing to the output file will be
  associated with an old version of that file after C<rmscopy>
  returns, not the newly created version.)
  
  The third parameter is an integer flag, which tells C<rmscopy>
  how to handle timestamps.  If it is E<lt> 0, none of the input file's
  timestamps are propagated to the output file.  If it is E<gt> 0, then
  it is interpreted as a bitmask: if bit 0 (the LSB) is set, then
  timestamps other than the revision date are propagated; if bit 1
  is set, the revision date is propagated.  If the third parameter
  to C<rmscopy> is 0, then it behaves much like the DCL COPY command:
  if the name or type of the output file was explicitly specified,
  then no timestamps are propagated, but if they were taken implicitly
  from the input filespec, then all timestamps other than the
  revision date are propagated.  If this parameter is not supplied,
  it defaults to 0.
  
  Like C<copy>, C<rmscopy> returns 1 on success.  If an error occurs,
  it sets C<$!>, deletes the output file, and returns 0.
  
  =back
  
  =head1 RETURN
  
  All functions return 1 on success, 0 on failure.
  $! will be set if an error was encountered.
  
  =head1 AUTHOR
  
  File::Copy was written by Aaron Sherman I<E<lt>ajs@ajs.comE<gt>> in 1995,
  and updated by Charles Bailey I<E<lt>bailey@newman.upenn.eduE<gt>> in 1996.
  
  =cut
  
FILE_COPY

$fatpacked{"File/DosGlob.pm"} = <<'FILE_DOSGLOB';
  #!perl -w
  
  #
  # Documentation at the __END__
  #
  
  package File::DosGlob;
  
  our $VERSION = '1.10';
  use strict;
  use warnings;
  
  require XSLoader;
  XSLoader::load();
  
  sub doglob {
      my $cond = shift;
      my @retval = ();
      my $fix_drive_relative_paths;
    OUTER:
      for my $pat (@_) {
  	my @matched = ();
  	my @globdirs = ();
  	my $head = '.';
  	my $sepchr = '/';
          my $tail;
  	next OUTER unless defined $pat and $pat ne '';
  	# if arg is within quotes strip em and do no globbing
  	if ($pat =~ /^"(.*)"\z/s) {
  	    $pat = $1;
  	    if ($cond eq 'd') { push(@retval, $pat) if -d $pat }
  	    else              { push(@retval, $pat) if -e $pat }
  	    next OUTER;
  	}
  	# wildcards with a drive prefix such as h:*.pm must be changed
  	# to h:./*.pm to expand correctly
  	if ($pat =~ m|^([A-Za-z]:)[^/\\]|s) {
  	    substr($pat,0,2) = $1 . "./";
  	    $fix_drive_relative_paths = 1;
  	}
  	if ($pat =~ m|^(.*)([\\/])([^\\/]*)\z|s) {
  	    ($head, $sepchr, $tail) = ($1,$2,$3);
  	    push (@retval, $pat), next OUTER if $tail eq '';
  	    if ($head =~ /[*?]/) {
  		@globdirs = doglob('d', $head);
  		push(@retval, doglob($cond, map {"$_$sepchr$tail"} @globdirs)),
  		    next OUTER if @globdirs;
  	    }
  	    $head .= $sepchr if $head eq '' or $head =~ /^[A-Za-z]:\z/s;
  	    $pat = $tail;
  	}
  	#
  	# If file component has no wildcards, we can avoid opendir
  	unless ($pat =~ /[*?]/) {
  	    $head = '' if $head eq '.';
  	    $head .= $sepchr unless $head eq '' or substr($head,-1) eq $sepchr;
  	    $head .= $pat;
  	    if ($cond eq 'd') { push(@retval,$head) if -d $head }
  	    else              { push(@retval,$head) if -e $head }
  	    next OUTER;
  	}
  	opendir(D, $head) or next OUTER;
  	my @leaves = readdir D;
  	closedir D;
  
  	# VMS-format filespecs, especially if they contain extended characters,
  	# are unlikely to match patterns correctly, so Unixify them.
  	if ($^O eq 'VMS') {
  	    require VMS::Filespec;
  	    @leaves = map {$_ =~ s/\.$//; VMS::Filespec::unixify($_)} @leaves;
          }
  	$head = '' if $head eq '.';
  	$head .= $sepchr unless $head eq '' or substr($head,-1) eq $sepchr;
  
  	# escape regex metachars but not glob chars
  	$pat =~ s:([].+^\-\${}()[|]):\\$1:g;
  	# and convert DOS-style wildcards to regex
  	$pat =~ s/\*/.*/g;
  	$pat =~ s/\?/.?/g;
  
  	my $matchsub = sub { $_[0] =~ m|^$pat\z|is };
        INNER:
  	for my $e (@leaves) {
  	    next INNER if $e eq '.' or $e eq '..';
  	    next INNER if $cond eq 'd' and ! -d "$head$e";
  	    push(@matched, "$head$e"), next INNER if &$matchsub($e);
  	    #
  	    # [DOS compatibility special case]
  	    # Failed, add a trailing dot and try again, but only
  	    # if name does not have a dot in it *and* pattern
  	    # has a dot *and* name is shorter than 9 chars.
  	    #
  	    if (index($e,'.') == -1 and length($e) < 9
  	        and index($pat,'\\.') != -1) {
  		push(@matched, "$head$e"), next INNER if &$matchsub("$e.");
  	    }
  	}
  	push @retval, @matched if @matched;
      }
      if ($fix_drive_relative_paths) {
  	s|^([A-Za-z]:)\./|$1| for @retval;
      }
      return @retval;
  }
  
  #
  # this can be used to override CORE::glob in a specific
  # package by saying C<use File::DosGlob 'glob';> in that
  # namespace.
  #
  
  # context (keyed by second cxix arg provided by core)
  our %entries;
  
  sub glob {
      my($pat,$cxix) = ($_[0], _callsite());
      my @pat;
  
      # glob without args defaults to $_
      $pat = $_ unless defined $pat;
  
      # if we're just beginning, do it all first
      if (!$entries{$cxix}) {
        # extract patterns
        if ($pat =~ /\s/) {
  	require Text::ParseWords;
  	@pat = Text::ParseWords::parse_line('\s+',0,$pat);
        }
        else {
  	push @pat, $pat;
        }
  
        # Mike Mestnik: made to do abc{1,2,3} == abc1 abc2 abc3.
        #   abc3 will be the original {3} (and drop the {}).
        #   abc1 abc2 will be put in @appendpat.
        # This was just the easiest way, not nearly the best.
        REHASH: {
  	my @appendpat = ();
  	for (@pat) {
  	    # There must be a "," I.E. abc{efg} is not what we want.
  	    while ( /^(.*)(?<!\\)\{(.*?)(?<!\\)\,.*?(?<!\\)\}(.*)$/ ) {
  		my ($start, $match, $end) = ($1, $2, $3);
  		#print "Got: \n\t$start\n\t$match\n\t$end\n";
  		my $tmp = "$start$match$end";
  		while ( $tmp =~ s/^(.*?)(?<!\\)\{(?:.*(?<!\\)\,)?(.*\Q$match\E.*?)(?:(?<!\\)\,.*)?(?<!\\)\}(.*)$/$1$2$3/ ) {
  		    #  these expansions will be performed by the original,
  		    #  when we call REHASH.
  		}
  		push @appendpat, ("$tmp");
  		s/^\Q$start\E(?<!\\)\{\Q$match\E(?<!\\)\,/$start\{/;
  		if ( /^\Q$start\E(?<!\\)\{(?!.*?(?<!\\)\,.*?\Q$end\E$)(.*)(?<!\\)\}\Q$end\E$/ ) {
  		    $match = $1;
  		    #print "GOT: \n\t$start\n\t$match\n\t$end\n\n";
  		    $_ = "$start$match$end";
  		}
  	    }
  	    #print "Sould have "GOT" vs "Got"!\n";
  		#FIXME: There should be checking for this.
  		#  How or what should be done about failure is beond me.
  	}
  	if ( $#appendpat != -1
  		) {
  	    #FIXME: Max loop, no way! :")
  	    for ( @appendpat ) {
  	        push @pat, $_;
  	    }
  	    goto REHASH;
  	}
        }
        for ( @pat ) {
  	s/\\([{},])/$1/g;
        }
   
        $entries{$cxix} = [doglob(1,@pat)];
      }
  
      # chuck it all out, quick or slow
      if (wantarray) {
  	return @{delete $entries{$cxix}};
      }
      else {
  	if (scalar @{$entries{$cxix}}) {
  	    return shift @{$entries{$cxix}};
  	}
  	else {
  	    # return undef for EOL
  	    delete $entries{$cxix};
  	    return undef;
  	}
      }
  }
  
  {
      no strict 'refs';
  
      sub import {
      my $pkg = shift;
      return unless @_;
      my $sym = shift;
      my $callpkg = ($sym =~ s/^GLOBAL_//s ? 'CORE::GLOBAL' : caller(0));
      *{$callpkg.'::'.$sym} = \&{$pkg.'::'.$sym} if $sym eq 'glob';
      }
  }
  1;
  
  __END__
  
  =head1 NAME
  
  File::DosGlob - DOS like globbing and then some
  
  =head1 SYNOPSIS
  
      require 5.004;
  
      # override CORE::glob in current package
      use File::DosGlob 'glob';
  
      # override CORE::glob in ALL packages (use with extreme caution!)
      use File::DosGlob 'GLOBAL_glob';
  
      @perlfiles = glob  "..\\pe?l/*.p?";
      print <..\\pe?l/*.p?>;
  
      # from the command line (overrides only in main::)
      > perl -MFile::DosGlob=glob -e "print <../pe*/*p?>"
  
  =head1 DESCRIPTION
  
  A module that implements DOS-like globbing with a few enhancements.
  It is largely compatible with perlglob.exe (the M$ setargv.obj
  version) in all but one respect--it understands wildcards in
  directory components.
  
  For example, C<< <..\\l*b\\file/*glob.p?> >> will work as expected (in
  that it will find something like '..\lib\File/DosGlob.pm' alright).
  Note that all path components are case-insensitive, and that
  backslashes and forward slashes are both accepted, and preserved.
  You may have to double the backslashes if you are putting them in
  literally, due to double-quotish parsing of the pattern by perl.
  
  Spaces in the argument delimit distinct patterns, so
  C<glob('*.exe *.dll')> globs all filenames that end in C<.exe>
  or C<.dll>.  If you want to put in literal spaces in the glob
  pattern, you can escape them with either double quotes, or backslashes.
  e.g. C<glob('c:/"Program Files"/*/*.dll')>, or
  C<glob('c:/Program\ Files/*/*.dll')>.  The argument is tokenized using
  C<Text::ParseWords::parse_line()>, so see L<Text::ParseWords> for details
  of the quoting rules used.
  
  Extending it to csh patterns is left as an exercise to the reader.
  
  =head1 EXPORTS (by request only)
  
  glob()
  
  =head1 BUGS
  
  Should probably be built into the core, and needs to stop
  pandering to DOS habits.  Needs a dose of optimizium too.
  
  =head1 AUTHOR
  
  Gurusamy Sarathy <gsar@activestate.com>
  
  =head1 HISTORY
  
  =over 4
  
  =item *
  
  Support for globally overriding glob() (GSAR 3-JUN-98)
  
  =item *
  
  Scalar context, independent iterator context fixes (GSAR 15-SEP-97)
  
  =item *
  
  A few dir-vs-file optimizations result in glob importation being
  10 times faster than using perlglob.exe, and using perlglob.bat is
  only twice as slow as perlglob.exe (GSAR 28-MAY-97)
  
  =item *
  
  Several cleanups prompted by lack of compatible perlglob.exe
  under Borland (GSAR 27-MAY-97)
  
  =item *
  
  Initial version (GSAR 20-FEB-97)
  
  =back
  
  =head1 SEE ALSO
  
  perl
  
  perlglob.bat
  
  Text::ParseWords
  
  =cut
  
FILE_DOSGLOB

$fatpacked{"File/Fetch.pm"} = <<'FILE_FETCH';
  package File::Fetch;
  
  use strict;
  use FileHandle;
  use File::Temp;
  use File::Copy;
  use File::Spec;
  use File::Spec::Unix;
  use File::Basename              qw[dirname];
  
  use Cwd                         qw[cwd];
  use Carp                        qw[carp];
  use IPC::Cmd                    qw[can_run run QUOTE];
  use File::Path                  qw[mkpath];
  use File::Temp                  qw[tempdir];
  use Params::Check               qw[check];
  use Module::Load::Conditional   qw[can_load];
  use Locale::Maketext::Simple    Style => 'gettext';
  
  use vars    qw[ $VERBOSE $PREFER_BIN $FROM_EMAIL $USER_AGENT
                  $BLACKLIST $METHOD_FAIL $VERSION $METHODS
                  $FTP_PASSIVE $TIMEOUT $DEBUG $WARN
              ];
  
  $VERSION        = '0.38';
  $VERSION        = eval $VERSION;    # avoid warnings with development releases
  $PREFER_BIN     = 0;                # XXX TODO implement
  $FROM_EMAIL     = 'File-Fetch@example.com';
  $USER_AGENT     = "File::Fetch/$VERSION";
  $BLACKLIST      = [qw|ftp|];
  $METHOD_FAIL    = { };
  $FTP_PASSIVE    = 1;
  $TIMEOUT        = 0;
  $DEBUG          = 0;
  $WARN           = 1;
  
  ### methods available to fetch the file depending on the scheme
  $METHODS = {
      http    => [ qw|lwp httptiny wget curl lftp fetch httplite lynx iosock| ],
      ftp     => [ qw|lwp netftp wget curl lftp fetch ncftp ftp| ],
      file    => [ qw|lwp lftp file| ],
      rsync   => [ qw|rsync| ]
  };
  
  ### silly warnings ###
  local $Params::Check::VERBOSE               = 1;
  local $Params::Check::VERBOSE               = 1;
  local $Module::Load::Conditional::VERBOSE   = 0;
  local $Module::Load::Conditional::VERBOSE   = 0;
  
  ### see what OS we are on, important for file:// uris ###
  use constant ON_WIN     => ($^O eq 'MSWin32');
  use constant ON_VMS     => ($^O eq 'VMS');
  use constant ON_UNIX    => (!ON_WIN);
  use constant HAS_VOL    => (ON_WIN);
  use constant HAS_SHARE  => (ON_WIN);
  use constant HAS_FETCH  => ( $^O =~ m!^(freebsd|netbsd|dragonfly)$! );
  
  =pod
  
  =head1 NAME
  
  File::Fetch - A generic file fetching mechanism
  
  =head1 SYNOPSIS
  
      use File::Fetch;
  
      ### build a File::Fetch object ###
      my $ff = File::Fetch->new(uri => 'http://some.where.com/dir/a.txt');
  
      ### fetch the uri to cwd() ###
      my $where = $ff->fetch() or die $ff->error;
  
      ### fetch the uri to /tmp ###
      my $where = $ff->fetch( to => '/tmp' );
  
      ### parsed bits from the uri ###
      $ff->uri;
      $ff->scheme;
      $ff->host;
      $ff->path;
      $ff->file;
  
  =head1 DESCRIPTION
  
  File::Fetch is a generic file fetching mechanism.
  
  It allows you to fetch any file pointed to by a C<ftp>, C<http>,
  C<file>, or C<rsync> uri by a number of different means.
  
  See the C<HOW IT WORKS> section further down for details.
  
  =head1 ACCESSORS
  
  A C<File::Fetch> object has the following accessors
  
  =over 4
  
  =item $ff->uri
  
  The uri you passed to the constructor
  
  =item $ff->scheme
  
  The scheme from the uri (like 'file', 'http', etc)
  
  =item $ff->host
  
  The hostname in the uri.  Will be empty if host was originally
  'localhost' for a 'file://' url.
  
  =item $ff->vol
  
  On operating systems with the concept of a volume the second element
  of a file:// is considered to the be volume specification for the file.
  Thus on Win32 this routine returns the volume, on other operating
  systems this returns nothing.
  
  On Windows this value may be empty if the uri is to a network share, in
  which case the 'share' property will be defined. Additionally, volume
  specifications that use '|' as ':' will be converted on read to use ':'.
  
  On VMS, which has a volume concept, this field will be empty because VMS
  file specifications are converted to absolute UNIX format and the volume
  information is transparently included.
  
  =item $ff->share
  
  On systems with the concept of a network share (currently only Windows) returns
  the sharename from a file://// url.  On other operating systems returns empty.
  
  =item $ff->path
  
  The path from the uri, will be at least a single '/'.
  
  =item $ff->file
  
  The name of the remote file. For the local file name, the
  result of $ff->output_file will be used.
  
  =item $ff->file_default
  
  The name of the default local file, that $ff->output_file falls back to if
  it would otherwise return no filename. For example when fetching a URI like
  http://www.abc.net.au/ the contents retrieved may be from a remote file called
  'index.html'. The default value of this attribute is literally 'file_default'.
  
  =cut
  
  
  ##########################
  ### Object & Accessors ###
  ##########################
  
  {
      ### template for autogenerated accessors ###
      my $Tmpl = {
          scheme          => { default => 'http' },
          host            => { default => 'localhost' },
          path            => { default => '/' },
          file            => { required => 1 },
          uri             => { required => 1 },
          vol             => { default => '' }, # windows for file:// uris
          share           => { default => '' }, # windows for file:// uris
          file_default    => { default => 'file_default' },
          tempdir_root    => { required => 1 }, # Should be lazy-set at ->new()
          _error_msg      => { no_override => 1 },
          _error_msg_long => { no_override => 1 },
      };
  
      for my $method ( keys %$Tmpl ) {
          no strict 'refs';
          *$method = sub {
                          my $self = shift;
                          $self->{$method} = $_[0] if @_;
                          return $self->{$method};
                      }
      }
  
      sub _create {
          my $class = shift;
          my %hash  = @_;
  
          my $args = check( $Tmpl, \%hash ) or return;
  
          bless $args, $class;
  
          if( lc($args->scheme) ne 'file' and not $args->host ) {
              return $class->_error(loc(
                  "Hostname required when fetching from '%1'",$args->scheme));
          }
  
          for (qw[path]) {
              unless( $args->$_() ) { # 5.5.x needs the ()
                  return $class->_error(loc("No '%1' specified",$_));
              }
          }
  
          return $args;
      }
  }
  
  =item $ff->output_file
  
  The name of the output file. This is the same as $ff->file,
  but any query parameters are stripped off. For example:
  
      http://example.com/index.html?x=y
  
  would make the output file be C<index.html> rather than
  C<index.html?x=y>.
  
  =back
  
  =cut
  
  sub output_file {
      my $self = shift;
      my $file = $self->file;
  
      $file =~ s/\?.*$//g;
  
      $file ||= $self->file_default;
  
      return $file;
  }
  
  ### XXX do this or just point to URI::Escape?
  # =head2 $esc_uri = $ff->escaped_uri
  #
  # =cut
  #
  # ### most of this is stolen straight from URI::escape
  # {   ### Build a char->hex map
  #     my %escapes = map { chr($_) => sprintf("%%%02X", $_) } 0..255;
  #
  #     sub escaped_uri {
  #         my $self = shift;
  #         my $uri  = $self->uri;
  #
  #         ### Default unsafe characters.  RFC 2732 ^(uric - reserved)
  #         $uri =~ s/([^A-Za-z0-9\-_.!~*'()])/
  #                     $escapes{$1} || $self->_fail_hi($1)/ge;
  #
  #         return $uri;
  #     }
  #
  #     sub _fail_hi {
  #         my $self = shift;
  #         my $char = shift;
  #
  #         $self->_error(loc(
  #             "Can't escape '%1', try using the '%2' module instead",
  #             sprintf("\\x{%04X}", ord($char)), 'URI::Escape'
  #         ));
  #     }
  #
  #     sub output_file {
  #
  #     }
  #
  #
  # }
  
  =head1 METHODS
  
  =head2 $ff = File::Fetch->new( uri => 'http://some.where.com/dir/file.txt' );
  
  Parses the uri and creates a corresponding File::Fetch::Item object,
  that is ready to be C<fetch>ed and returns it.
  
  Returns false on failure.
  
  =cut
  
  sub new {
      my $class = shift;
      my %hash  = @_;
  
      my ($uri, $file_default, $tempdir_root);
      my $tmpl = {
          uri          => { required => 1, store => \$uri },
          file_default => { required => 0, store => \$file_default },
          tempdir_root => { required => 0, store => \$tempdir_root },
      };
  
      check( $tmpl, \%hash ) or return;
  
      ### parse the uri to usable parts ###
      my $href    = $class->_parse_uri( $uri ) or return;
  
      $href->{file_default} = $file_default if $file_default;
      $href->{tempdir_root} = File::Spec->rel2abs( $tempdir_root ) if $tempdir_root;
      $href->{tempdir_root} = File::Spec->rel2abs( Cwd::cwd      ) if not $href->{tempdir_root};
  
      ### make it into a FFI object ###
      my $ff      = $class->_create( %$href ) or return;
  
  
      ### return the object ###
      return $ff;
  }
  
  ### parses an uri to a hash structure:
  ###
  ### $class->_parse_uri( 'ftp://ftp.cpan.org/pub/mirror/index.txt' )
  ###
  ### becomes:
  ###
  ### $href = {
  ###     scheme  => 'ftp',
  ###     host    => 'ftp.cpan.org',
  ###     path    => '/pub/mirror',
  ###     file    => 'index.html'
  ### };
  ###
  ### In the case of file:// urls there maybe be additional fields
  ###
  ### For systems with volume specifications such as Win32 there will be
  ### a volume specifier provided in the 'vol' field.
  ###
  ###   'vol' => 'volumename'
  ###
  ### For windows file shares there may be a 'share' key specified
  ###
  ###   'share' => 'sharename'
  ###
  ### Note that the rules of what a file:// url means vary by the operating system
  ### of the host being addressed. Thus file:///d|/foo/bar.txt means the obvious
  ### 'D:\foo\bar.txt' on windows, but on unix it means '/d|/foo/bar.txt' and
  ### not '/foo/bar.txt'
  ###
  ### Similarly if the host interpreting the url is VMS then
  ### file:///disk$user/my/notes/note12345.txt' means
  ### 'DISK$USER:[MY.NOTES]NOTE123456.TXT' but will be returned the same as
  ### if it is unix where it means /disk$user/my/notes/note12345.txt'.
  ### Except for some cases in the File::Spec methods, Perl on VMS will generally
  ### handle UNIX format file specifications.
  ###
  ### This means it is impossible to serve certain file:// urls on certain systems.
  ###
  ### Thus are the problems with a protocol-less specification. :-(
  ###
  
  sub _parse_uri {
      my $self = shift;
      my $uri  = shift or return;
  
      my $href = { uri => $uri };
  
      ### find the scheme ###
      $uri            =~ s|^(\w+)://||;
      $href->{scheme} = $1;
  
      ### See rfc 1738 section 3.10
      ### http://www.faqs.org/rfcs/rfc1738.html
      ### And wikipedia for more on windows file:// urls
      ### http://en.wikipedia.org/wiki/File://
      if( $href->{scheme} eq 'file' ) {
  
          my @parts = split '/',$uri;
  
          ### file://hostname/...
          ### file://hostname/...
          ### normalize file://localhost with file:///
          $href->{host} = $parts[0] || '';
  
          ### index in @parts where the path components begin;
          my $index = 1;
  
          ### file:////hostname/sharename/blah.txt
          if ( HAS_SHARE and not length $parts[0] and not length $parts[1] ) {
  
              $href->{host}   = $parts[2] || '';  # avoid warnings
              $href->{share}  = $parts[3] || '';  # avoid warnings
  
              $index          = 4         # index after the share
  
          ### file:///D|/blah.txt
          ### file:///D:/blah.txt
          } elsif (HAS_VOL) {
  
              ### this code comes from dmq's patch, but:
              ### XXX if volume is empty, wouldn't that be an error? --kane
              ### if so, our file://localhost test needs to be fixed as wel
              $href->{vol}    = $parts[1] || '';
  
              ### correct D| style colume descriptors
              $href->{vol}    =~ s/\A([A-Z])\|\z/$1:/i if ON_WIN;
  
              $index          = 2;        # index after the volume
          }
  
          ### rebuild the path from the leftover parts;
          $href->{path} = join '/', '', splice( @parts, $index, $#parts );
  
      } else {
          ### using anything but qw() in hash slices may produce warnings
          ### in older perls :-(
          @{$href}{ qw(host path) } = $uri =~ m|([^/]*)(/.*)$|s;
      }
  
      ### split the path into file + dir ###
      {   my @parts = File::Spec::Unix->splitpath( delete $href->{path} );
          $href->{path} = $parts[1];
          $href->{file} = $parts[2];
      }
  
      ### host will be empty if the target was 'localhost' and the
      ### scheme was 'file'
      $href->{host} = '' if   ($href->{host}      eq 'localhost') and
                              ($href->{scheme}    eq 'file');
  
      return $href;
  }
  
  =head2 $where = $ff->fetch( [to => /my/output/dir/ | \$scalar] )
  
  Fetches the file you requested and returns the full path to the file.
  
  By default it writes to C<cwd()>, but you can override that by specifying
  the C<to> argument:
  
      ### file fetch to /tmp, full path to the file in $where
      $where = $ff->fetch( to => '/tmp' );
  
      ### file slurped into $scalar, full path to the file in $where
      ### file is downloaded to a temp directory and cleaned up at exit time
      $where = $ff->fetch( to => \$scalar );
  
  Returns the full path to the downloaded file on success, and false
  on failure.
  
  =cut
  
  sub fetch {
      my $self = shift or return;
      my %hash = @_;
  
      my $target;
      my $tmpl = {
          to  => { default => cwd(), store => \$target },
      };
  
      check( $tmpl, \%hash ) or return;
  
      my ($to, $fh);
      ### you want us to slurp the contents
      if( ref $target and UNIVERSAL::isa( $target, 'SCALAR' ) ) {
          $to = tempdir( 'FileFetch.XXXXXX', DIR => $self->tempdir_root, CLEANUP => 1 );
  
      ### plain old fetch
      } else {
          $to = $target;
  
          ### On VMS force to VMS format so File::Spec will work.
          $to = VMS::Filespec::vmspath($to) if ON_VMS;
  
          ### create the path if it doesn't exist yet ###
          unless( -d $to ) {
              eval { mkpath( $to ) };
  
              return $self->_error(loc("Could not create path '%1'",$to)) if $@;
          }
      }
  
      ### set passive ftp if required ###
      local $ENV{FTP_PASSIVE} = $FTP_PASSIVE;
  
      ### we dont use catfile on win32 because if we are using a cygwin tool
      ### under cmd.exe they wont understand windows style separators.
      my $out_to = ON_WIN ? $to.'/'.$self->output_file
                          : File::Spec->catfile( $to, $self->output_file );
  
      for my $method ( @{ $METHODS->{$self->scheme} } ) {
          my $sub =  '_'.$method.'_fetch';
  
          unless( __PACKAGE__->can($sub) ) {
              $self->_error(loc("Cannot call method for '%1' -- WEIRD!",
                          $method));
              next;
          }
  
          ### method is blacklisted ###
          next if grep { lc $_ eq $method } @$BLACKLIST;
  
          ### method is known to fail ###
          next if $METHOD_FAIL->{$method};
  
          ### there's serious issues with IPC::Run and quoting of command
          ### line arguments. using quotes in the wrong place breaks things,
          ### and in the case of say,
          ### C:\cygwin\bin\wget.EXE --quiet --passive-ftp --output-document
          ### "index.html" "http://www.cpan.org/index.html?q=1&y=2"
          ### it doesn't matter how you quote, it always fails.
          local $IPC::Cmd::USE_IPC_RUN = 0;
  
          if( my $file = $self->$sub(
                          to => $out_to
          )){
  
              unless( -e $file && -s _ ) {
                  $self->_error(loc("'%1' said it fetched '%2', ".
                       "but it was not created",$method,$file));
  
                  ### mark the failure ###
                  $METHOD_FAIL->{$method} = 1;
  
                  next;
  
              } else {
  
                  ### slurp mode?
                  if( ref $target and UNIVERSAL::isa( $target, 'SCALAR' ) ) {
  
                      ### open the file
                      open my $fh, "<$file" or do {
                          $self->_error(
                              loc("Could not open '%1': %2", $file, $!));
                          return;
                      };
  
                      ### slurp
                      $$target = do { local $/; <$fh> };
  
                  }
  
                  my $abs = File::Spec->rel2abs( $file );
                  return $abs;
  
              }
          }
      }
  
  
      ### if we got here, we looped over all methods, but we weren't able
      ### to fetch it.
      return;
  }
  
  ########################
  ### _*_fetch methods ###
  ########################
  
  ### LWP fetching ###
  sub _lwp_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
      ### modules required to download with lwp ###
      my $use_list = {
          LWP                 => '0.0',
          'LWP::UserAgent'    => '0.0',
          'HTTP::Request'     => '0.0',
          'HTTP::Status'      => '0.0',
          URI                 => '0.0',
  
      };
  
      unless( can_load( modules => $use_list ) ) {
          $METHOD_FAIL->{'lwp'} = 1;
          return;
      }
  
      ### setup the uri object
      my $uri = URI->new( File::Spec::Unix->catfile(
                                  $self->path, $self->file
                      ) );
  
      ### special rules apply for file:// uris ###
      $uri->scheme( $self->scheme );
      $uri->host( $self->scheme eq 'file' ? '' : $self->host );
      $uri->userinfo("anonymous:$FROM_EMAIL") if $self->scheme ne 'file';
  
      ### set up the useragent object
      my $ua = LWP::UserAgent->new();
      $ua->timeout( $TIMEOUT ) if $TIMEOUT;
      $ua->agent( $USER_AGENT );
      $ua->from( $FROM_EMAIL );
      $ua->env_proxy;
  
      my $res = $ua->mirror($uri, $to) or return;
  
      ### uptodate or fetched ok ###
      if ( $res->code == 304 or $res->code == 200 ) {
          return $to;
  
      } else {
          return $self->_error(loc("Fetch failed! HTTP response: %1 %2 [%3]",
                      $res->code, HTTP::Status::status_message($res->code),
                      $res->status_line));
      }
  
  }
  
  ### HTTP::Tiny fetching ###
  sub _httptiny_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
      my $use_list = {
          'HTTP::Tiny'    => '0.008',
  
      };
  
      unless( can_load(modules => $use_list) ) {
          $METHOD_FAIL->{'httptiny'} = 1;
          return;
      }
  
      my $uri = $self->uri;
  
      my $http = HTTP::Tiny->new( ( $TIMEOUT ? ( timeout => $TIMEOUT ) : () ) );
  
      my $rc = $http->mirror( $uri, $to );
  
      unless ( $rc->{success} ) {
  
          return $self->_error(loc( "Fetch failed! HTTP response: %1 [%2]",
                      $rc->{status}, $rc->{reason} ) );
  
      }
  
      return $to;
  
  }
  
  ### HTTP::Lite fetching ###
  sub _httplite_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
      ### modules required to download with lwp ###
      my $use_list = {
          'HTTP::Lite'    => '2.2',
  
      };
  
      unless( can_load(modules => $use_list) ) {
          $METHOD_FAIL->{'httplite'} = 1;
          return;
      }
  
      my $uri = $self->uri;
      my $retries = 0;
  
      RETRIES: while ( $retries++ < 5 ) {
  
        my $http = HTTP::Lite->new();
        # Naughty naughty but there isn't any accessor/setter
        $http->{timeout} = $TIMEOUT if $TIMEOUT;
        $http->http11_mode(1);
  
        my $fh = FileHandle->new;
  
        unless ( $fh->open($to,'>') ) {
          return $self->_error(loc(
               "Could not open '%1' for writing: %2",$to,$!));
        }
  
        $fh->autoflush(1);
  
        binmode $fh;
  
        my $rc = $http->request( $uri, sub { my ($self,$dref,$cbargs) = @_; local $\; print {$cbargs} $$dref }, $fh );
  
        close $fh;
  
        if ( $rc == 301 || $rc == 302 ) {
            my $loc;
            HEADERS: for ($http->headers_array) {
              /Location: (\S+)/ and $loc = $1, last HEADERS;
            }
            #$loc or last; # Think we should squeal here.
            if ($loc =~ m!^/!) {
              $uri =~ s{^(\w+?://[^/]+)/.*$}{$1};
              $uri .= $loc;
            }
            else {
              $uri = $loc;
            }
            next RETRIES;
        }
        elsif ( $rc == 200 ) {
            return $to;
        }
        else {
          return $self->_error(loc("Fetch failed! HTTP response: %1 [%2]",
                      $rc, $http->status_message));
        }
  
      } # Loop for 5 retries.
  
      return $self->_error("Fetch failed! Gave up after 5 tries");
  
  }
  
  ### Simple IO::Socket::INET fetching ###
  sub _iosock_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
      my $use_list = {
          'IO::Socket::INET' => '0.0',
          'IO::Select'       => '0.0',
      };
  
      unless( can_load(modules => $use_list) ) {
          $METHOD_FAIL->{'iosock'} = 1;
          return;
      }
  
      my $sock = IO::Socket::INET->new(
          PeerHost => $self->host,
          ( $self->host =~ /:/ ? () : ( PeerPort => 80 ) ),
      );
  
      unless ( $sock ) {
          return $self->_error(loc("Could not open socket to '%1', '%2'",$self->host,$!));
      }
  
      my $fh = FileHandle->new;
  
      # Check open()
  
      unless ( $fh->open($to,'>') ) {
          return $self->_error(loc(
               "Could not open '%1' for writing: %2",$to,$!));
      }
  
      $fh->autoflush(1);
      binmode $fh;
  
      my $path = File::Spec::Unix->catfile( $self->path, $self->file );
      my $req = "GET $path HTTP/1.0\x0d\x0aHost: " . $self->host . "\x0d\x0a\x0d\x0a";
      $sock->send( $req );
  
      my $select = IO::Select->new( $sock );
  
      my $resp = '';
      my $normal = 0;
      while ( $select->can_read( $TIMEOUT || 60 ) ) {
        my $ret = $sock->sysread( $resp, 4096, length($resp) );
        if ( !defined $ret or $ret == 0 ) {
          $select->remove( $sock );
          $normal++;
        }
      }
      close $sock;
  
      unless ( $normal ) {
          return $self->_error(loc("Socket timed out after '%1' seconds", ( $TIMEOUT || 60 )));
      }
  
      # Check the "response"
      # Strip preceding blank lines apparently they are allowed (RFC 2616 4.1)
      $resp =~ s/^(\x0d?\x0a)+//;
      # Check it is an HTTP response
      unless ( $resp =~ m!^HTTP/(\d+)\.(\d+)!i ) {
          return $self->_error(loc("Did not get a HTTP response from '%1'",$self->host));
      }
  
      # Check for OK
      my ($code) = $resp =~ m!^HTTP/\d+\.\d+\s+(\d+)!i;
      unless ( $code eq '200' ) {
          return $self->_error(loc("Got a '%1' from '%2' expected '200'",$code,$self->host));
      }
  
      {
        local $\;
        print $fh +($resp =~ m/\x0d\x0a\x0d\x0a(.*)$/s )[0];
      }
      close $fh;
      return $to;
  }
  
  ### Net::FTP fetching
  sub _netftp_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
      ### required modules ###
      my $use_list = { 'Net::FTP' => 0 };
  
      unless( can_load( modules => $use_list ) ) {
          $METHOD_FAIL->{'netftp'} = 1;
          return;
      }
  
      ### make connection ###
      my $ftp;
      my @options = ($self->host);
      push(@options, Timeout => $TIMEOUT) if $TIMEOUT;
      unless( $ftp = Net::FTP->new( @options ) ) {
          return $self->_error(loc("Ftp creation failed: %1",$@));
      }
  
      ### login ###
      unless( $ftp->login( anonymous => $FROM_EMAIL ) ) {
          return $self->_error(loc("Could not login to '%1'",$self->host));
      }
  
      ### set binary mode, just in case ###
      $ftp->binary;
  
      ### create the remote path
      ### remember remote paths are unix paths! [#11483]
      my $remote = File::Spec::Unix->catfile( $self->path, $self->file );
  
      ### fetch the file ###
      my $target;
      unless( $target = $ftp->get( $remote, $to ) ) {
          return $self->_error(loc("Could not fetch '%1' from '%2'",
                      $remote, $self->host));
      }
  
      ### log out ###
      $ftp->quit;
  
      return $target;
  
  }
  
  ### /bin/wget fetch ###
  sub _wget_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
      my $wget;
      ### see if we have a wget binary ###
      unless( $wget = can_run('wget') ) {
          $METHOD_FAIL->{'wget'} = 1;
          return;
      }
  
      ### no verboseness, thanks ###
      my $cmd = [ $wget, '--quiet' ];
  
      ### if a timeout is set, add it ###
      push(@$cmd, '--timeout=' . $TIMEOUT) if $TIMEOUT;
  
      ### run passive if specified ###
      push @$cmd, '--passive-ftp' if $FTP_PASSIVE;
  
      ### set the output document, add the uri ###
      push @$cmd, '--output-document', $to, $self->uri;
  
      ### with IPC::Cmd > 0.41, this is fixed in teh library,
      ### and there's no need for special casing any more.
      ### DO NOT quote things for IPC::Run, it breaks stuff.
      # $IPC::Cmd::USE_IPC_RUN
      #    ? ($to, $self->uri)
      #    : (QUOTE. $to .QUOTE, QUOTE. $self->uri .QUOTE);
  
      ### shell out ###
      my $captured;
      unless(run( command => $cmd,
                  buffer  => \$captured,
                  verbose => $DEBUG
      )) {
          ### wget creates the output document always, even if the fetch
          ### fails.. so unlink it in that case
          1 while unlink $to;
  
          return $self->_error(loc( "Command failed: %1", $captured || '' ));
      }
  
      return $to;
  }
  
  ### /bin/lftp fetch ###
  sub _lftp_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
      ### see if we have a lftp binary ###
      my $lftp;
      unless( $lftp = can_run('lftp') ) {
          $METHOD_FAIL->{'lftp'} = 1;
          return;
      }
  
      ### no verboseness, thanks ###
      my $cmd = [ $lftp, '-f' ];
  
      my $fh = File::Temp->new;
  
      my $str;
  
      ### if a timeout is set, add it ###
      $str .= "set net:timeout $TIMEOUT;\n" if $TIMEOUT;
  
      ### run passive if specified ###
      $str .= "set ftp:passive-mode 1;\n" if $FTP_PASSIVE;
  
      ### set the output document, add the uri ###
      ### quote the URI, because lftp supports certain shell
      ### expansions, most notably & for backgrounding.
      ### ' quote does nto work, must be "
      $str .= q[get ']. $self->uri .q[' -o ]. $to . $/;
  
      if( $DEBUG ) {
          my $pp_str = join ' ', split $/, $str;
          print "# lftp command: $pp_str\n";
      }
  
      ### write straight to the file.
      $fh->autoflush(1);
      print $fh $str;
  
      ### the command needs to be 1 string to be executed
      push @$cmd, $fh->filename;
  
      ### with IPC::Cmd > 0.41, this is fixed in teh library,
      ### and there's no need for special casing any more.
      ### DO NOT quote things for IPC::Run, it breaks stuff.
      # $IPC::Cmd::USE_IPC_RUN
      #    ? ($to, $self->uri)
      #    : (QUOTE. $to .QUOTE, QUOTE. $self->uri .QUOTE);
  
  
      ### shell out ###
      my $captured;
      unless(run( command => $cmd,
                  buffer  => \$captured,
                  verbose => $DEBUG
      )) {
          ### wget creates the output document always, even if the fetch
          ### fails.. so unlink it in that case
          1 while unlink $to;
  
          return $self->_error(loc( "Command failed: %1", $captured || '' ));
      }
  
      return $to;
  }
  
  
  
  ### /bin/ftp fetch ###
  sub _ftp_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
      ### see if we have a ftp binary ###
      my $ftp;
      unless( $ftp = can_run('ftp') ) {
          $METHOD_FAIL->{'ftp'} = 1;
          return;
      }
  
      my $fh = FileHandle->new;
  
      local $SIG{CHLD} = 'IGNORE';
  
      unless ($fh->open("$ftp -n", '|-')) {
          return $self->_error(loc("%1 creation failed: %2", $ftp, $!));
      }
  
      my @dialog = (
          "lcd " . dirname($to),
          "open " . $self->host,
          "user anonymous $FROM_EMAIL",
          "cd /",
          "cd " . $self->path,
          "binary",
          "get " . $self->file . " " . $self->output_file,
          "quit",
      );
  
      foreach (@dialog) { $fh->print($_, "\n") }
      $fh->close or return;
  
      return $to;
  }
  
  ### lynx is stupid - it decompresses any .gz file it finds to be text
  ### use /bin/lynx to fetch files
  sub _lynx_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
      ### see if we have a lynx binary ###
      my $lynx;
      unless ( $lynx = can_run('lynx') ){
          $METHOD_FAIL->{'lynx'} = 1;
          return;
      }
  
      unless( IPC::Cmd->can_capture_buffer ) {
          $METHOD_FAIL->{'lynx'} = 1;
  
          return $self->_error(loc(
              "Can not capture buffers. Can not use '%1' to fetch files",
              'lynx' ));
      }
  
      ### check if the HTTP resource exists ###
      if ($self->uri =~ /^https?:\/\//i) {
          my $cmd = [
              $lynx,
              '-head',
              '-source',
              "-auth=anonymous:$FROM_EMAIL",
          ];
  
          push @$cmd, "-connect_timeout=$TIMEOUT" if $TIMEOUT;
  
          push @$cmd, $self->uri;
  
          ### shell out ###
          my $head;
          unless(run( command => $cmd,
                      buffer  => \$head,
                      verbose => $DEBUG )
          ) {
              return $self->_error(loc("Command failed: %1", $head || ''));
          }
  
          unless($head =~ /^HTTP\/\d+\.\d+ 200\b/) {
              return $self->_error(loc("Command failed: %1", $head || ''));
          }
      }
  
      ### write to the output file ourselves, since lynx ass_u_mes to much
      my $local = FileHandle->new( $to, 'w' )
                      or return $self->_error(loc(
                          "Could not open '%1' for writing: %2",$to,$!));
  
      ### dump to stdout ###
      my $cmd = [
          $lynx,
          '-source',
          "-auth=anonymous:$FROM_EMAIL",
      ];
  
      push @$cmd, "-connect_timeout=$TIMEOUT" if $TIMEOUT;
  
      ### DO NOT quote things for IPC::Run, it breaks stuff.
      push @$cmd, $self->uri;
  
      ### with IPC::Cmd > 0.41, this is fixed in teh library,
      ### and there's no need for special casing any more.
      ### DO NOT quote things for IPC::Run, it breaks stuff.
      # $IPC::Cmd::USE_IPC_RUN
      #    ? $self->uri
      #    : QUOTE. $self->uri .QUOTE;
  
  
      ### shell out ###
      my $captured;
      unless(run( command => $cmd,
                  buffer  => \$captured,
                  verbose => $DEBUG )
      ) {
          return $self->_error(loc("Command failed: %1", $captured || ''));
      }
  
      ### print to local file ###
      ### XXX on a 404 with a special error page, $captured will actually
      ### hold the contents of that page, and make it *appear* like the
      ### request was a success, when really it wasn't :(
      ### there doesn't seem to be an option for lynx to change the exit
      ### code based on a 4XX status or so.
      ### the closest we can come is using --error_file and parsing that,
      ### which is very unreliable ;(
      $local->print( $captured );
      $local->close or return;
  
      return $to;
  }
  
  ### use /bin/ncftp to fetch files
  sub _ncftp_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
      ### we can only set passive mode in interactive sessions, so bail out
      ### if $FTP_PASSIVE is set
      return if $FTP_PASSIVE;
  
      ### see if we have a ncftp binary ###
      my $ncftp;
      unless( $ncftp = can_run('ncftp') ) {
          $METHOD_FAIL->{'ncftp'} = 1;
          return;
      }
  
      my $cmd = [
          $ncftp,
          '-V',                   # do not be verbose
          '-p', $FROM_EMAIL,      # email as password
          $self->host,            # hostname
          dirname($to),           # local dir for the file
                                  # remote path to the file
          ### DO NOT quote things for IPC::Run, it breaks stuff.
          $IPC::Cmd::USE_IPC_RUN
                      ? File::Spec::Unix->catdir( $self->path, $self->file )
                      : QUOTE. File::Spec::Unix->catdir(
                                      $self->path, $self->file ) .QUOTE
  
      ];
  
      ### shell out ###
      my $captured;
      unless(run( command => $cmd,
                  buffer  => \$captured,
                  verbose => $DEBUG )
      ) {
          return $self->_error(loc("Command failed: %1", $captured || ''));
      }
  
      return $to;
  
  }
  
  ### use /bin/curl to fetch files
  sub _curl_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
      my $curl;
      unless ( $curl = can_run('curl') ) {
          $METHOD_FAIL->{'curl'} = 1;
          return;
      }
  
      ### these long opts are self explanatory - I like that -jmb
      my $cmd = [ $curl, '-q' ];
  
      push(@$cmd, '--connect-timeout', $TIMEOUT) if $TIMEOUT;
  
      push(@$cmd, '--silent') unless $DEBUG;
  
      ### curl does the right thing with passive, regardless ###
      if ($self->scheme eq 'ftp') {
          push(@$cmd, '--user', "anonymous:$FROM_EMAIL");
      }
  
      ### curl doesn't follow 302 (temporarily moved) etc automatically
      ### so we add --location to enable that.
      push @$cmd, '--fail', '--location', '--output', $to, $self->uri;
  
      ### with IPC::Cmd > 0.41, this is fixed in teh library,
      ### and there's no need for special casing any more.
      ### DO NOT quote things for IPC::Run, it breaks stuff.
      # $IPC::Cmd::USE_IPC_RUN
      #    ? ($to, $self->uri)
      #    : (QUOTE. $to .QUOTE, QUOTE. $self->uri .QUOTE);
  
  
      my $captured;
      unless(run( command => $cmd,
                  buffer  => \$captured,
                  verbose => $DEBUG )
      ) {
  
          return $self->_error(loc("Command failed: %1", $captured || ''));
      }
  
      return $to;
  
  }
  
  ### /usr/bin/fetch fetch! ###
  sub _fetch_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
      ### see if we have a fetch binary ###
      my $fetch;
      unless( HAS_FETCH and $fetch = can_run('fetch') ) {
          $METHOD_FAIL->{'fetch'} = 1;
          return;
      }
  
      ### no verboseness, thanks ###
      my $cmd = [ $fetch, '-q' ];
  
      ### if a timeout is set, add it ###
      push(@$cmd, '-T', $TIMEOUT) if $TIMEOUT;
  
      ### run passive if specified ###
      #push @$cmd, '-p' if $FTP_PASSIVE;
      local $ENV{'FTP_PASSIVE_MODE'} = 1 if $FTP_PASSIVE;
  
      ### set the output document, add the uri ###
      push @$cmd, '-o', $to, $self->uri;
  
      ### with IPC::Cmd > 0.41, this is fixed in teh library,
      ### and there's no need for special casing any more.
      ### DO NOT quote things for IPC::Run, it breaks stuff.
      # $IPC::Cmd::USE_IPC_RUN
      #    ? ($to, $self->uri)
      #    : (QUOTE. $to .QUOTE, QUOTE. $self->uri .QUOTE);
  
      ### shell out ###
      my $captured;
      unless(run( command => $cmd,
                  buffer  => \$captured,
                  verbose => $DEBUG
      )) {
          ### wget creates the output document always, even if the fetch
          ### fails.. so unlink it in that case
          1 while unlink $to;
  
          return $self->_error(loc( "Command failed: %1", $captured || '' ));
      }
  
      return $to;
  }
  
  ### use File::Copy for fetching file:// urls ###
  ###
  ### See section 3.10 of RFC 1738 (http://www.faqs.org/rfcs/rfc1738.html)
  ### Also see wikipedia on file:// (http://en.wikipedia.org/wiki/File://)
  ###
  
  sub _file_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
  
  
  
      ### prefix a / on unix systems with a file uri, since it would
      ### look somewhat like this:
      ###     file:///home/kane/file
      ### whereas windows file uris for 'c:\some\dir\file' might look like:
      ###     file:///C:/some/dir/file
      ###     file:///C|/some/dir/file
      ### or for a network share '\\host\share\some\dir\file':
      ###     file:////host/share/some/dir/file
      ###
      ### VMS file uri's for 'DISK$USER:[MY.NOTES]NOTE123456.TXT' might look like:
      ###     file://vms.host.edu/disk$user/my/notes/note12345.txt
      ###
  
      my $path    = $self->path;
      my $vol     = $self->vol;
      my $share   = $self->share;
  
      my $remote;
      if (!$share and $self->host) {
          return $self->_error(loc(
              "Currently %1 cannot handle hosts in %2 urls",
              'File::Fetch', 'file://'
          ));
      }
  
      if( $vol ) {
          $path   = File::Spec->catdir( split /\//, $path );
          $remote = File::Spec->catpath( $vol, $path, $self->file);
  
      } elsif( $share ) {
          ### win32 specific, and a share name, so we wont bother with File::Spec
          $path   =~ s|/+|\\|g;
          $remote = "\\\\".$self->host."\\$share\\$path";
  
      } else {
          ### File::Spec on VMS can not currently handle UNIX syntax.
          my $file_class = ON_VMS
              ? 'File::Spec::Unix'
              : 'File::Spec';
  
          $remote  = $file_class->catfile( $path, $self->file );
      }
  
      ### File::Copy is littered with 'die' statements :( ###
      my $rv = eval { File::Copy::copy( $remote, $to ) };
  
      ### something went wrong ###
      if( !$rv or $@ ) {
          return $self->_error(loc("Could not copy '%1' to '%2': %3 %4",
                               $remote, $to, $!, $@));
      }
  
      return $to;
  }
  
  ### use /usr/bin/rsync to fetch files
  sub _rsync_fetch {
      my $self = shift;
      my %hash = @_;
  
      my ($to);
      my $tmpl = {
          to  => { required => 1, store => \$to }
      };
      check( $tmpl, \%hash ) or return;
      my $rsync;
      unless ( $rsync = can_run('rsync') ) {
          $METHOD_FAIL->{'rsync'} = 1;
          return;
      }
  
      my $cmd = [ $rsync ];
  
      ### XXX: rsync has no I/O timeouts at all, by default
      push(@$cmd, '--timeout=' . $TIMEOUT) if $TIMEOUT;
  
      push(@$cmd, '--quiet') unless $DEBUG;
  
      ### DO NOT quote things for IPC::Run, it breaks stuff.
      push @$cmd, $self->uri, $to;
  
      ### with IPC::Cmd > 0.41, this is fixed in teh library,
      ### and there's no need for special casing any more.
      ### DO NOT quote things for IPC::Run, it breaks stuff.
      # $IPC::Cmd::USE_IPC_RUN
      #    ? ($to, $self->uri)
      #    : (QUOTE. $to .QUOTE, QUOTE. $self->uri .QUOTE);
  
      my $captured;
      unless(run( command => $cmd,
                  buffer  => \$captured,
                  verbose => $DEBUG )
      ) {
  
          return $self->_error(loc("Command %1 failed: %2",
              "@$cmd" || '', $captured || ''));
      }
  
      return $to;
  
  }
  
  #################################
  #
  # Error code
  #
  #################################
  
  =pod
  
  =head2 $ff->error([BOOL])
  
  Returns the last encountered error as string.
  Pass it a true value to get the C<Carp::longmess()> output instead.
  
  =cut
  
  ### error handling the way Archive::Extract does it
  sub _error {
      my $self    = shift;
      my $error   = shift;
  
      $self->_error_msg( $error );
      $self->_error_msg_long( Carp::longmess($error) );
  
      if( $WARN ) {
          carp $DEBUG ? $self->_error_msg_long : $self->_error_msg;
      }
  
      return;
  }
  
  sub error {
      my $self = shift;
      return shift() ? $self->_error_msg_long : $self->_error_msg;
  }
  
  
  1;
  
  =pod
  
  =head1 HOW IT WORKS
  
  File::Fetch is able to fetch a variety of uris, by using several
  external programs and modules.
  
  Below is a mapping of what utilities will be used in what order
  for what schemes, if available:
  
      file    => LWP, lftp, file
      http    => LWP, HTTP::Lite, wget, curl, lftp, fetch, lynx, iosock
      ftp     => LWP, Net::FTP, wget, curl, lftp, fetch, ncftp, ftp
      rsync   => rsync
  
  If you'd like to disable the use of one or more of these utilities
  and/or modules, see the C<$BLACKLIST> variable further down.
  
  If a utility or module isn't available, it will be marked in a cache
  (see the C<$METHOD_FAIL> variable further down), so it will not be
  tried again. The C<fetch> method will only fail when all options are
  exhausted, and it was not able to retrieve the file.
  
  The C<fetch> utility is available on FreeBSD. NetBSD and Dragonfly BSD
  may also have it from C<pkgsrc>. We only check for C<fetch> on those
  three platforms.
  
  C<iosock> is a very limited L<IO::Socket::INET> based mechanism for
  retrieving C<http> schemed urls. It doesn't follow redirects for instance.
  
  A special note about fetching files from an ftp uri:
  
  By default, all ftp connections are done in passive mode. To change
  that, see the C<$FTP_PASSIVE> variable further down.
  
  Furthermore, ftp uris only support anonymous connections, so no
  named user/password pair can be passed along.
  
  C</bin/ftp> is blacklisted by default; see the C<$BLACKLIST> variable
  further down.
  
  =head1 GLOBAL VARIABLES
  
  The behaviour of File::Fetch can be altered by changing the following
  global variables:
  
  =head2 $File::Fetch::FROM_EMAIL
  
  This is the email address that will be sent as your anonymous ftp
  password.
  
  Default is C<File-Fetch@example.com>.
  
  =head2 $File::Fetch::USER_AGENT
  
  This is the useragent as C<LWP> will report it.
  
  Default is C<File::Fetch/$VERSION>.
  
  =head2 $File::Fetch::FTP_PASSIVE
  
  This variable controls whether the environment variable C<FTP_PASSIVE>
  and any passive switches to commandline tools will be set to true.
  
  Default value is 1.
  
  Note: When $FTP_PASSIVE is true, C<ncftp> will not be used to fetch
  files, since passive mode can only be set interactively for this binary
  
  =head2 $File::Fetch::TIMEOUT
  
  When set, controls the network timeout (counted in seconds).
  
  Default value is 0.
  
  =head2 $File::Fetch::WARN
  
  This variable controls whether errors encountered internally by
  C<File::Fetch> should be C<carp>'d or not.
  
  Set to false to silence warnings. Inspect the output of the C<error()>
  method manually to see what went wrong.
  
  Defaults to C<true>.
  
  =head2 $File::Fetch::DEBUG
  
  This enables debugging output when calling commandline utilities to
  fetch files.
  This also enables C<Carp::longmess> errors, instead of the regular
  C<carp> errors.
  
  Good for tracking down why things don't work with your particular
  setup.
  
  Default is 0.
  
  =head2 $File::Fetch::BLACKLIST
  
  This is an array ref holding blacklisted modules/utilities for fetching
  files with.
  
  To disallow the use of, for example, C<LWP> and C<Net::FTP>, you could
  set $File::Fetch::BLACKLIST to:
  
      $File::Fetch::BLACKLIST = [qw|lwp netftp|]
  
  The default blacklist is [qw|ftp|], as C</bin/ftp> is rather unreliable.
  
  See the note on C<MAPPING> below.
  
  =head2 $File::Fetch::METHOD_FAIL
  
  This is a hashref registering what modules/utilities were known to fail
  for fetching files (mostly because they weren't installed).
  
  You can reset this cache by assigning an empty hashref to it, or
  individually remove keys.
  
  See the note on C<MAPPING> below.
  
  =head1 MAPPING
  
  
  Here's a quick mapping for the utilities/modules, and their names for
  the $BLACKLIST, $METHOD_FAIL and other internal functions.
  
      LWP         => lwp
      HTTP::Lite  => httplite
      HTTP::Tiny  => httptiny
      Net::FTP    => netftp
      wget        => wget
      lynx        => lynx
      ncftp       => ncftp
      ftp         => ftp
      curl        => curl
      rsync       => rsync
      lftp        => lftp
      fetch       => fetch
      IO::Socket  => iosock
  
  =head1 FREQUENTLY ASKED QUESTIONS
  
  =head2 So how do I use a proxy with File::Fetch?
  
  C<File::Fetch> currently only supports proxies with LWP::UserAgent.
  You will need to set your environment variables accordingly. For
  example, to use an ftp proxy:
  
      $ENV{ftp_proxy} = 'foo.com';
  
  Refer to the LWP::UserAgent manpage for more details.
  
  =head2 I used 'lynx' to fetch a file, but its contents is all wrong!
  
  C<lynx> can only fetch remote files by dumping its contents to C<STDOUT>,
  which we in turn capture. If that content is a 'custom' error file
  (like, say, a C<404 handler>), you will get that contents instead.
  
  Sadly, C<lynx> doesn't support any options to return a different exit
  code on non-C<200 OK> status, giving us no way to tell the difference
  between a 'successful' fetch and a custom error page.
  
  Therefor, we recommend to only use C<lynx> as a last resort. This is
  why it is at the back of our list of methods to try as well.
  
  =head2 Files I'm trying to fetch have reserved characters or non-ASCII characters in them. What do I do?
  
  C<File::Fetch> is relatively smart about things. When trying to write
  a file to disk, it removes the C<query parameters> (see the
  C<output_file> method for details) from the file name before creating
  it. In most cases this suffices.
  
  If you have any other characters you need to escape, please install
  the C<URI::Escape> module from CPAN, and pre-encode your URI before
  passing it to C<File::Fetch>. You can read about the details of URIs
  and URI encoding here:
  
    http://www.faqs.org/rfcs/rfc2396.html
  
  =head1 TODO
  
  =over 4
  
  =item Implement $PREFER_BIN
  
  To indicate to rather use commandline tools than modules
  
  =back
  
  =head1 BUG REPORTS
  
  Please report bugs or other issues to E<lt>bug-file-fetch@rt.cpan.org<gt>.
  
  =head1 AUTHOR
  
  This module by Jos Boumans E<lt>kane@cpan.orgE<gt>.
  
  =head1 COPYRIGHT
  
  This library is free software; you may redistribute and/or modify it
  under the same terms as Perl itself.
  
  
  =cut
  
  # Local variables:
  # c-indentation-style: bsd
  # c-basic-offset: 4
  # indent-tabs-mode: nil
  # End:
  # vim: expandtab shiftwidth=4:
  
  
  
  
FILE_FETCH

$fatpacked{"File/Find.pm"} = <<'FILE_FIND';
  package File::Find;
  use 5.006;
  use strict;
  use warnings;
  use warnings::register;
  our $VERSION = '1.23';
  require Exporter;
  require Cwd;
  
  #
  # Modified to ensure sub-directory traversal order is not inverted by stack
  # push and pops.  That is remains in the same order as in the directory file,
  # or user pre-processing (EG:sorted).
  #
  
  =head1 NAME
  
  File::Find - Traverse a directory tree.
  
  =head1 SYNOPSIS
  
      use File::Find;
      find(\&wanted, @directories_to_search);
      sub wanted { ... }
  
      use File::Find;
      finddepth(\&wanted, @directories_to_search);
      sub wanted { ... }
  
      use File::Find;
      find({ wanted => \&process, follow => 1 }, '.');
  
  =head1 DESCRIPTION
  
  These are functions for searching through directory trees doing work
  on each file found similar to the Unix I<find> command.  File::Find
  exports two functions, C<find> and C<finddepth>.  They work similarly
  but have subtle differences.
  
  =over 4
  
  =item B<find>
  
    find(\&wanted,  @directories);
    find(\%options, @directories);
  
  C<find()> does a depth-first search over the given C<@directories> in
  the order they are given.  For each file or directory found, it calls
  the C<&wanted> subroutine.  (See below for details on how to use the
  C<&wanted> function).  Additionally, for each directory found, it will
  C<chdir()> into that directory and continue the search, invoking the
  C<&wanted> function on each file or subdirectory in the directory.
  
  =item B<finddepth>
  
    finddepth(\&wanted,  @directories);
    finddepth(\%options, @directories);
  
  C<finddepth()> works just like C<find()> except that it invokes the
  C<&wanted> function for a directory I<after> invoking it for the
  directory's contents.  It does a postorder traversal instead of a
  preorder traversal, working from the bottom of the directory tree up
  where C<find()> works from the top of the tree down.
  
  =back
  
  =head2 %options
  
  The first argument to C<find()> is either a code reference to your
  C<&wanted> function, or a hash reference describing the operations
  to be performed for each file.  The
  code reference is described in L<The wanted function> below.
  
  Here are the possible keys for the hash:
  
  =over 3
  
  =item C<wanted>
  
  The value should be a code reference.  This code reference is
  described in L<The wanted function> below. The C<&wanted> subroutine is
  mandatory.
  
  =item C<bydepth>
  
  Reports the name of a directory only AFTER all its entries
  have been reported.  Entry point C<finddepth()> is a shortcut for
  specifying C<< { bydepth => 1 } >> in the first argument of C<find()>.
  
  =item C<preprocess>
  
  The value should be a code reference. This code reference is used to
  preprocess the current directory. The name of the currently processed
  directory is in C<$File::Find::dir>. Your preprocessing function is
  called after C<readdir()>, but before the loop that calls the C<wanted()>
  function. It is called with a list of strings (actually file/directory
  names) and is expected to return a list of strings. The code can be
  used to sort the file/directory names alphabetically, numerically,
  or to filter out directory entries based on their name alone. When
  I<follow> or I<follow_fast> are in effect, C<preprocess> is a no-op.
  
  =item C<postprocess>
  
  The value should be a code reference. It is invoked just before leaving
  the currently processed directory. It is called in void context with no
  arguments. The name of the current directory is in C<$File::Find::dir>. This
  hook is handy for summarizing a directory, such as calculating its disk
  usage. When I<follow> or I<follow_fast> are in effect, C<postprocess> is a
  no-op.
  
  =item C<follow>
  
  Causes symbolic links to be followed. Since directory trees with symbolic
  links (followed) may contain files more than once and may even have
  cycles, a hash has to be built up with an entry for each file.
  This might be expensive both in space and time for a large
  directory tree. See L</follow_fast> and L</follow_skip> below.
  If either I<follow> or I<follow_fast> is in effect:
  
  =over 6
  
  =item *
  
  It is guaranteed that an I<lstat> has been called before the user's
  C<wanted()> function is called. This enables fast file checks involving S<_>.
  Note that this guarantee no longer holds if I<follow> or I<follow_fast>
  are not set.
  
  =item *
  
  There is a variable C<$File::Find::fullname> which holds the absolute
  pathname of the file with all symbolic links resolved.  If the link is
  a dangling symbolic link, then fullname will be set to C<undef>.
  
  =back
  
  This is a no-op on Win32.
  
  =item C<follow_fast>
  
  This is similar to I<follow> except that it may report some files more
  than once.  It does detect cycles, however.  Since only symbolic links
  have to be hashed, this is much cheaper both in space and time.  If
  processing a file more than once (by the user's C<wanted()> function)
  is worse than just taking time, the option I<follow> should be used.
  
  This is also a no-op on Win32.
  
  =item C<follow_skip>
  
  C<follow_skip==1>, which is the default, causes all files which are
  neither directories nor symbolic links to be ignored if they are about
  to be processed a second time. If a directory or a symbolic link
  are about to be processed a second time, File::Find dies.
  
  C<follow_skip==0> causes File::Find to die if any file is about to be
  processed a second time.
  
  C<follow_skip==2> causes File::Find to ignore any duplicate files and
  directories but to proceed normally otherwise.
  
  =item C<dangling_symlinks>
  
  If true and a code reference, will be called with the symbolic link
  name and the directory it lives in as arguments.  Otherwise, if true
  and warnings are on, warning "symbolic_link_name is a dangling
  symbolic link\n" will be issued.  If false, the dangling symbolic link
  will be silently ignored.
  
  =item C<no_chdir>
  
  Does not C<chdir()> to each directory as it recurses. The C<wanted()>
  function will need to be aware of this, of course. In this case,
  C<$_> will be the same as C<$File::Find::name>.
  
  =item C<untaint>
  
  If find is used in taint-mode (-T command line switch or if EUID != UID
  or if EGID != GID) then internally directory names have to be untainted
  before they can be chdir'ed to. Therefore they are checked against a regular
  expression I<untaint_pattern>.  Note that all names passed to the user's
  I<wanted()> function are still tainted. If this option is used while
  not in taint-mode, C<untaint> is a no-op.
  
  =item C<untaint_pattern>
  
  See above. This should be set using the C<qr> quoting operator.
  The default is set to  C<qr|^([-+@\w./]+)$|>.
  Note that the parentheses are vital.
  
  =item C<untaint_skip>
  
  If set, a directory which fails the I<untaint_pattern> is skipped,
  including all its sub-directories. The default is to 'die' in such a case.
  
  =back
  
  =head2 The wanted function
  
  The C<wanted()> function does whatever verifications you want on
  each file and directory.  Note that despite its name, the C<wanted()>
  function is a generic callback function, and does B<not> tell
  File::Find if a file is "wanted" or not.  In fact, its return value
  is ignored.
  
  The wanted function takes no arguments but rather does its work
  through a collection of variables.
  
  =over 4
  
  =item C<$File::Find::dir> is the current directory name,
  
  =item C<$_> is the current filename within that directory
  
  =item C<$File::Find::name> is the complete pathname to the file.
  
  =back
  
  The above variables have all been localized and may be changed without
  affecting data outside of the wanted function.
  
  For example, when examining the file F</some/path/foo.ext> you will have:
  
      $File::Find::dir  = /some/path/
      $_                = foo.ext
      $File::Find::name = /some/path/foo.ext
  
  You are chdir()'d to C<$File::Find::dir> when the function is called,
  unless C<no_chdir> was specified. Note that when changing to
  directories is in effect the root directory (F</>) is a somewhat
  special case inasmuch as the concatenation of C<$File::Find::dir>,
  C<'/'> and C<$_> is not literally equal to C<$File::Find::name>. The
  table below summarizes all variants:
  
                $File::Find::name  $File::Find::dir  $_
   default      /                  /                 .
   no_chdir=>0  /etc               /                 etc
                /etc/x             /etc              x
  
   no_chdir=>1  /                  /                 /
                /etc               /                 /etc
                /etc/x             /etc              /etc/x
  
  
  When C<follow> or C<follow_fast> are in effect, there is
  also a C<$File::Find::fullname>.  The function may set
  C<$File::Find::prune> to prune the tree unless C<bydepth> was
  specified.  Unless C<follow> or C<follow_fast> is specified, for
  compatibility reasons (find.pl, find2perl) there are in addition the
  following globals available: C<$File::Find::topdir>,
  C<$File::Find::topdev>, C<$File::Find::topino>,
  C<$File::Find::topmode> and C<$File::Find::topnlink>.
  
  This library is useful for the C<find2perl> tool, which when fed,
  
      find2perl / -name .nfs\* -mtime +7 \
          -exec rm -f {} \; -o -fstype nfs -prune
  
  produces something like:
  
      sub wanted {
          /^\.nfs.*\z/s &&
          (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_)) &&
          int(-M _) > 7 &&
          unlink($_)
          ||
          ($nlink || (($dev, $ino, $mode, $nlink, $uid, $gid) = lstat($_))) &&
          $dev < 0 &&
          ($File::Find::prune = 1);
      }
  
  Notice the C<_> in the above C<int(-M _)>: the C<_> is a magical
  filehandle that caches the information from the preceding
  C<stat()>, C<lstat()>, or filetest.
  
  Here's another interesting wanted function.  It will find all symbolic
  links that don't resolve:
  
      sub wanted {
           -l && !-e && print "bogus link: $File::Find::name\n";
      }
  
  Note that you may mix directories and (non-directory) files in the list of 
  directories to be searched by the C<wanted()> function.
  
      find(\&wanted, "./foo", "./bar", "./baz/epsilon");
  
  In the example above, no file in F<./baz/> other than F<./baz/epsilon> will be
  evaluated by C<wanted()>.
  
  See also the script C<pfind> on CPAN for a nice application of this
  module.
  
  =head1 WARNINGS
  
  If you run your program with the C<-w> switch, or if you use the
  C<warnings> pragma, File::Find will report warnings for several weird
  situations. You can disable these warnings by putting the statement
  
      no warnings 'File::Find';
  
  in the appropriate scope. See L<perllexwarn> for more info about lexical
  warnings.
  
  =head1 CAVEAT
  
  =over 2
  
  =item $dont_use_nlink
  
  You can set the variable C<$File::Find::dont_use_nlink> to 1, if you want to
  force File::Find to always stat directories. This was used for file systems
  that do not have an C<nlink> count matching the number of sub-directories.
  Examples are ISO-9660 (CD-ROM), AFS, HPFS (OS/2 file system), FAT (DOS file
  system) and a couple of others.
  
  You shouldn't need to set this variable, since File::Find should now detect
  such file systems on-the-fly and switch itself to using stat. This works even
  for parts of your file system, like a mounted CD-ROM.
  
  If you do set C<$File::Find::dont_use_nlink> to 1, you will notice slow-downs.
  
  =item symlinks
  
  Be aware that the option to follow symbolic links can be dangerous.
  Depending on the structure of the directory tree (including symbolic
  links to directories) you might traverse a given (physical) directory
  more than once (only if C<follow_fast> is in effect).
  Furthermore, deleting or changing files in a symbolically linked directory
  might cause very unpleasant surprises, since you delete or change files
  in an unknown directory.
  
  =back
  
  =head1 BUGS AND CAVEATS
  
  Despite the name of the C<finddepth()> function, both C<find()> and
  C<finddepth()> perform a depth-first search of the directory
  hierarchy.
  
  =head1 HISTORY
  
  File::Find used to produce incorrect results if called recursively.
  During the development of perl 5.8 this bug was fixed.
  The first fixed version of File::Find was 1.01.
  
  =head1 SEE ALSO
  
  find, find2perl.
  
  =cut
  
  our @ISA = qw(Exporter);
  our @EXPORT = qw(find finddepth);
  
  
  use strict;
  my $Is_VMS;
  my $Is_Win32;
  
  require File::Basename;
  require File::Spec;
  
  # Should ideally be my() not our() but local() currently
  # refuses to operate on lexicals
  
  our %SLnkSeen;
  our ($wanted_callback, $avoid_nlink, $bydepth, $no_chdir, $follow,
      $follow_skip, $full_check, $untaint, $untaint_skip, $untaint_pat,
      $pre_process, $post_process, $dangling_symlinks);
  
  sub contract_name {
      my ($cdir,$fn) = @_;
  
      return substr($cdir,0,rindex($cdir,'/')) if $fn eq $File::Find::current_dir;
  
      $cdir = substr($cdir,0,rindex($cdir,'/')+1);
  
      $fn =~ s|^\./||;
  
      my $abs_name= $cdir . $fn;
  
      if (substr($fn,0,3) eq '../') {
         1 while $abs_name =~ s!/[^/]*/\.\./+!/!;
      }
  
      return $abs_name;
  }
  
  sub PathCombine($$) {
      my ($Base,$Name) = @_;
      my $AbsName;
  
      if (substr($Name,0,1) eq '/') {
  	$AbsName= $Name;
      }
      else {
  	$AbsName= contract_name($Base,$Name);
      }
  
      # (simple) check for recursion
      my $newlen= length($AbsName);
      if ($newlen <= length($Base)) {
  	if (($newlen == length($Base) || substr($Base,$newlen,1) eq '/')
  	    && $AbsName eq substr($Base,0,$newlen))
  	{
  	    return undef;
  	}
      }
      return $AbsName;
  }
  
  sub Follow_SymLink($) {
      my ($AbsName) = @_;
  
      my ($NewName,$DEV, $INO);
      ($DEV, $INO)= lstat $AbsName;
  
      while (-l _) {
  	if ($SLnkSeen{$DEV, $INO}++) {
  	    if ($follow_skip < 2) {
  		die "$AbsName is encountered a second time";
  	    }
  	    else {
  		return undef;
  	    }
  	}
  	$NewName= PathCombine($AbsName, readlink($AbsName));
  	unless(defined $NewName) {
  	    if ($follow_skip < 2) {
  		die "$AbsName is a recursive symbolic link";
  	    }
  	    else {
  		return undef;
  	    }
  	}
  	else {
  	    $AbsName= $NewName;
  	}
  	($DEV, $INO) = lstat($AbsName);
  	return undef unless defined $DEV;  #  dangling symbolic link
      }
  
      if ($full_check && defined $DEV && $SLnkSeen{$DEV, $INO}++) {
  	if ( ($follow_skip < 1) || ((-d _) && ($follow_skip < 2)) ) {
  	    die "$AbsName encountered a second time";
  	}
  	else {
  	    return undef;
  	}
      }
  
      return $AbsName;
  }
  
  our($dir, $name, $fullname, $prune);
  sub _find_dir_symlnk($$$);
  sub _find_dir($$$);
  
  # check whether or not a scalar variable is tainted
  # (code straight from the Camel, 3rd ed., page 561)
  sub is_tainted_pp {
      my $arg = shift;
      my $nada = substr($arg, 0, 0); # zero-length
      local $@;
      eval { eval "# $nada" };
      return length($@) != 0;
  }
  
  sub _find_opt {
      my $wanted = shift;
      die "invalid top directory" unless defined $_[0];
  
      # This function must local()ize everything because callbacks may
      # call find() or finddepth()
  
      local %SLnkSeen;
      local ($wanted_callback, $avoid_nlink, $bydepth, $no_chdir, $follow,
  	$follow_skip, $full_check, $untaint, $untaint_skip, $untaint_pat,
  	$pre_process, $post_process, $dangling_symlinks);
      local($dir, $name, $fullname, $prune);
      local *_ = \my $a;
  
      my $cwd            = $wanted->{bydepth} ? Cwd::fastcwd() : Cwd::getcwd();
      if ($Is_VMS) {
  	# VMS returns this by default in VMS format which just doesn't
  	# work for the rest of this module.
  	$cwd = VMS::Filespec::unixpath($cwd);
  
  	# Apparently this is not expected to have a trailing space.
  	# To attempt to make VMS/UNIX conversions mostly reversable,
  	# a trailing slash is needed.  The run-time functions ignore the
  	# resulting double slash, but it causes the perl tests to fail.
          $cwd =~ s#/\z##;
  
  	# This comes up in upper case now, but should be lower.
  	# In the future this could be exact case, no need to change.
      }
      my $cwd_untainted  = $cwd;
      my $check_t_cwd    = 1;
      $wanted_callback   = $wanted->{wanted};
      $bydepth           = $wanted->{bydepth};
      $pre_process       = $wanted->{preprocess};
      $post_process      = $wanted->{postprocess};
      $no_chdir          = $wanted->{no_chdir};
      $full_check        = $Is_Win32 ? 0 : $wanted->{follow};
      $follow            = $Is_Win32 ? 0 :
                               $full_check || $wanted->{follow_fast};
      $follow_skip       = $wanted->{follow_skip};
      $untaint           = $wanted->{untaint};
      $untaint_pat       = $wanted->{untaint_pattern};
      $untaint_skip      = $wanted->{untaint_skip};
      $dangling_symlinks = $wanted->{dangling_symlinks};
  
      # for compatibility reasons (find.pl, find2perl)
      local our ($topdir, $topdev, $topino, $topmode, $topnlink);
  
      # a symbolic link to a directory doesn't increase the link count
      $avoid_nlink      = $follow || $File::Find::dont_use_nlink;
  
      my ($abs_dir, $Is_Dir);
  
      Proc_Top_Item:
      foreach my $TOP (@_) {
  	my $top_item = $TOP;
  	$top_item = VMS::Filespec::unixify($top_item) if $Is_VMS;
  
  	($topdev,$topino,$topmode,$topnlink) = $follow ? stat $top_item : lstat $top_item;
  
  	if ($Is_Win32) {
  	    $top_item =~ s|[/\\]\z||
  	      unless $top_item =~ m{^(?:\w:)?[/\\]$};
  	}
  	else {
  	    $top_item =~ s|/\z|| unless $top_item eq '/';
  	}
  
  	$Is_Dir= 0;
  
  	if ($follow) {
  
  	    if (substr($top_item,0,1) eq '/') {
  		$abs_dir = $top_item;
  	    }
  	    elsif ($top_item eq $File::Find::current_dir) {
  		$abs_dir = $cwd;
  	    }
  	    else {  # care about any  ../
  		$top_item =~ s/\.dir\z//i if $Is_VMS;
  		$abs_dir = contract_name("$cwd/",$top_item);
  	    }
  	    $abs_dir= Follow_SymLink($abs_dir);
  	    unless (defined $abs_dir) {
  		if ($dangling_symlinks) {
  		    if (ref $dangling_symlinks eq 'CODE') {
  			$dangling_symlinks->($top_item, $cwd);
  		    } else {
  			warnings::warnif "$top_item is a dangling symbolic link\n";
  		    }
  		}
  		next Proc_Top_Item;
  	    }
  
  	    if (-d _) {
  		$top_item =~ s/\.dir\z//i if $Is_VMS;
  		_find_dir_symlnk($wanted, $abs_dir, $top_item);
  		$Is_Dir= 1;
  	    }
  	}
  	else { # no follow
  	    $topdir = $top_item;
  	    unless (defined $topnlink) {
  		warnings::warnif "Can't stat $top_item: $!\n";
  		next Proc_Top_Item;
  	    }
  	    if (-d _) {
  		$top_item =~ s/\.dir\z//i if $Is_VMS;
  		_find_dir($wanted, $top_item, $topnlink);
  		$Is_Dir= 1;
  	    }
  	    else {
  		$abs_dir= $top_item;
  	    }
  	}
  
  	unless ($Is_Dir) {
  	    unless (($_,$dir) = File::Basename::fileparse($abs_dir)) {
  		($dir,$_) = ('./', $top_item);
  	    }
  
  	    $abs_dir = $dir;
  	    if (( $untaint ) && (is_tainted($dir) )) {
  		( $abs_dir ) = $dir =~ m|$untaint_pat|;
  		unless (defined $abs_dir) {
  		    if ($untaint_skip == 0) {
  			die "directory $dir is still tainted";
  		    }
  		    else {
  			next Proc_Top_Item;
  		    }
  		}
  	    }
  
  	    unless ($no_chdir || chdir $abs_dir) {
  		warnings::warnif "Couldn't chdir $abs_dir: $!\n";
  		next Proc_Top_Item;
  	    }
  
  	    $name = $abs_dir . $_; # $File::Find::name
  	    $_ = $name if $no_chdir;
  
  	    { $wanted_callback->() }; # protect against wild "next"
  
  	}
  
  	unless ( $no_chdir ) {
  	    if ( ($check_t_cwd) && (($untaint) && (is_tainted($cwd) )) ) {
  		( $cwd_untainted ) = $cwd =~ m|$untaint_pat|;
  		unless (defined $cwd_untainted) {
  		    die "insecure cwd in find(depth)";
  		}
  		$check_t_cwd = 0;
  	    }
  	    unless (chdir $cwd_untainted) {
  		die "Can't cd to $cwd: $!\n";
  	    }
  	}
      }
  }
  
  # API:
  #  $wanted
  #  $p_dir :  "parent directory"
  #  $nlink :  what came back from the stat
  # preconditions:
  #  chdir (if not no_chdir) to dir
  
  sub _find_dir($$$) {
      my ($wanted, $p_dir, $nlink) = @_;
      my ($CdLvl,$Level) = (0,0);
      my @Stack;
      my @filenames;
      my ($subcount,$sub_nlink);
      my $SE= [];
      my $dir_name= $p_dir;
      my $dir_pref;
      my $dir_rel = $File::Find::current_dir;
      my $tainted = 0;
      my $no_nlink;
  
      if ($Is_Win32) {
  	$dir_pref
  	  = ($p_dir =~ m{^(?:\w:[/\\]?|[/\\])$} ? $p_dir : "$p_dir/" );
      } elsif ($Is_VMS) {
  
  	#	VMS is returning trailing .dir on directories
  	#	and trailing . on files and symbolic links
  	#	in UNIX syntax.
  	#
  
  	$p_dir =~ s/\.(dir)?$//i unless $p_dir eq '.';
  
  	$dir_pref = ($p_dir =~ m/[\]>]+$/ ? $p_dir : "$p_dir/" );
      }
      else {
  	$dir_pref= ( $p_dir eq '/' ? '/' : "$p_dir/" );
      }
  
      local ($dir, $name, $prune, *DIR);
  
      unless ( $no_chdir || ($p_dir eq $File::Find::current_dir)) {
  	my $udir = $p_dir;
  	if (( $untaint ) && (is_tainted($p_dir) )) {
  	    ( $udir ) = $p_dir =~ m|$untaint_pat|;
  	    unless (defined $udir) {
  		if ($untaint_skip == 0) {
  		    die "directory $p_dir is still tainted";
  		}
  		else {
  		    return;
  		}
  	    }
  	}
  	unless (chdir ($Is_VMS && $udir !~ /[\/\[<]+/ ? "./$udir" : $udir)) {
  	    warnings::warnif "Can't cd to $udir: $!\n";
  	    return;
  	}
      }
  
      # push the starting directory
      push @Stack,[$CdLvl,$p_dir,$dir_rel,-1]  if  $bydepth;
  
      while (defined $SE) {
  	unless ($bydepth) {
  	    $dir= $p_dir; # $File::Find::dir
  	    $name= $dir_name; # $File::Find::name
  	    $_= ($no_chdir ? $dir_name : $dir_rel ); # $_
  	    # prune may happen here
  	    $prune= 0;
  	    { $wanted_callback->() };	# protect against wild "next"
  	    next if $prune;
  	}
  
  	# change to that directory
  	unless ($no_chdir || ($dir_rel eq $File::Find::current_dir)) {
  	    my $udir= $dir_rel;
  	    if ( ($untaint) && (($tainted) || ($tainted = is_tainted($dir_rel) )) ) {
  		( $udir ) = $dir_rel =~ m|$untaint_pat|;
  		unless (defined $udir) {
  		    if ($untaint_skip == 0) {
  			die "directory (" . ($p_dir ne '/' ? $p_dir : '') . "/) $dir_rel is still tainted";
  		    } else { # $untaint_skip == 1
  			next;
  		    }
  		}
  	    }
  	    unless (chdir ($Is_VMS && $udir !~ /[\/\[<]+/ ? "./$udir" : $udir)) {
  		warnings::warnif "Can't cd to (" .
  		    ($p_dir ne '/' ? $p_dir : '') . "/) $udir: $!\n";
  		next;
  	    }
  	    $CdLvl++;
  	}
  
  	$dir= $dir_name; # $File::Find::dir
  
  	# Get the list of files in the current directory.
  	unless (opendir DIR, ($no_chdir ? $dir_name : $File::Find::current_dir)) {
  	    warnings::warnif "Can't opendir($dir_name): $!\n";
  	    next;
  	}
  	@filenames = readdir DIR;
  	closedir(DIR);
  	@filenames = $pre_process->(@filenames) if $pre_process;
  	push @Stack,[$CdLvl,$dir_name,"",-2]   if $post_process;
  
  	# default: use whatever was specified
          # (if $nlink >= 2, and $avoid_nlink == 0, this will switch back)
          $no_nlink = $avoid_nlink;
          # if dir has wrong nlink count, force switch to slower stat method
          $no_nlink = 1 if ($nlink < 2);
  
  	if ($nlink == 2 && !$no_nlink) {
  	    # This dir has no subdirectories.
  	    for my $FN (@filenames) {
  		if ($Is_VMS) {
  		# Big hammer here - Compensate for VMS trailing . and .dir
  		# No win situation until this is changed, but this
  		# will handle the majority of the cases with breaking the fewest
  
  		    $FN =~ s/\.dir\z//i;
  		    $FN =~ s#\.$## if ($FN ne '.');
  		}
  		next if $FN =~ $File::Find::skip_pattern;
  		
  		$name = $dir_pref . $FN; # $File::Find::name
  		$_ = ($no_chdir ? $name : $FN); # $_
  		{ $wanted_callback->() }; # protect against wild "next"
  	    }
  
  	}
  	else {
  	    # This dir has subdirectories.
  	    $subcount = $nlink - 2;
  
  	    # HACK: insert directories at this position. so as to preserve
  	    # the user pre-processed ordering of files.
  	    # EG: directory traversal is in user sorted order, not at random.
              my $stack_top = @Stack;
  
  	    for my $FN (@filenames) {
  		next if $FN =~ $File::Find::skip_pattern;
  		if ($subcount > 0 || $no_nlink) {
  		    # Seen all the subdirs?
  		    # check for directoriness.
  		    # stat is faster for a file in the current directory
  		    $sub_nlink = (lstat ($no_chdir ? $dir_pref . $FN : $FN))[3];
  
  		    if (-d _) {
  			--$subcount;
  			$FN =~ s/\.dir\z//i if $Is_VMS;
  			# HACK: replace push to preserve dir traversal order
  			#push @Stack,[$CdLvl,$dir_name,$FN,$sub_nlink];
  			splice @Stack, $stack_top, 0,
  			         [$CdLvl,$dir_name,$FN,$sub_nlink];
  		    }
  		    else {
  			$name = $dir_pref . $FN; # $File::Find::name
  			$_= ($no_chdir ? $name : $FN); # $_
  			{ $wanted_callback->() }; # protect against wild "next"
  		    }
  		}
  		else {
  		    $name = $dir_pref . $FN; # $File::Find::name
  		    $_= ($no_chdir ? $name : $FN); # $_
  		    { $wanted_callback->() }; # protect against wild "next"
  		}
  	    }
  	}
      }
      continue {
  	while ( defined ($SE = pop @Stack) ) {
  	    ($Level, $p_dir, $dir_rel, $nlink) = @$SE;
  	    if ($CdLvl > $Level && !$no_chdir) {
  		my $tmp;
  		if ($Is_VMS) {
  		    $tmp = '[' . ('-' x ($CdLvl-$Level)) . ']';
  		}
  		else {
  		    $tmp = join('/',('..') x ($CdLvl-$Level));
  		}
  		die "Can't cd to $tmp from $dir_name"
  		    unless chdir ($tmp);
  		$CdLvl = $Level;
  	    }
  
  	    if ($Is_Win32) {
  		$dir_name = ($p_dir =~ m{^(?:\w:[/\\]?|[/\\])$}
  		    ? "$p_dir$dir_rel" : "$p_dir/$dir_rel");
  		$dir_pref = "$dir_name/";
  	    }
  	    elsif ($^O eq 'VMS') {
                  if ($p_dir =~ m/[\]>]+$/) {
                      $dir_name = $p_dir;
                      $dir_name =~ s/([\]>]+)$/.$dir_rel$1/;
                      $dir_pref = $dir_name;
                  }
                  else {
                      $dir_name = "$p_dir/$dir_rel";
                      $dir_pref = "$dir_name/";
                  }
  	    }
  	    else {
  		$dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
  		$dir_pref = "$dir_name/";
  	    }
  
  	    if ( $nlink == -2 ) {
  		$name = $dir = $p_dir; # $File::Find::name / dir
                  $_ = $File::Find::current_dir;
  		$post_process->();		# End-of-directory processing
  	    }
  	    elsif ( $nlink < 0 ) {  # must be finddepth, report dirname now
  		$name = $dir_name;
  		if ( substr($name,-2) eq '/.' ) {
  		    substr($name, length($name) == 2 ? -1 : -2) = '';
  		}
  		$dir = $p_dir;
  		$_ = ($no_chdir ? $dir_name : $dir_rel );
  		if ( substr($_,-2) eq '/.' ) {
  		    substr($_, length($_) == 2 ? -1 : -2) = '';
  		}
  		{ $wanted_callback->() }; # protect against wild "next"
  	     }
  	     else {
  		push @Stack,[$CdLvl,$p_dir,$dir_rel,-1]  if  $bydepth;
  		last;
  	    }
  	}
      }
  }
  
  
  # API:
  #  $wanted
  #  $dir_loc : absolute location of a dir
  #  $p_dir   : "parent directory"
  # preconditions:
  #  chdir (if not no_chdir) to dir
  
  sub _find_dir_symlnk($$$) {
      my ($wanted, $dir_loc, $p_dir) = @_; # $dir_loc is the absolute directory
      my @Stack;
      my @filenames;
      my $new_loc;
      my $updir_loc = $dir_loc; # untainted parent directory
      my $SE = [];
      my $dir_name = $p_dir;
      my $dir_pref;
      my $loc_pref;
      my $dir_rel = $File::Find::current_dir;
      my $byd_flag; # flag for pending stack entry if $bydepth
      my $tainted = 0;
      my $ok = 1;
  
      $dir_pref = ( $p_dir   eq '/' ? '/' : "$p_dir/" );
      $loc_pref = ( $dir_loc eq '/' ? '/' : "$dir_loc/" );
  
      local ($dir, $name, $fullname, $prune, *DIR);
  
      unless ($no_chdir) {
  	# untaint the topdir
  	if (( $untaint ) && (is_tainted($dir_loc) )) {
  	    ( $updir_loc ) = $dir_loc =~ m|$untaint_pat|; # parent dir, now untainted
  	     # once untainted, $updir_loc is pushed on the stack (as parent directory);
  	    # hence, we don't need to untaint the parent directory every time we chdir
  	    # to it later
  	    unless (defined $updir_loc) {
  		if ($untaint_skip == 0) {
  		    die "directory $dir_loc is still tainted";
  		}
  		else {
  		    return;
  		}
  	    }
  	}
  	$ok = chdir($updir_loc) unless ($p_dir eq $File::Find::current_dir);
  	unless ($ok) {
  	    warnings::warnif "Can't cd to $updir_loc: $!\n";
  	    return;
  	}
      }
  
      push @Stack,[$dir_loc,$updir_loc,$p_dir,$dir_rel,-1]  if  $bydepth;
  
      while (defined $SE) {
  
  	unless ($bydepth) {
  	    # change (back) to parent directory (always untainted)
  	    unless ($no_chdir) {
  		unless (chdir $updir_loc) {
  		    warnings::warnif "Can't cd to $updir_loc: $!\n";
  		    next;
  		}
  	    }
  	    $dir= $p_dir; # $File::Find::dir
  	    $name= $dir_name; # $File::Find::name
  	    $_= ($no_chdir ? $dir_name : $dir_rel ); # $_
  	    $fullname= $dir_loc; # $File::Find::fullname
  	    # prune may happen here
  	    $prune= 0;
  	    lstat($_); # make sure  file tests with '_' work
  	    { $wanted_callback->() }; # protect against wild "next"
  	    next if $prune;
  	}
  
  	# change to that directory
  	unless ($no_chdir || ($dir_rel eq $File::Find::current_dir)) {
  	    $updir_loc = $dir_loc;
  	    if ( ($untaint) && (($tainted) || ($tainted = is_tainted($dir_loc) )) ) {
  		# untaint $dir_loc, what will be pushed on the stack as (untainted) parent dir
  		( $updir_loc ) = $dir_loc =~ m|$untaint_pat|;
  		unless (defined $updir_loc) {
  		    if ($untaint_skip == 0) {
  			die "directory $dir_loc is still tainted";
  		    }
  		    else {
  			next;
  		    }
  		}
  	    }
  	    unless (chdir $updir_loc) {
  		warnings::warnif "Can't cd to $updir_loc: $!\n";
  		next;
  	    }
  	}
  
  	$dir = $dir_name; # $File::Find::dir
  
  	# Get the list of files in the current directory.
  	unless (opendir DIR, ($no_chdir ? $dir_loc : $File::Find::current_dir)) {
  	    warnings::warnif "Can't opendir($dir_loc): $!\n";
  	    next;
  	}
  	@filenames = readdir DIR;
  	closedir(DIR);
  
  	for my $FN (@filenames) {
  	    if ($Is_VMS) {
  	    # Big hammer here - Compensate for VMS trailing . and .dir
  	    # No win situation until this is changed, but this
  	    # will handle the majority of the cases with breaking the fewest.
  
  		$FN =~ s/\.dir\z//i;
  		$FN =~ s#\.$## if ($FN ne '.');
  	    }
  	    next if $FN =~ $File::Find::skip_pattern;
  
  	    # follow symbolic links / do an lstat
  	    $new_loc = Follow_SymLink($loc_pref.$FN);
  
  	    # ignore if invalid symlink
  	    unless (defined $new_loc) {
  	        if (!defined -l _ && $dangling_symlinks) {
  	            if (ref $dangling_symlinks eq 'CODE') {
  	                $dangling_symlinks->($FN, $dir_pref);
  	            } else {
  	                warnings::warnif "$dir_pref$FN is a dangling symbolic link\n";
  	            }
  	        }
  
  	        $fullname = undef;
  	        $name = $dir_pref . $FN;
  	        $_ = ($no_chdir ? $name : $FN);
  	        { $wanted_callback->() };
  	        next;
  	    }
  
  	    if (-d _) {
  		if ($Is_VMS) {
  		    $FN =~ s/\.dir\z//i;
  		    $FN =~ s#\.$## if ($FN ne '.');
  		    $new_loc =~ s/\.dir\z//i;
  		    $new_loc =~ s#\.$## if ($new_loc ne '.');
  		}
  		push @Stack,[$new_loc,$updir_loc,$dir_name,$FN,1];
  	    }
  	    else {
  		$fullname = $new_loc; # $File::Find::fullname
  		$name = $dir_pref . $FN; # $File::Find::name
  		$_ = ($no_chdir ? $name : $FN); # $_
  		{ $wanted_callback->() }; # protect against wild "next"
  	    }
  	}
  
      }
      continue {
  	while (defined($SE = pop @Stack)) {
  	    ($dir_loc, $updir_loc, $p_dir, $dir_rel, $byd_flag) = @$SE;
  	    $dir_name = ($p_dir eq '/' ? "/$dir_rel" : "$p_dir/$dir_rel");
  	    $dir_pref = "$dir_name/";
  	    $loc_pref = "$dir_loc/";
  	    if ( $byd_flag < 0 ) {  # must be finddepth, report dirname now
  		unless ($no_chdir || ($dir_rel eq $File::Find::current_dir)) {
  		    unless (chdir $updir_loc) { # $updir_loc (parent dir) is always untainted
  			warnings::warnif "Can't cd to $updir_loc: $!\n";
  			next;
  		    }
  		}
  		$fullname = $dir_loc; # $File::Find::fullname
  		$name = $dir_name; # $File::Find::name
  		if ( substr($name,-2) eq '/.' ) {
  		    substr($name, length($name) == 2 ? -1 : -2) = ''; # $File::Find::name
  		}
  		$dir = $p_dir; # $File::Find::dir
  		$_ = ($no_chdir ? $dir_name : $dir_rel); # $_
  		if ( substr($_,-2) eq '/.' ) {
  		    substr($_, length($_) == 2 ? -1 : -2) = '';
  		}
  
  		lstat($_); # make sure file tests with '_' work
  		{ $wanted_callback->() }; # protect against wild "next"
  	    }
  	    else {
  		push @Stack,[$dir_loc, $updir_loc, $p_dir, $dir_rel,-1]  if  $bydepth;
  		last;
  	    }
  	}
      }
  }
  
  
  sub wrap_wanted {
      my $wanted = shift;
      if ( ref($wanted) eq 'HASH' ) {
          unless( exists $wanted->{wanted} and ref( $wanted->{wanted} ) eq 'CODE' ) {
              die 'no &wanted subroutine given';
          }
  	if ( $wanted->{follow} || $wanted->{follow_fast}) {
  	    $wanted->{follow_skip} = 1 unless defined $wanted->{follow_skip};
  	}
  	if ( $wanted->{untaint} ) {
  	    $wanted->{untaint_pattern} = $File::Find::untaint_pattern
  		unless defined $wanted->{untaint_pattern};
  	    $wanted->{untaint_skip} = 0 unless defined $wanted->{untaint_skip};
  	}
  	return $wanted;
      }
      elsif( ref( $wanted ) eq 'CODE' ) {
  	return { wanted => $wanted };
      }
      else {
         die 'no &wanted subroutine given';
      }
  }
  
  sub find {
      my $wanted = shift;
      _find_opt(wrap_wanted($wanted), @_);
  }
  
  sub finddepth {
      my $wanted = wrap_wanted(shift);
      $wanted->{bydepth} = 1;
      _find_opt($wanted, @_);
  }
  
  # default
  $File::Find::skip_pattern    = qr/^\.{1,2}\z/;
  $File::Find::untaint_pattern = qr|^([-+@\w./]+)$|;
  
  # These are hard-coded for now, but may move to hint files.
  if ($^O eq 'VMS') {
      $Is_VMS = 1;
      $File::Find::dont_use_nlink  = 1;
  }
  elsif ($^O eq 'MSWin32') {
      $Is_Win32 = 1;
  }
  
  # this _should_ work properly on all platforms
  # where File::Find can be expected to work
  $File::Find::current_dir = File::Spec->curdir || '.';
  
  $File::Find::dont_use_nlink = 1
      if $^O eq 'os2' || $^O eq 'dos' || $^O eq 'amigaos' || $Is_Win32 ||
         $^O eq 'interix' || $^O eq 'cygwin' || $^O eq 'qnx' || $^O eq 'nto';
  
  # Set dont_use_nlink in your hint file if your system's stat doesn't
  # report the number of links in a directory as an indication
  # of the number of files.
  # See, e.g. hints/machten.sh for MachTen 2.2.
  unless ($File::Find::dont_use_nlink) {
      require Config;
      $File::Find::dont_use_nlink = 1 if ($Config::Config{'dont_use_nlink'});
  }
  
  # We need a function that checks if a scalar is tainted. Either use the
  # Scalar::Util module's tainted() function or our (slower) pure Perl
  # fallback is_tainted_pp()
  {
      local $@;
      eval { require Scalar::Util };
      *is_tainted = $@ ? \&is_tainted_pp : \&Scalar::Util::tainted;
  }
  
  1;
FILE_FIND

$fatpacked{"File/Glob.pm"} = <<'FILE_GLOB';
  package File::Glob;
  
  use strict;
  our($VERSION, @ISA, @EXPORT_OK, @EXPORT_FAIL, %EXPORT_TAGS, $DEFAULT_FLAGS);
  
  require XSLoader;
  
  @ISA = qw(Exporter);
  
  # NOTE: The glob() export is only here for compatibility with 5.6.0.
  # csh_glob() should not be used directly, unless you know what you're doing.
  
  %EXPORT_TAGS = (
      'glob' => [ qw(
          GLOB_ABEND
  	GLOB_ALPHASORT
          GLOB_ALTDIRFUNC
          GLOB_BRACE
          GLOB_CSH
          GLOB_ERR
          GLOB_ERROR
          GLOB_LIMIT
          GLOB_MARK
          GLOB_NOCASE
          GLOB_NOCHECK
          GLOB_NOMAGIC
          GLOB_NOSORT
          GLOB_NOSPACE
          GLOB_QUOTE
          GLOB_TILDE
          bsd_glob
          glob
      ) ],
  );
  $EXPORT_TAGS{bsd_glob} = [@{$EXPORT_TAGS{glob}}];
  pop @{$EXPORT_TAGS{bsd_glob}}; # no "glob"
  
  @EXPORT_OK   = (@{$EXPORT_TAGS{'glob'}}, 'csh_glob');
  
  $VERSION = '1.20';
  
  sub import {
      require Exporter;
      local $Exporter::ExportLevel = $Exporter::ExportLevel + 1;
      Exporter::import(grep {
          my $passthrough;
          if ($_ eq ':case') {
              $DEFAULT_FLAGS &= ~GLOB_NOCASE()
          }
          elsif ($_ eq ':nocase') {
              $DEFAULT_FLAGS |= GLOB_NOCASE();
          }
          elsif ($_ eq ':globally') {
  	    no warnings 'redefine';
  	    *CORE::GLOBAL::glob = \&File::Glob::csh_glob;
  	}
          elsif ($_ eq ':bsd_glob') {
  	    no strict; *{caller."::glob"} = \&bsd_glob_override;
              $passthrough = 1;
  	}
  	else {
              $passthrough = 1;
          }
          $passthrough;
      } @_);
  }
  
  XSLoader::load();
  
  $DEFAULT_FLAGS = GLOB_CSH();
  if ($^O =~ /^(?:MSWin32|VMS|os2|dos|riscos)$/) {
      $DEFAULT_FLAGS |= GLOB_NOCASE();
  }
  
  # File::Glob::glob() is deprecated because its prototype is different from
  # CORE::glob() (use bsd_glob() instead)
  sub glob {
      splice @_, 1; # no flags
      goto &bsd_glob;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Glob - Perl extension for BSD glob routine
  
  =head1 SYNOPSIS
  
    use File::Glob ':bsd_glob';
  
    @list = bsd_glob('*.[ch]');
    $homedir = bsd_glob('~gnat', GLOB_TILDE | GLOB_ERR);
  
    if (GLOB_ERROR) {
      # an error occurred reading $homedir
    }
  
    ## override the core glob (CORE::glob() does this automatically
    ## by default anyway, since v5.6.0)
    use File::Glob ':globally';
    my @sources = <*.{c,h,y}>;
  
    ## override the core glob, forcing case sensitivity
    use File::Glob qw(:globally :case);
    my @sources = <*.{c,h,y}>;
  
    ## override the core glob forcing case insensitivity
    use File::Glob qw(:globally :nocase);
    my @sources = <*.{c,h,y}>;
  
    ## glob on all files in home directory
    use File::Glob ':globally';
    my @sources = <~gnat/*>;
  
  =head1 DESCRIPTION
  
  The glob angle-bracket operator C<< <> >> is a pathname generator that
  implements the rules for file name pattern matching used by Unix-like shells
  such as the Bourne shell or C shell.
  
  File::Glob::bsd_glob() implements the FreeBSD glob(3) routine, which is
  a superset of the POSIX glob() (described in IEEE Std 1003.2 "POSIX.2").
  bsd_glob() takes a mandatory C<pattern> argument, and an optional
  C<flags> argument, and returns a list of filenames matching the
  pattern, with interpretation of the pattern modified by the C<flags>
  variable.
  
  Since v5.6.0, Perl's CORE::glob() is implemented in terms of bsd_glob().
  Note that they don't share the same prototype--CORE::glob() only accepts
  a single argument.  Due to historical reasons, CORE::glob() will also
  split its argument on whitespace, treating it as multiple patterns,
  whereas bsd_glob() considers them as one pattern.  But see C<:bsd_glob>
  under L</EXPORTS>, below.
  
  =head2 META CHARACTERS
  
    \       Quote the next metacharacter
    []      Character class
    {}      Multiple pattern
    *       Match any string of characters
    ?       Match any single character
    ~       User name home directory
  
  The metanotation C<a{b,c,d}e> is a shorthand for C<abe ace ade>.  Left to
  right order is preserved, with results of matches being sorted separately
  at a low level to preserve this order.  As a special case C<{>, C<}>, and
  C<{}> are passed undisturbed.
  
  =head2 EXPORTS
  
  See also the L</POSIX FLAGS> below, which can be exported individually.
  
  =head3 C<:bsd_glob>
  
  The C<:bsd_glob> export tag exports bsd_glob() and the constants listed
  below.  It also overrides glob() in the calling package with one that
  behaves like bsd_glob() with regard to spaces (the space is treated as part
  of a file name), but supports iteration in scalar context; i.e., it
  preserves the core function's feature of returning the next item each time
  it is called.
  
  =head3 C<:glob>
  
  The C<:glob> tag, now discouraged, is the old version of C<:bsd_glob>.  It
  exports the same constants and functions, but its glob() override does not
  support iteration; it returns the last file name in scalar context.  That
  means this will loop forever:
  
      use File::Glob ':glob';
      while (my $file = <* copy.txt>) {
  	...
      }
  
  =head3 C<bsd_glob>
  
  This function, which is included in the two export tags listed above,
  takes one or two arguments.  The first is the glob pattern.  The second is
  a set of flags ORed together.  The available flags are listed below under
  L</POSIX FLAGS>.  If the second argument is omitted, C<GLOB_CSH> (or
  C<GLOB_CSH|GLOB_NOCASE> on VMS and DOSish systems) is used by default.
  
  =head3 C<:nocase> and C<:case>
  
  These two export tags globally modify the default flags that bsd_glob()
  and, except on VMS, Perl's built-in C<glob> operator use.  C<GLOB_NOCASE>
  is turned on or off, respectively.
  
  =head3 C<csh_glob>
  
  The csh_glob() function can also be exported, but you should not use it
  directly unless you really know what you are doing.  It splits the pattern
  into words and feeds each one to bsd_glob().  Perl's own glob() function
  uses this internally.
  
  =head2 POSIX FLAGS
  
  The POSIX defined flags for bsd_glob() are:
  
  =over 4
  
  =item C<GLOB_ERR>
  
  Force bsd_glob() to return an error when it encounters a directory it
  cannot open or read.  Ordinarily bsd_glob() continues to find matches.
  
  =item C<GLOB_LIMIT>
  
  Make bsd_glob() return an error (GLOB_NOSPACE) when the pattern expands
  to a size bigger than the system constant C<ARG_MAX> (usually found in
  limits.h).  If your system does not define this constant, bsd_glob() uses
  C<sysconf(_SC_ARG_MAX)> or C<_POSIX_ARG_MAX> where available (in that
  order).  You can inspect these values using the standard C<POSIX>
  extension.
  
  =item C<GLOB_MARK>
  
  Each pathname that is a directory that matches the pattern has a slash
  appended.
  
  =item C<GLOB_NOCASE>
  
  By default, file names are assumed to be case sensitive; this flag
  makes bsd_glob() treat case differences as not significant.
  
  =item C<GLOB_NOCHECK>
  
  If the pattern does not match any pathname, then bsd_glob() returns a list
  consisting of only the pattern.  If C<GLOB_QUOTE> is set, its effect
  is present in the pattern returned.
  
  =item C<GLOB_NOSORT>
  
  By default, the pathnames are sorted in ascending ASCII order; this
  flag prevents that sorting (speeding up bsd_glob()).
  
  =back
  
  The FreeBSD extensions to the POSIX standard are the following flags:
  
  =over 4
  
  =item C<GLOB_BRACE>
  
  Pre-process the string to expand C<{pat,pat,...}> strings like csh(1).
  The pattern '{}' is left unexpanded for historical reasons (and csh(1)
  does the same thing to ease typing of find(1) patterns).
  
  =item C<GLOB_NOMAGIC>
  
  Same as C<GLOB_NOCHECK> but it only returns the pattern if it does not
  contain any of the special characters "*", "?" or "[".  C<NOMAGIC> is
  provided to simplify implementing the historic csh(1) globbing
  behaviour and should probably not be used anywhere else.
  
  =item C<GLOB_QUOTE>
  
  Use the backslash ('\') character for quoting: every occurrence of a
  backslash followed by a character in the pattern is replaced by that
  character, avoiding any special interpretation of the character.
  (But see below for exceptions on DOSISH systems).
  
  =item C<GLOB_TILDE>
  
  Expand patterns that start with '~' to user name home directories.
  
  =item C<GLOB_CSH>
  
  For convenience, C<GLOB_CSH> is a synonym for
  C<GLOB_BRACE | GLOB_NOMAGIC | GLOB_QUOTE | GLOB_TILDE | GLOB_ALPHASORT>.
  
  =back
  
  The POSIX provided C<GLOB_APPEND>, C<GLOB_DOOFFS>, and the FreeBSD
  extensions C<GLOB_ALTDIRFUNC>, and C<GLOB_MAGCHAR> flags have not been
  implemented in the Perl version because they involve more complex
  interaction with the underlying C structures.
  
  The following flag has been added in the Perl implementation for
  csh compatibility:
  
  =over 4
  
  =item C<GLOB_ALPHASORT>
  
  If C<GLOB_NOSORT> is not in effect, sort filenames is alphabetical
  order (case does not matter) rather than in ASCII order.
  
  =back
  
  =head1 DIAGNOSTICS
  
  bsd_glob() returns a list of matching paths, possibly zero length.  If an
  error occurred, &File::Glob::GLOB_ERROR will be non-zero and C<$!> will be
  set.  &File::Glob::GLOB_ERROR is guaranteed to be zero if no error occurred,
  or one of the following values otherwise:
  
  =over 4
  
  =item C<GLOB_NOSPACE>
  
  An attempt to allocate memory failed.
  
  =item C<GLOB_ABEND>
  
  The glob was stopped because an error was encountered.
  
  =back
  
  In the case where bsd_glob() has found some matching paths, but is
  interrupted by an error, it will return a list of filenames B<and>
  set &File::Glob::ERROR.
  
  Note that bsd_glob() deviates from POSIX and FreeBSD glob(3) behaviour
  by not considering C<ENOENT> and C<ENOTDIR> as errors - bsd_glob() will
  continue processing despite those errors, unless the C<GLOB_ERR> flag is
  set.
  
  Be aware that all filenames returned from File::Glob are tainted.
  
  =head1 NOTES
  
  =over 4
  
  =item *
  
  If you want to use multiple patterns, e.g. C<bsd_glob("a* b*")>, you should
  probably throw them in a set as in C<bsd_glob("{a*,b*}")>.  This is because
  the argument to bsd_glob() isn't subjected to parsing by the C shell.
  Remember that you can use a backslash to escape things.
  
  =item *
  
  On DOSISH systems, backslash is a valid directory separator character.
  In this case, use of backslash as a quoting character (via GLOB_QUOTE)
  interferes with the use of backslash as a directory separator.  The
  best (simplest, most portable) solution is to use forward slashes for
  directory separators, and backslashes for quoting.  However, this does
  not match "normal practice" on these systems.  As a concession to user
  expectation, therefore, backslashes (under GLOB_QUOTE) only quote the
  glob metacharacters '[', ']', '{', '}', '-', '~', and backslash itself.
  All other backslashes are passed through unchanged.
  
  =item *
  
  Win32 users should use the real slash.  If you really want to use
  backslashes, consider using Sarathy's File::DosGlob, which comes with
  the standard Perl distribution.
  
  =back
  
  =head1 SEE ALSO
  
  L<perlfunc/glob>, glob(3)
  
  =head1 AUTHOR
  
  The Perl interface was written by Nathan Torkington E<lt>gnat@frii.comE<gt>,
  and is released under the artistic license.  Further modifications were
  made by Greg Bacon E<lt>gbacon@cs.uah.eduE<gt>, Gurusamy Sarathy
  E<lt>gsar@activestate.comE<gt>, and Thomas Wegner
  E<lt>wegner_thomas@yahoo.comE<gt>.  The C glob code has the
  following copyright:
  
      Copyright (c) 1989, 1993 The Regents of the University of California.
      All rights reserved.
  
      This code is derived from software contributed to Berkeley by
      Guido van Rossum.
  
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions
      are met:
  
      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in the
         documentation and/or other materials provided with the distribution.
      3. Neither the name of the University nor the names of its contributors
         may be used to endorse or promote products derived from this software
         without specific prior written permission.
  
      THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS "AS IS" AND
      ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
      FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
      DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
      OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
      HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
      LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
      OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
      SUCH DAMAGE.
  
  =cut
FILE_GLOB

$fatpacked{"File/GlobMapper.pm"} = <<'FILE_GLOBMAPPER';
  package File::GlobMapper;
  
  use strict;
  use warnings;
  use Carp;
  
  our ($CSH_GLOB);
  
  BEGIN
  {
      if ($] < 5.006)
      { 
          require File::BSDGlob; import File::BSDGlob qw(:glob) ;
          $CSH_GLOB = File::BSDGlob::GLOB_CSH() ;
          *globber = \&File::BSDGlob::csh_glob;
      }  
      else
      { 
          require File::Glob; import File::Glob qw(:glob) ;
          $CSH_GLOB = File::Glob::GLOB_CSH() ;
          #*globber = \&File::Glob::bsd_glob;
          *globber = \&File::Glob::csh_glob;
      }  
  }
  
  our ($Error);
  
  our ($VERSION, @EXPORT_OK);
  $VERSION = '1.000';
  @EXPORT_OK = qw( globmap );
  
  
  our ($noPreBS, $metachars, $matchMetaRE, %mapping, %wildCount);
  $noPreBS = '(?<!\\\)' ; # no preceding backslash
  $metachars = '.*?[](){}';
  $matchMetaRE = '[' . quotemeta($metachars) . ']';
  
  %mapping = (
                  '*' => '([^/]*)',
                  '?' => '([^/])',
                  '.' => '\.',
                  '[' => '([',
                  '(' => '(',
                  ')' => ')',
             );
  
  %wildCount = map { $_ => 1 } qw/ * ? . { ( [ /;           
  
  sub globmap ($$;)
  {
      my $inputGlob = shift ;
      my $outputGlob = shift ;
  
      my $obj = new File::GlobMapper($inputGlob, $outputGlob, @_)
          or croak "globmap: $Error" ;
      return $obj->getFileMap();
  }
  
  sub new
  {
      my $class = shift ;
      my $inputGlob = shift ;
      my $outputGlob = shift ;
      # TODO -- flags needs to default to whatever File::Glob does
      my $flags = shift || $CSH_GLOB ;
      #my $flags = shift ;
  
      $inputGlob =~ s/^\s*\<\s*//;
      $inputGlob =~ s/\s*\>\s*$//;
  
      $outputGlob =~ s/^\s*\<\s*//;
      $outputGlob =~ s/\s*\>\s*$//;
  
      my %object =
              (   InputGlob   => $inputGlob,
                  OutputGlob  => $outputGlob,
                  GlobFlags   => $flags,
                  Braces      => 0,
                  WildCount   => 0,
                  Pairs       => [],
                  Sigil       => '#',
              );
  
      my $self = bless \%object, ref($class) || $class ;
  
      $self->_parseInputGlob()
          or return undef ;
  
      $self->_parseOutputGlob()
          or return undef ;
      
      my @inputFiles = globber($self->{InputGlob}, $flags) ;
  
      if (GLOB_ERROR)
      {
          $Error = $!;
          return undef ;
      }
  
      #if (whatever)
      {
          my $missing = grep { ! -e $_ } @inputFiles ;
  
          if ($missing)
          {
              $Error = "$missing input files do not exist";
              return undef ;
          }
      }
  
      $self->{InputFiles} = \@inputFiles ;
  
      $self->_getFiles()
          or return undef ;
  
      return $self;
  }
  
  sub _retError
  {
      my $string = shift ;
      $Error = "$string in input fileglob" ;
      return undef ;
  }
  
  sub _unmatched
  {
      my $delimeter = shift ;
  
      _retError("Unmatched $delimeter");
      return undef ;
  }
  
  sub _parseBit
  {
      my $self = shift ;
  
      my $string = shift ;
  
      my $out = '';
      my $depth = 0 ;
  
      while ($string =~ s/(.*?)$noPreBS(,|$matchMetaRE)//)
      {
          $out .= quotemeta($1) ;
          $out .= $mapping{$2} if defined $mapping{$2};
  
          ++ $self->{WildCount} if $wildCount{$2} ;
  
          if ($2 eq ',')
          { 
              return _unmatched "("
                  if $depth ;
              
              $out .= '|';
          }
          elsif ($2 eq '(')
          { 
              ++ $depth ;
          }
          elsif ($2 eq ')')
          { 
              return _unmatched ")"
                  if ! $depth ;
  
              -- $depth ;
          }
          elsif ($2 eq '[')
          {
              # TODO -- quotemeta & check no '/'
              # TODO -- check for \]  & other \ within the []
              $string =~ s#(.*?\])##
                  or return _unmatched "[" ;
              $out .= "$1)" ;
          }
          elsif ($2 eq ']')
          {
              return _unmatched "]" ;
          }
          elsif ($2 eq '{' || $2 eq '}')
          {
              return _retError "Nested {} not allowed" ;
          }
      }
  
      $out .= quotemeta $string;
  
      return _unmatched "("
          if $depth ;
  
      return $out ;
  }
  
  sub _parseInputGlob
  {
      my $self = shift ;
  
      my $string = $self->{InputGlob} ;
      my $inGlob = '';
  
      # Multiple concatenated *'s don't make sense
      #$string =~ s#\*\*+#*# ;
  
      # TODO -- Allow space to delimit patterns?
      #my @strings = split /\s+/, $string ;
      #for my $str (@strings)
      my $out = '';
      my $depth = 0 ;
  
      while ($string =~ s/(.*?)$noPreBS($matchMetaRE)//)
      {
          $out .= quotemeta($1) ;
          $out .= $mapping{$2} if defined $mapping{$2};
          ++ $self->{WildCount} if $wildCount{$2} ;
  
          if ($2 eq '(')
          { 
              ++ $depth ;
          }
          elsif ($2 eq ')')
          { 
              return _unmatched ")"
                  if ! $depth ;
  
              -- $depth ;
          }
          elsif ($2 eq '[')
          {
              # TODO -- quotemeta & check no '/' or '(' or ')'
              # TODO -- check for \]  & other \ within the []
              $string =~ s#(.*?\])##
                  or return _unmatched "[";
              $out .= "$1)" ;
          }
          elsif ($2 eq ']')
          {
              return _unmatched "]" ;
          }
          elsif ($2 eq '}')
          {
              return _unmatched "}" ;
          }
          elsif ($2 eq '{')
          {
              # TODO -- check no '/' within the {}
              # TODO -- check for \}  & other \ within the {}
  
              my $tmp ;
              unless ( $string =~ s/(.*?)$noPreBS\}//)
              {
                  return _unmatched "{";
              }
              #$string =~ s#(.*?)\}##;
  
              #my $alt = join '|', 
              #          map { quotemeta $_ } 
              #          split "$noPreBS,", $1 ;
              my $alt = $self->_parseBit($1);
              defined $alt or return 0 ;
              $out .= "($alt)" ;
  
              ++ $self->{Braces} ;
          }
      }
  
      return _unmatched "("
          if $depth ;
  
      $out .= quotemeta $string ;
  
  
      $self->{InputGlob} =~ s/$noPreBS[\(\)]//g;
      $self->{InputPattern} = $out ;
  
      #print "# INPUT '$self->{InputGlob}' => '$out'\n";
  
      return 1 ;
  
  }
  
  sub _parseOutputGlob
  {
      my $self = shift ;
  
      my $string = $self->{OutputGlob} ;
      my $maxwild = $self->{WildCount};
  
      if ($self->{GlobFlags} & GLOB_TILDE)
      #if (1)
      {
          $string =~ s{
                ^ ~             # find a leading tilde
                (               # save this in $1
                    [^/]        # a non-slash character
                          *     # repeated 0 or more times (0 means me)
                )
              }{
                $1
                    ? (getpwnam($1))[7]
                    : ( $ENV{HOME} || $ENV{LOGDIR} )
              }ex;
  
      }
  
      # max #1 must be == to max no of '*' in input
      while ( $string =~ m/#(\d)/g )
      {
          croak "Max wild is #$maxwild, you tried #$1"
              if $1 > $maxwild ;
      }
  
      my $noPreBS = '(?<!\\\)' ; # no preceding backslash
      #warn "noPreBS = '$noPreBS'\n";
  
      #$string =~ s/${noPreBS}\$(\d)/\${$1}/g;
      $string =~ s/${noPreBS}#(\d)/\${$1}/g;
      $string =~ s#${noPreBS}\*#\${inFile}#g;
      $string = '"' . $string . '"';
  
      #print "OUTPUT '$self->{OutputGlob}' => '$string'\n";
      $self->{OutputPattern} = $string ;
  
      return 1 ;
  }
  
  sub _getFiles
  {
      my $self = shift ;
  
      my %outInMapping = ();
      my %inFiles = () ;
  
      foreach my $inFile (@{ $self->{InputFiles} })
      {
          next if $inFiles{$inFile} ++ ;
  
          my $outFile = $inFile ;
  
          if ( $inFile =~ m/$self->{InputPattern}/ )
          {
              no warnings 'uninitialized';
              eval "\$outFile = $self->{OutputPattern};" ;
  
              if (defined $outInMapping{$outFile})
              {
                  $Error =  "multiple input files map to one output file";
                  return undef ;
              }
              $outInMapping{$outFile} = $inFile;
              push @{ $self->{Pairs} }, [$inFile, $outFile];
          }
      }
  
      return 1 ;
  }
  
  sub getFileMap
  {
      my $self = shift ;
  
      return $self->{Pairs} ;
  }
  
  sub getHash
  {
      my $self = shift ;
  
      return { map { $_->[0] => $_->[1] } @{ $self->{Pairs} } } ;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::GlobMapper - Extend File Glob to Allow Input and Output Files
  
  =head1 SYNOPSIS
  
      use File::GlobMapper qw( globmap );
  
      my $aref = globmap $input => $output
          or die $File::GlobMapper::Error ;
  
      my $gm = new File::GlobMapper $input => $output
          or die $File::GlobMapper::Error ;
  
  
  =head1 DESCRIPTION
  
  This module needs Perl5.005 or better.
  
  This module takes the existing C<File::Glob> module as a starting point and
  extends it to allow new filenames to be derived from the files matched by
  C<File::Glob>.
  
  This can be useful when carrying out batch operations on multiple files that
  have both an input filename and output filename and the output file can be
  derived from the input filename. Examples of operations where this can be
  useful include, file renaming, file copying and file compression.
  
  
  =head2 Behind The Scenes
  
  To help explain what C<File::GlobMapper> does, consider what code you
  would write if you wanted to rename all files in the current directory
  that ended in C<.tar.gz> to C<.tgz>. So say these files are in the
  current directory
  
      alpha.tar.gz
      beta.tar.gz
      gamma.tar.gz
  
  and they need renamed to this
  
      alpha.tgz
      beta.tgz
      gamma.tgz
  
  Below is a possible implementation of a script to carry out the rename
  (error cases have been omitted)
  
      foreach my $old ( glob "*.tar.gz" )
      {
          my $new = $old;
          $new =~ s#(.*)\.tar\.gz$#$1.tgz# ;
  
          rename $old => $new 
              or die "Cannot rename '$old' to '$new': $!\n;
      }
  
  Notice that a file glob pattern C<*.tar.gz> was used to match the
  C<.tar.gz> files, then a fairly similar regular expression was used in
  the substitute to allow the new filename to be created.
  
  Given that the file glob is just a cut-down regular expression and that it
  has already done a lot of the hard work in pattern matching the filenames,
  wouldn't it be handy to be able to use the patterns in the fileglob to
  drive the new filename?
  
  Well, that's I<exactly> what C<File::GlobMapper> does. 
  
  Here is same snippet of code rewritten using C<globmap>
  
      for my $pair (globmap '<*.tar.gz>' => '<#1.tgz>' )
      {
          my ($from, $to) = @$pair;
          rename $from => $to 
              or die "Cannot rename '$old' to '$new': $!\n;
      }
  
  So how does it work?
  
  Behind the scenes the C<globmap> function does a combination of a
  file glob to match existing filenames followed by a substitute
  to create the new filenames. 
  
  Notice how both parameters to C<globmap> are strings that are delimited by <>.
  This is done to make them look more like file globs - it is just syntactic
  sugar, but it can be handy when you want the strings to be visually
  distinctive. The enclosing <> are optional, so you don't have to use them - in
  fact the first thing globmap will do is remove these delimiters if they are
  present.
  
  The first parameter to C<globmap>, C<*.tar.gz>, is an I<Input File Glob>. 
  Once the enclosing "< ... >" is removed, this is passed (more or
  less) unchanged to C<File::Glob> to carry out a file match.
  
  Next the fileglob C<*.tar.gz> is transformed behind the scenes into a
  full Perl regular expression, with the additional step of wrapping each
  transformed wildcard metacharacter sequence in parenthesis.
  
  In this case the input fileglob C<*.tar.gz> will be transformed into
  this Perl regular expression 
  
      ([^/]*)\.tar\.gz
  
  Wrapping with parenthesis allows the wildcard parts of the Input File
  Glob to be referenced by the second parameter to C<globmap>, C<#1.tgz>,
  the I<Output File Glob>. This parameter operates just like the replacement
  part of a substitute command. The difference is that the C<#1> syntax
  is used to reference sub-patterns matched in the input fileglob, rather
  than the C<$1> syntax that is used with perl regular expressions. In
  this case C<#1> is used to refer to the text matched by the C<*> in the
  Input File Glob. This makes it easier to use this module where the
  parameters to C<globmap> are typed at the command line.
  
  The final step involves passing each filename matched by the C<*.tar.gz>
  file glob through the derived Perl regular expression in turn and
  expanding the output fileglob using it.
  
  The end result of all this is a list of pairs of filenames. By default
  that is what is returned by C<globmap>. In this example the data structure
  returned will look like this
  
       ( ['alpha.tar.gz' => 'alpha.tgz'],
         ['beta.tar.gz'  => 'beta.tgz' ],
         ['gamma.tar.gz' => 'gamma.tgz']
       )
  
  
  Each pair is an array reference with two elements - namely the I<from>
  filename, that C<File::Glob> has matched, and a I<to> filename that is
  derived from the I<from> filename.
  
  
  
  =head2 Limitations
  
  C<File::GlobMapper> has been kept simple deliberately, so it isn't intended to
  solve all filename mapping operations. Under the hood C<File::Glob> (or for
  older versions of Perl, C<File::BSDGlob>) is used to match the files, so you
  will never have the flexibility of full Perl regular expression.
  
  =head2 Input File Glob
  
  The syntax for an Input FileGlob is identical to C<File::Glob>, except
  for the following
  
  =over 5
  
  =item 1.
  
  No nested {}
  
  =item 2.
  
  Whitespace does not delimit fileglobs.
  
  =item 3.
  
  The use of parenthesis can be used to capture parts of the input filename.
  
  =item 4.
  
  If an Input glob matches the same file more than once, only the first
  will be used.
  
  =back
  
  The syntax
  
  =over 5
  
  =item B<~>
  
  =item B<~user>
  
  
  =item B<.>
  
  Matches a literal '.'.
  Equivalent to the Perl regular expression
  
      \.
  
  =item B<*>
  
  Matches zero or more characters, except '/'. Equivalent to the Perl
  regular expression
  
      [^/]*
  
  =item B<?>
  
  Matches zero or one character, except '/'. Equivalent to the Perl
  regular expression
  
      [^/]?
  
  =item B<\>
  
  Backslash is used, as usual, to escape the next character.
  
  =item  B<[]>
  
  Character class.
  
  =item  B<{,}>
  
  Alternation
  
  =item  B<()>
  
  Capturing parenthesis that work just like perl
  
  =back
  
  Any other character it taken literally.
  
  =head2 Output File Glob
  
  The Output File Glob is a normal string, with 2 glob-like features.
  
  The first is the '*' metacharacter. This will be replaced by the complete
  filename matched by the input file glob. So
  
      *.c *.Z
  
  The second is     
  
  Output FileGlobs take the 
  
  =over 5
  
  =item "*"
  
  The "*" character will be replaced with the complete input filename.
  
  =item #1
  
  Patterns of the form /#\d/ will be replaced with the 
  
  =back
  
  =head2 Returned Data
  
  
  =head1 EXAMPLES
  
  =head2 A Rename script
  
  Below is a simple "rename" script that uses C<globmap> to determine the
  source and destination filenames.
  
      use File::GlobMapper qw(globmap) ;
      use File::Copy;
  
      die "rename: Usage rename 'from' 'to'\n"
          unless @ARGV == 2 ;
  
      my $fromGlob = shift @ARGV;
      my $toGlob   = shift @ARGV;
  
      my $pairs = globmap($fromGlob, $toGlob)
          or die $File::GlobMapper::Error;
  
      for my $pair (@$pairs)
      {
          my ($from, $to) = @$pair;
          move $from => $to ;
      }
  
  
  
  Here is an example that renames all c files to cpp.
      
      $ rename '*.c' '#1.cpp'
  
  =head2 A few example globmaps
  
  Below are a few examples of globmaps
  
  To copy all your .c file to a backup directory
  
      '</my/home/*.c>'    '</my/backup/#1.c>'
  
  If you want to compress all    
  
      '</my/home/*.[ch]>'    '<*.gz>'
  
  To uncompress
  
      '</my/home/*.[ch].gz>'    '</my/home/#1.#2>'
  
  =head1 SEE ALSO
  
  L<File::Glob|File::Glob>
  
  =head1 AUTHOR
  
  The I<File::GlobMapper> module was written by Paul Marquess, F<pmqs@cpan.org>.
  
  =head1 COPYRIGHT AND LICENSE
  
  Copyright (c) 2005 Paul Marquess. All rights reserved.
  This program is free software; you can redistribute it and/or
  modify it under the same terms as Perl itself.
FILE_GLOBMAPPER

$fatpacked{"File/Path.pm"} = <<'FILE_PATH';
  package File::Path;
  
  use 5.005_04;
  use strict;
  
  use Cwd 'getcwd';
  use File::Basename ();
  use File::Spec     ();
  
  BEGIN {
      if ($] < 5.006) {
          # can't say 'opendir my $dh, $dirname'
          # need to initialise $dh
          eval "use Symbol";
      }
  }
  
  use Exporter ();
  use vars qw($VERSION @ISA @EXPORT @EXPORT_OK);
  $VERSION   = '2.09';
  @ISA       = qw(Exporter);
  @EXPORT    = qw(mkpath rmtree);
  @EXPORT_OK = qw(make_path remove_tree);
  
  my $Is_VMS     = $^O eq 'VMS';
  my $Is_MacOS   = $^O eq 'MacOS';
  
  # These OSes complain if you want to remove a file that you have no
  # write permission to:
  my $Force_Writeable = grep {$^O eq $_} qw(amigaos dos epoc MSWin32 MacOS os2);
  
  # Unix-like systems need to stat each directory in order to detect
  # race condition. MS-Windows is immune to this particular attack.
  my $Need_Stat_Check = !($^O eq 'MSWin32');
  
  sub _carp {
      require Carp;
      goto &Carp::carp;
  }
  
  sub _croak {
      require Carp;
      goto &Carp::croak;
  }
  
  sub _error {
      my $arg     = shift;
      my $message = shift;
      my $object  = shift;
  
      if ($arg->{error}) {
          $object = '' unless defined $object;
          $message .= ": $!" if $!;
          push @{${$arg->{error}}}, {$object => $message};
      }
      else {
          _carp(defined($object) ? "$message for $object: $!" : "$message: $!");
      }
  }
  
  sub make_path {
      push @_, {} unless @_ and UNIVERSAL::isa($_[-1],'HASH');
      goto &mkpath;
  }
  
  sub mkpath {
      my $old_style = !(@_ and UNIVERSAL::isa($_[-1],'HASH'));
  
      my $arg;
      my $paths;
  
      if ($old_style) {
          my ($verbose, $mode);
          ($paths, $verbose, $mode) = @_;
          $paths = [$paths] unless UNIVERSAL::isa($paths,'ARRAY');
          $arg->{verbose} = $verbose;
          $arg->{mode}    = defined $mode ? $mode : 0777;
      }
      else {
          $arg = pop @_;
          $arg->{mode}      = delete $arg->{mask} if exists $arg->{mask};
          $arg->{mode}      = 0777 unless exists $arg->{mode};
          ${$arg->{error}}  = [] if exists $arg->{error};
          $arg->{owner}     = delete $arg->{user} if exists $arg->{user};
          $arg->{owner}     = delete $arg->{uid}  if exists $arg->{uid};
          if (exists $arg->{owner} and $arg->{owner} =~ /\D/) {
              my $uid = (getpwnam $arg->{owner})[2];
              if (defined $uid) {
                  $arg->{owner} = $uid;
              }
              else {
                  _error($arg, "unable to map $arg->{owner} to a uid, ownership not changed");
                  delete $arg->{owner};
              }
          }
          if (exists $arg->{group} and $arg->{group} =~ /\D/) {
              my $gid = (getgrnam $arg->{group})[2];
              if (defined $gid) {
                  $arg->{group} = $gid;
              }
              else {
                  _error($arg, "unable to map $arg->{group} to a gid, group ownership not changed");
                  delete $arg->{group};
              }
          }
          if (exists $arg->{owner} and not exists $arg->{group}) {
              $arg->{group} = -1; # chown will leave group unchanged
          }
          if (exists $arg->{group} and not exists $arg->{owner}) {
              $arg->{owner} = -1; # chown will leave owner unchanged
          }
          $paths = [@_];
      }
      return _mkpath($arg, $paths);
  }
  
  sub _mkpath {
      my $arg   = shift;
      my $paths = shift;
  
      my(@created,$path);
      foreach $path (@$paths) {
          next unless defined($path) and length($path);
          $path .= '/' if $^O eq 'os2' and $path =~ /^\w:\z/s; # feature of CRT 
          # Logic wants Unix paths, so go with the flow.
          if ($Is_VMS) {
              next if $path eq '/';
              $path = VMS::Filespec::unixify($path);
          }
          next if -d $path;
          my $parent = File::Basename::dirname($path);
          unless (-d $parent or $path eq $parent) {
              push(@created,_mkpath($arg, [$parent]));
          }
          print "mkdir $path\n" if $arg->{verbose};
          if (mkdir($path,$arg->{mode})) {
              push(@created, $path);
              if (exists $arg->{owner}) {
  				# NB: $arg->{group} guaranteed to be set during initialisation
                  if (!chown $arg->{owner}, $arg->{group}, $path) {
                      _error($arg, "Cannot change ownership of $path to $arg->{owner}:$arg->{group}");
                  }
              }
          }
          else {
              my $save_bang = $!;
              my ($e, $e1) = ($save_bang, $^E);
              $e .= "; $e1" if $e ne $e1;
              # allow for another process to have created it meanwhile
              if (!-d $path) {
                  $! = $save_bang;
                  if ($arg->{error}) {
                      push @{${$arg->{error}}}, {$path => $e};
                  }
                  else {
                      _croak("mkdir $path: $e");
                  }
              }
          }
      }
      return @created;
  }
  
  sub remove_tree {
      push @_, {} unless @_ and UNIVERSAL::isa($_[-1],'HASH');
      goto &rmtree;
  }
  
  sub _is_subdir {
      my($dir, $test) = @_;
  
      my($dv, $dd) = File::Spec->splitpath($dir, 1);
      my($tv, $td) = File::Spec->splitpath($test, 1);
  
      # not on same volume
      return 0 if $dv ne $tv;
  
      my @d = File::Spec->splitdir($dd);
      my @t = File::Spec->splitdir($td);
  
      # @t can't be a subdir if it's shorter than @d
      return 0 if @t < @d;
  
      return join('/', @d) eq join('/', splice @t, 0, +@d);
  }
  
  sub rmtree {
      my $old_style = !(@_ and UNIVERSAL::isa($_[-1],'HASH'));
  
      my $arg;
      my $paths;
  
      if ($old_style) {
          my ($verbose, $safe);
          ($paths, $verbose, $safe) = @_;
          $arg->{verbose} = $verbose;
          $arg->{safe}    = defined $safe    ? $safe    : 0;
  
          if (defined($paths) and length($paths)) {
              $paths = [$paths] unless UNIVERSAL::isa($paths,'ARRAY');
          }
          else {
              _carp ("No root path(s) specified\n");
              return 0;
          }
      }
      else {
          $arg = pop @_;
          ${$arg->{error}}  = [] if exists $arg->{error};
          ${$arg->{result}} = [] if exists $arg->{result};
          $paths = [@_];
      }
  
      $arg->{prefix} = '';
      $arg->{depth}  = 0;
  
      my @clean_path;
      $arg->{cwd} = getcwd() or do {
          _error($arg, "cannot fetch initial working directory");
          return 0;
      };
      for ($arg->{cwd}) { /\A(.*)\Z/; $_ = $1 } # untaint
  
      for my $p (@$paths) {
          # need to fixup case and map \ to / on Windows
          my $ortho_root = $^O eq 'MSWin32' ? _slash_lc($p)          : $p;
          my $ortho_cwd  = $^O eq 'MSWin32' ? _slash_lc($arg->{cwd}) : $arg->{cwd};
          my $ortho_root_length = length($ortho_root);
          $ortho_root_length-- if $^O eq 'VMS'; # don't compare '.' with ']'
          if ($ortho_root_length && _is_subdir($ortho_root, $ortho_cwd)) {
              local $! = 0;
              _error($arg, "cannot remove path when cwd is $arg->{cwd}", $p);
              next;
          }
  
          if ($Is_MacOS) {
              $p  = ":$p" unless $p =~ /:/;
              $p .= ":"   unless $p =~ /:\z/;
          }
          elsif ($^O eq 'MSWin32') {
              $p =~ s{[/\\]\z}{};
          }
          else {
              $p =~ s{/\z}{};
          }
          push @clean_path, $p;
      }
  
      @{$arg}{qw(device inode perm)} = (lstat $arg->{cwd})[0,1] or do {
          _error($arg, "cannot stat initial working directory", $arg->{cwd});
          return 0;
      };
  
      return _rmtree($arg, \@clean_path);
  }
  
  sub _rmtree {
      my $arg   = shift;
      my $paths = shift;
  
      my $count  = 0;
      my $curdir = File::Spec->curdir();
      my $updir  = File::Spec->updir();
  
      my (@files, $root);
      ROOT_DIR:
      foreach $root (@$paths) {
          # since we chdir into each directory, it may not be obvious
          # to figure out where we are if we generate a message about
          # a file name. We therefore construct a semi-canonical
          # filename, anchored from the directory being unlinked (as
          # opposed to being truly canonical, anchored from the root (/).
  
          my $canon = $arg->{prefix}
              ? File::Spec->catfile($arg->{prefix}, $root)
              : $root
          ;
  
          my ($ldev, $lino, $perm) = (lstat $root)[0,1,2] or next ROOT_DIR;
  
          if ( -d _ ) {
              $root = VMS::Filespec::vmspath(VMS::Filespec::pathify($root)) if $Is_VMS;
  
              if (!chdir($root)) {
                  # see if we can escalate privileges to get in
                  # (e.g. funny protection mask such as -w- instead of rwx)
                  $perm &= 07777;
                  my $nperm = $perm | 0700;
                  if (!($arg->{safe} or $nperm == $perm or chmod($nperm, $root))) {
                      _error($arg, "cannot make child directory read-write-exec", $canon);
                      next ROOT_DIR;
                  }
                  elsif (!chdir($root)) {
                      _error($arg, "cannot chdir to child", $canon);
                      next ROOT_DIR;
                  }
              }
  
              my ($cur_dev, $cur_inode, $perm) = (stat $curdir)[0,1,2] or do {
                  _error($arg, "cannot stat current working directory", $canon);
                  next ROOT_DIR;
              };
  
              if ($Need_Stat_Check) {
                  ($ldev eq $cur_dev and $lino eq $cur_inode)
                      or _croak("directory $canon changed before chdir, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting.");
              }
  
              $perm &= 07777; # don't forget setuid, setgid, sticky bits
              my $nperm = $perm | 0700;
  
              # notabene: 0700 is for making readable in the first place,
              # it's also intended to change it to writable in case we have
              # to recurse in which case we are better than rm -rf for 
              # subtrees with strange permissions
  
              if (!($arg->{safe} or $nperm == $perm or chmod($nperm, $curdir))) {
                  _error($arg, "cannot make directory read+writeable", $canon);
                  $nperm = $perm;
              }
  
              my $d;
              $d = gensym() if $] < 5.006;
              if (!opendir $d, $curdir) {
                  _error($arg, "cannot opendir", $canon);
                  @files = ();
              }
              else {
                  no strict 'refs';
                  if (!defined ${"\cTAINT"} or ${"\cTAINT"}) {
                      # Blindly untaint dir names if taint mode is
                      # active, or any perl < 5.006
                      @files = map { /\A(.*)\z/s; $1 } readdir $d;
                  }
                  else {
                      @files = readdir $d;
                  }
                  closedir $d;
              }
  
              if ($Is_VMS) {
                  # Deleting large numbers of files from VMS Files-11
                  # filesystems is faster if done in reverse ASCIIbetical order.
                  # include '.' to '.;' from blead patch #31775
                  @files = map {$_ eq '.' ? '.;' : $_} reverse @files;
              }
  
              @files = grep {$_ ne $updir and $_ ne $curdir} @files;
  
              if (@files) {
                  # remove the contained files before the directory itself
                  my $narg = {%$arg};
                  @{$narg}{qw(device inode cwd prefix depth)}
                      = ($cur_dev, $cur_inode, $updir, $canon, $arg->{depth}+1);
                  $count += _rmtree($narg, \@files);
              }
  
              # restore directory permissions of required now (in case the rmdir
              # below fails), while we are still in the directory and may do so
              # without a race via '.'
              if ($nperm != $perm and not chmod($perm, $curdir)) {
                  _error($arg, "cannot reset chmod", $canon);
              }
  
              # don't leave the client code in an unexpected directory
              chdir($arg->{cwd})
                  or _croak("cannot chdir to $arg->{cwd} from $canon: $!, aborting.");
  
              # ensure that a chdir upwards didn't take us somewhere other
              # than we expected (see CVE-2002-0435)
              ($cur_dev, $cur_inode) = (stat $curdir)[0,1]
                  or _croak("cannot stat prior working directory $arg->{cwd}: $!, aborting.");
  
              if ($Need_Stat_Check) {
                  ($arg->{device} eq $cur_dev and $arg->{inode} eq $cur_inode)
                      or _croak("previous directory $arg->{cwd} changed before entering $canon, expected dev=$ldev ino=$lino, actual dev=$cur_dev ino=$cur_inode, aborting.");
              }
  
              if ($arg->{depth} or !$arg->{keep_root}) {
                  if ($arg->{safe} &&
                      ($Is_VMS ? !&VMS::Filespec::candelete($root) : !-w $root)) {
                      print "skipped $root\n" if $arg->{verbose};
                      next ROOT_DIR;
                  }
                  if ($Force_Writeable and !chmod $perm | 0700, $root) {
                      _error($arg, "cannot make directory writeable", $canon);
                  }
                  print "rmdir $root\n" if $arg->{verbose};
                  if (rmdir $root) {
                      push @{${$arg->{result}}}, $root if $arg->{result};
                      ++$count;
                  }
                  else {
                      _error($arg, "cannot remove directory", $canon);
                      if ($Force_Writeable && !chmod($perm, ($Is_VMS ? VMS::Filespec::fileify($root) : $root))
                      ) {
                          _error($arg, sprintf("cannot restore permissions to 0%o",$perm), $canon);
                      }
                  }
              }
          }
          else {
              # not a directory
              $root = VMS::Filespec::vmsify("./$root")
                  if $Is_VMS
                     && !File::Spec->file_name_is_absolute($root)
                     && ($root !~ m/(?<!\^)[\]>]+/);  # not already in VMS syntax
  
              if ($arg->{safe} &&
                  ($Is_VMS ? !&VMS::Filespec::candelete($root)
                           : !(-l $root || -w $root)))
              {
                  print "skipped $root\n" if $arg->{verbose};
                  next ROOT_DIR;
              }
  
              my $nperm = $perm & 07777 | 0600;
              if ($Force_Writeable and $nperm != $perm and not chmod $nperm, $root) {
                  _error($arg, "cannot make file writeable", $canon);
              }
              print "unlink $canon\n" if $arg->{verbose};
              # delete all versions under VMS
              for (;;) {
                  if (unlink $root) {
                      push @{${$arg->{result}}}, $root if $arg->{result};
                  }
                  else {
                      _error($arg, "cannot unlink file", $canon);
                      $Force_Writeable and chmod($perm, $root) or
                          _error($arg, sprintf("cannot restore permissions to 0%o",$perm), $canon);
                      last;
                  }
                  ++$count;
                  last unless $Is_VMS && lstat $root;
              }
          }
      }
      return $count;
  }
  
  sub _slash_lc {
      # fix up slashes and case on MSWin32 so that we can determine that
      # c:\path\to\dir is underneath C:/Path/To
      my $path = shift;
      $path =~ tr{\\}{/};
      return lc($path);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Path - Create or remove directory trees
  
  =head1 VERSION
  
  This document describes version 2.09 of File::Path, released
  2013-01-17.
  
  =head1 SYNOPSIS
  
    use File::Path qw(make_path remove_tree);
  
    make_path('foo/bar/baz', '/zug/zwang');
    make_path('foo/bar/baz', '/zug/zwang', {
        verbose => 1,
        mode => 0711,
    });
  
    remove_tree('foo/bar/baz', '/zug/zwang');
    remove_tree('foo/bar/baz', '/zug/zwang', {
        verbose => 1,
        error  => \my $err_list,
    });
  
    # legacy (interface promoted before v2.00)
    mkpath('/foo/bar/baz');
    mkpath('/foo/bar/baz', 1, 0711);
    mkpath(['/foo/bar/baz', 'blurfl/quux'], 1, 0711);
    rmtree('foo/bar/baz', 1, 1);
    rmtree(['foo/bar/baz', 'blurfl/quux'], 1, 1);
  
    # legacy (interface promoted before v2.06)
    mkpath('foo/bar/baz', '/zug/zwang', { verbose => 1, mode => 0711 });
    rmtree('foo/bar/baz', '/zug/zwang', { verbose => 1, mode => 0711 });
  
  =head1 DESCRIPTION
  
  This module provide a convenient way to create directories of
  arbitrary depth and to delete an entire directory subtree from the
  filesystem.
  
  The following functions are provided:
  
  =over
  
  =item make_path( $dir1, $dir2, .... )
  
  =item make_path( $dir1, $dir2, ...., \%opts )
  
  The C<make_path> function creates the given directories if they don't
  exists before, much like the Unix command C<mkdir -p>.
  
  The function accepts a list of directories to be created. Its
  behaviour may be tuned by an optional hashref appearing as the last
  parameter on the call.
  
  The function returns the list of directories actually created during
  the call; in scalar context the number of directories created.
  
  The following keys are recognised in the option hash:
  
  =over
  
  =item mode => $num
  
  The numeric permissions mode to apply to each created directory
  (defaults to 0777), to be modified by the current C<umask>. If the
  directory already exists (and thus does not need to be created),
  the permissions will not be modified.
  
  C<mask> is recognised as an alias for this parameter.
  
  =item verbose => $bool
  
  If present, will cause C<make_path> to print the name of each directory
  as it is created. By default nothing is printed.
  
  =item error => \$err
  
  If present, it should be a reference to a scalar.
  This scalar will be made to reference an array, which will
  be used to store any errors that are encountered.  See the L</"ERROR
  HANDLING"> section for more information.
  
  If this parameter is not used, certain error conditions may raise
  a fatal error that will cause the program will halt, unless trapped
  in an C<eval> block.
  
  =item owner => $owner
  
  =item user => $owner
  
  =item uid => $owner
  
  If present, will cause any created directory to be owned by C<$owner>.
  If the value is numeric, it will be interpreted as a uid, otherwise
  as username is assumed. An error will be issued if the username cannot be
  mapped to a uid, or the uid does not exist, or the process lacks the
  privileges to change ownership.
  
  Ownwership of directories that already exist will not be changed.
  
  C<user> and C<uid> are aliases of C<owner>.
  
  =item group => $group
  
  If present, will cause any created directory to be owned by the group C<$group>.
  If the value is numeric, it will be interpreted as a gid, otherwise
  as group name is assumed. An error will be issued if the group name cannot be
  mapped to a gid, or the gid does not exist, or the process lacks the
  privileges to change group ownership.
  
  Group ownwership of directories that already exist will not be changed.
  
      make_path '/var/tmp/webcache', {owner=>'nobody', group=>'nogroup'};
  
  =back
  
  =item mkpath( $dir )
  
  =item mkpath( $dir, $verbose, $mode )
  
  =item mkpath( [$dir1, $dir2,...], $verbose, $mode )
  
  =item mkpath( $dir1, $dir2,..., \%opt )
  
  The mkpath() function provide the legacy interface of make_path() with
  a different interpretation of the arguments passed.  The behaviour and
  return value of the function is otherwise identical to make_path().
  
  =item remove_tree( $dir1, $dir2, .... )
  
  =item remove_tree( $dir1, $dir2, ...., \%opts )
  
  The C<remove_tree> function deletes the given directories and any
  files and subdirectories they might contain, much like the Unix
  command C<rm -r> or C<del /s> on Windows.
  
  The function accepts a list of directories to be
  removed. Its behaviour may be tuned by an optional hashref
  appearing as the last parameter on the call.
  
  The functions returns the number of files successfully deleted.
  
  The following keys are recognised in the option hash:
  
  =over
  
  =item verbose => $bool
  
  If present, will cause C<remove_tree> to print the name of each file as
  it is unlinked. By default nothing is printed.
  
  =item safe => $bool
  
  When set to a true value, will cause C<remove_tree> to skip the files
  for which the process lacks the required privileges needed to delete
  files, such as delete privileges on VMS. In other words, the code
  will make no attempt to alter file permissions. Thus, if the process
  is interrupted, no filesystem object will be left in a more
  permissive mode.
  
  =item keep_root => $bool
  
  When set to a true value, will cause all files and subdirectories
  to be removed, except the initially specified directories. This comes
  in handy when cleaning out an application's scratch directory.
  
    remove_tree( '/tmp', {keep_root => 1} );
  
  =item result => \$res
  
  If present, it should be a reference to a scalar.
  This scalar will be made to reference an array, which will
  be used to store all files and directories unlinked
  during the call. If nothing is unlinked, the array will be empty.
  
    remove_tree( '/tmp', {result => \my $list} );
    print "unlinked $_\n" for @$list;
  
  This is a useful alternative to the C<verbose> key.
  
  =item error => \$err
  
  If present, it should be a reference to a scalar.
  This scalar will be made to reference an array, which will
  be used to store any errors that are encountered.  See the L</"ERROR
  HANDLING"> section for more information.
  
  Removing things is a much more dangerous proposition than
  creating things. As such, there are certain conditions that
  C<remove_tree> may encounter that are so dangerous that the only
  sane action left is to kill the program.
  
  Use C<error> to trap all that is reasonable (problems with
  permissions and the like), and let it die if things get out
  of hand. This is the safest course of action.
  
  =back
  
  =item rmtree( $dir )
  
  =item rmtree( $dir, $verbose, $safe )
  
  =item rmtree( [$dir1, $dir2,...], $verbose, $safe )
  
  =item rmtree( $dir1, $dir2,..., \%opt )
  
  The rmtree() function provide the legacy interface of remove_tree()
  with a different interpretation of the arguments passed. The behaviour
  and return value of the function is otherwise identical to
  remove_tree().
  
  =back
  
  =head2 ERROR HANDLING
  
  =over 4
  
  =item B<NOTE:>
  
  The following error handling mechanism is considered
  experimental and is subject to change pending feedback from
  users.
  
  =back
  
  If C<make_path> or C<remove_tree> encounter an error, a diagnostic
  message will be printed to C<STDERR> via C<carp> (for non-fatal
  errors), or via C<croak> (for fatal errors).
  
  If this behaviour is not desirable, the C<error> attribute may be
  used to hold a reference to a variable, which will be used to store
  the diagnostics. The variable is made a reference to an array of hash
  references.  Each hash contain a single key/value pair where the key
  is the name of the file, and the value is the error message (including
  the contents of C<$!> when appropriate).  If a general error is
  encountered the diagnostic key will be empty.
  
  An example usage looks like:
  
    remove_tree( 'foo/bar', 'bar/rat', {error => \my $err} );
    if (@$err) {
        for my $diag (@$err) {
            my ($file, $message) = %$diag;
            if ($file eq '') {
                print "general error: $message\n";
            }
            else {
                print "problem unlinking $file: $message\n";
            }
        }
    }
    else {
        print "No error encountered\n";
    }
  
  Note that if no errors are encountered, C<$err> will reference an
  empty array.  This means that C<$err> will always end up TRUE; so you
  need to test C<@$err> to determine if errors occured.
  
  =head2 NOTES
  
  C<File::Path> blindly exports C<mkpath> and C<rmtree> into the
  current namespace. These days, this is considered bad style, but
  to change it now would break too much code. Nonetheless, you are
  invited to specify what it is you are expecting to use:
  
    use File::Path 'rmtree';
  
  The routines C<make_path> and C<remove_tree> are B<not> exported
  by default. You must specify which ones you want to use.
  
    use File::Path 'remove_tree';
  
  Note that a side-effect of the above is that C<mkpath> and C<rmtree>
  are no longer exported at all. This is due to the way the C<Exporter>
  module works. If you are migrating a codebase to use the new
  interface, you will have to list everything explicitly. But that's
  just good practice anyway.
  
    use File::Path qw(remove_tree rmtree);
  
  =head3 API CHANGES
  
  The API was changed in the 2.0 branch. For a time, C<mkpath> and
  C<rmtree> tried, unsuccessfully, to deal with the two different
  calling mechanisms. This approach was considered a failure.
  
  The new semantics are now only available with C<make_path> and
  C<remove_tree>. The old semantics are only available through
  C<mkpath> and C<rmtree>. Users are strongly encouraged to upgrade
  to at least 2.08 in order to avoid surprises.
  
  =head3 SECURITY CONSIDERATIONS
  
  There were race conditions 1.x implementations of File::Path's
  C<rmtree> function (although sometimes patched depending on the OS
  distribution or platform). The 2.0 version contains code to avoid the
  problem mentioned in CVE-2002-0435.
  
  See the following pages for more information:
  
    http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=286905
    http://www.nntp.perl.org/group/perl.perl5.porters/2005/01/msg97623.html
    http://www.debian.org/security/2005/dsa-696
  
  Additionally, unless the C<safe> parameter is set (or the
  third parameter in the traditional interface is TRUE), should a
  C<remove_tree> be interrupted, files that were originally in read-only
  mode may now have their permissions set to a read-write (or "delete
  OK") mode.
  
  =head1 DIAGNOSTICS
  
  FATAL errors will cause the program to halt (C<croak>), since the
  problem is so severe that it would be dangerous to continue. (This
  can always be trapped with C<eval>, but it's not a good idea. Under
  the circumstances, dying is the best thing to do).
  
  SEVERE errors may be trapped using the modern interface. If the
  they are not trapped, or the old interface is used, such an error
  will cause the program will halt.
  
  All other errors may be trapped using the modern interface, otherwise
  they will be C<carp>ed about. Program execution will not be halted.
  
  =over 4
  
  =item mkdir [path]: [errmsg] (SEVERE)
  
  C<make_path> was unable to create the path. Probably some sort of
  permissions error at the point of departure, or insufficient resources
  (such as free inodes on Unix).
  
  =item No root path(s) specified
  
  C<make_path> was not given any paths to create. This message is only
  emitted if the routine is called with the traditional interface.
  The modern interface will remain silent if given nothing to do.
  
  =item No such file or directory
  
  On Windows, if C<make_path> gives you this warning, it may mean that
  you have exceeded your filesystem's maximum path length.
  
  =item cannot fetch initial working directory: [errmsg]
  
  C<remove_tree> attempted to determine the initial directory by calling
  C<Cwd::getcwd>, but the call failed for some reason. No attempt
  will be made to delete anything.
  
  =item cannot stat initial working directory: [errmsg]
  
  C<remove_tree> attempted to stat the initial directory (after having
  successfully obtained its name via C<getcwd>), however, the call
  failed for some reason. No attempt will be made to delete anything.
  
  =item cannot chdir to [dir]: [errmsg]
  
  C<remove_tree> attempted to set the working directory in order to
  begin deleting the objects therein, but was unsuccessful. This is
  usually a permissions issue. The routine will continue to delete
  other things, but this directory will be left intact.
  
  =item directory [dir] changed before chdir, expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)
  
  C<remove_tree> recorded the device and inode of a directory, and then
  moved into it. It then performed a C<stat> on the current directory
  and detected that the device and inode were no longer the same. As
  this is at the heart of the race condition problem, the program
  will die at this point.
  
  =item cannot make directory [dir] read+writeable: [errmsg]
  
  C<remove_tree> attempted to change the permissions on the current directory
  to ensure that subsequent unlinkings would not run into problems,
  but was unable to do so. The permissions remain as they were, and
  the program will carry on, doing the best it can.
  
  =item cannot read [dir]: [errmsg]
  
  C<remove_tree> tried to read the contents of the directory in order
  to acquire the names of the directory entries to be unlinked, but
  was unsuccessful. This is usually a permissions issue. The
  program will continue, but the files in this directory will remain
  after the call.
  
  =item cannot reset chmod [dir]: [errmsg]
  
  C<remove_tree>, after having deleted everything in a directory, attempted
  to restore its permissions to the original state but failed. The
  directory may wind up being left behind.
  
  =item cannot remove [dir] when cwd is [dir]
  
  The current working directory of the program is F</some/path/to/here>
  and you are attempting to remove an ancestor, such as F</some/path>.
  The directory tree is left untouched.
  
  The solution is to C<chdir> out of the child directory to a place
  outside the directory tree to be removed.
  
  =item cannot chdir to [parent-dir] from [child-dir]: [errmsg], aborting. (FATAL)
  
  C<remove_tree>, after having deleted everything and restored the permissions
  of a directory, was unable to chdir back to the parent. The program
  halts to avoid a race condition from occurring.
  
  =item cannot stat prior working directory [dir]: [errmsg], aborting. (FATAL)
  
  C<remove_tree> was unable to stat the parent directory after have returned
  from the child. Since there is no way of knowing if we returned to
  where we think we should be (by comparing device and inode) the only
  way out is to C<croak>.
  
  =item previous directory [parent-dir] changed before entering [child-dir], expected dev=[n] ino=[n], actual dev=[n] ino=[n], aborting. (FATAL)
  
  When C<remove_tree> returned from deleting files in a child directory, a
  check revealed that the parent directory it returned to wasn't the one
  it started out from. This is considered a sign of malicious activity.
  
  =item cannot make directory [dir] writeable: [errmsg]
  
  Just before removing a directory (after having successfully removed
  everything it contained), C<remove_tree> attempted to set the permissions
  on the directory to ensure it could be removed and failed. Program
  execution continues, but the directory may possibly not be deleted.
  
  =item cannot remove directory [dir]: [errmsg]
  
  C<remove_tree> attempted to remove a directory, but failed. This may because
  some objects that were unable to be removed remain in the directory, or
  a permissions issue. The directory will be left behind.
  
  =item cannot restore permissions of [dir] to [0nnn]: [errmsg]
  
  After having failed to remove a directory, C<remove_tree> was unable to
  restore its permissions from a permissive state back to a possibly
  more restrictive setting. (Permissions given in octal).
  
  =item cannot make file [file] writeable: [errmsg]
  
  C<remove_tree> attempted to force the permissions of a file to ensure it
  could be deleted, but failed to do so. It will, however, still attempt
  to unlink the file.
  
  =item cannot unlink file [file]: [errmsg]
  
  C<remove_tree> failed to remove a file. Probably a permissions issue.
  
  =item cannot restore permissions of [file] to [0nnn]: [errmsg]
  
  After having failed to remove a file, C<remove_tree> was also unable
  to restore the permissions on the file to a possibly less permissive
  setting. (Permissions given in octal).
  
  =item unable to map [owner] to a uid, ownership not changed");
  
  C<make_path> was instructed to give the ownership of created
  directories to the symbolic name [owner], but C<getpwnam> did
  not return the corresponding numeric uid. The directory will
  be created, but ownership will not be changed.
  
  =item unable to map [group] to a gid, group ownership not changed
  
  C<make_path> was instructed to give the group ownership of created
  directories to the symbolic name [group], but C<getgrnam> did
  not return the corresponding numeric gid. The directory will
  be created, but group ownership will not be changed.
  
  =back
  
  =head1 SEE ALSO
  
  =over 4
  
  =item *
  
  L<File::Remove>
  
  Allows files and directories to be moved to the Trashcan/Recycle
  Bin (where they may later be restored if necessary) if the operating
  system supports such functionality. This feature may one day be
  made available directly in C<File::Path>.
  
  =item *
  
  L<File::Find::Rule>
  
  When removing directory trees, if you want to examine each file to
  decide whether to delete it (and possibly leaving large swathes
  alone), F<File::Find::Rule> offers a convenient and flexible approach
  to examining directory trees.
  
  =back
  
  =head1 BUGS
  
  Please report all bugs on the RT queue:
  
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=File-Path>
  
  You can also send pull requests to the Github repository:
  
  L<https://github.com/dland/File-Path>
  
  =head1 ACKNOWLEDGEMENTS
  
  Paul Szabo identified the race condition originally, and Brendan
  O'Dea wrote an implementation for Debian that addressed the problem.
  That code was used as a basis for the current code. Their efforts
  are greatly appreciated.
  
  Gisle Aas made a number of improvements to the documentation for
  2.07 and his advice and assistance is also greatly appreciated.
  
  =head1 AUTHORS
  
  Tim Bunce and Charles Bailey. Currently maintained by David Landgren
  <F<david@landgren.net>>.
  
  =head1 COPYRIGHT
  
  This module is copyright (C) Charles Bailey, Tim Bunce and
  David Landgren 1995-2013. All rights reserved.
  
  =head1 LICENSE
  
  This library is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
FILE_PATH

$fatpacked{"File/Spec.pm"} = <<'FILE_SPEC';
  package File::Spec;
  
  use strict;
  use vars qw(@ISA $VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  my %module = (MacOS   => 'Mac',
  	      MSWin32 => 'Win32',
  	      os2     => 'OS2',
  	      VMS     => 'VMS',
  	      epoc    => 'Epoc',
  	      NetWare => 'Win32', # Yes, File::Spec::Win32 works on NetWare.
  	      symbian => 'Win32', # Yes, File::Spec::Win32 works on symbian.
  	      dos     => 'OS2',   # Yes, File::Spec::OS2 works on DJGPP.
  	      cygwin  => 'Cygwin');
  
  
  my $module = $module{$^O} || 'Unix';
  
  require "File/Spec/$module.pm";
  @ISA = ("File::Spec::$module");
  
  1;
  
  __END__
  
  =head1 NAME
  
  File::Spec - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec;
  
  	$x=File::Spec->catfile('a', 'b', 'c');
  
  which returns 'a/b/c' under Unix. Or:
  
  	use File::Spec::Functions;
  
  	$x = catfile('a', 'b', 'c');
  
  =head1 DESCRIPTION
  
  This module is designed to support operations commonly performed on file
  specifications (usually called "file names", but not to be confused with the
  contents of a file, or Perl's file handles), such as concatenating several
  directory and file names into a single path, or determining whether a path
  is rooted. It is based on code directly taken from MakeMaker 5.17, code
  written by Andreas KE<ouml>nig, Andy Dougherty, Charles Bailey, Ilya
  Zakharevich, Paul Schinder, and others.
  
  Since these functions are different for most operating systems, each set of
  OS specific routines is available in a separate module, including:
  
  	File::Spec::Unix
  	File::Spec::Mac
  	File::Spec::OS2
  	File::Spec::Win32
  	File::Spec::VMS
  
  The module appropriate for the current OS is automatically loaded by
  File::Spec. Since some modules (like VMS) make use of facilities available
  only under that OS, it may not be possible to load all modules under all
  operating systems.
  
  Since File::Spec is object oriented, subroutines should not be called directly,
  as in:
  
  	File::Spec::catfile('a','b');
  
  but rather as class methods:
  
  	File::Spec->catfile('a','b');
  
  For simple uses, L<File::Spec::Functions> provides convenient functional
  forms of these methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  X<canonpath>
  
  No physical check on the filesystem, but a logical cleanup of a
  path.
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =item catdir
  X<catdir>
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS/2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
      $path = File::Spec->catdir( @directories );
  
  =item catfile
  X<catfile>
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
      $path = File::Spec->catfile( @directories, $filename );
  
  =item curdir
  X<curdir>
  
  Returns a string representation of the current directory.
  
      $curdir = File::Spec->curdir();
  
  =item devnull
  X<devnull>
  
  Returns a string representation of the null device.
  
      $devnull = File::Spec->devnull();
  
  =item rootdir
  X<rootdir>
  
  Returns a string representation of the root directory.
  
      $rootdir = File::Spec->rootdir();
  
  =item tmpdir
  X<tmpdir>
  
  Returns a string representation of the first writable directory from a
  list of possible temporary directories.  Returns the current directory
  if no writable temporary directories are found.  The list of directories
  checked depends on the platform; e.g. File::Spec::Unix checks C<$ENV{TMPDIR}>
  (unless taint is on) and F</tmp>.
  
      $tmpdir = File::Spec->tmpdir();
  
  =item updir
  X<updir>
  
  Returns a string representation of the parent directory.
  
      $updir = File::Spec->updir();
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
      @paths = File::Spec->no_upwards( @paths );
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  case is not or is significant when comparing file specifications.
  Cygwin and Win32 accept an optional drive argument.
  
      $is_case_tolerant = File::Spec->case_tolerant();
  
  =item file_name_is_absolute
  
  Takes as its argument a path, and returns true if it is an absolute path.
  
      $is_absolute = File::Spec->file_name_is_absolute( $path );
  
  This does not consult the local filesystem on Unix, Win32, OS/2, or
  Mac OS (Classic).  It does consult the working environment for VMS
  (see L<File::Spec::VMS/file_name_is_absolute>).
  
  =item path
  X<path>
  
  Takes no argument.  Returns the environment variable C<PATH> (or the local
  platform's equivalent) as a list.
  
      @PATH = File::Spec->path();
  
  =item join
  X<join, path>
  
  join is the same as catfile.
  
  =item splitpath
  X<splitpath> X<split, path>
  
  Splits a path in to volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path );
      ($volume,$directories,$file) =
                         File::Spec->splitpath( $path, $no_file );
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless C<$no_file> is true or a
  trailing separator or F</.> or F</..> is present. On Unix, this means that C<$no_file>
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =item splitdir
  X<splitdir> X<split, dir>
  
  The opposite of L</catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  C<$directories> must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSes.
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, C<$volume> is ignored, and directory and file are concatenated.  A '/' is
  inserted if need be.  On other OSes, C<$volume> is significant.
  
      $full_path = File::Spec->catpath( $volume, $directory, $file );
  
  =item abs2rel
  X<abs2rel> X<absolute, path> X<relative, path>
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =item rel2abs()
  X<rel2abs> X<absolute, path> X<relative, path>
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If C<$base> is not present or '', then L<Cwd::cwd()|Cwd> is used. If C<$base> is relative,
  then it is converted to absolute form using L</rel2abs()>. This means that it
  is taken to be relative to L<Cwd::cwd()|Cwd>.
  
  On systems with the concept of volume, if C<$path> and C<$base> appear to be
  on two different volumes, we will not attempt to resolve the two
  paths, and we will instead simply return C<$path>.  Note that previous
  versions of this module ignored the volume of C<$base>, which resulted in
  garbage results part of the time.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  C<$base> filename as well. Otherwise all path components are assumed to be
  directories.
  
  If C<$path> is absolute, it is cleaned up and returned using L</canonpath>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =back
  
  For further information, please see L<File::Spec::Unix>,
  L<File::Spec::Mac>, L<File::Spec::OS2>, L<File::Spec::Win32>, or
  L<File::Spec::VMS>.
  
  =head1 SEE ALSO
  
  L<File::Spec::Unix>, L<File::Spec::Mac>, L<File::Spec::OS2>,
  L<File::Spec::Win32>, L<File::Spec::VMS>, L<File::Spec::Functions>,
  L<ExtUtils::MakeMaker>
  
  =head1 AUTHOR
  
  Currently maintained by Ken Williams C<< <KWILLIAMS@cpan.org> >>.
  
  The vast majority of the code was written by
  Kenneth Albanowski C<< <kjahds@kjahds.com> >>,
  Andy Dougherty C<< <doughera@lafayette.edu> >>,
  Andreas KE<ouml>nig C<< <A.Koenig@franz.ww.TU-Berlin.DE> >>,
  Tim Bunce C<< <Tim.Bunce@ig.co.uk> >>.
  VMS support by Charles Bailey C<< <bailey@newman.upenn.edu> >>.
  OS/2 support by Ilya Zakharevich C<< <ilya@math.ohio-state.edu> >>.
  Mac support by Paul Schinder C<< <schinder@pobox.com> >>, and
  Thomas Wegner C<< <wegner_thomas@yahoo.com> >>.
  abs2rel() and rel2abs() written by Shigio Yamaguchi C<< <shigio@tamacom.com> >>,
  modified by Barrie Slaymaker C<< <barries@slaysys.com> >>.
  splitpath(), splitdir(), catpath() and catdir() by Barrie Slaymaker.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004-2013 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
FILE_SPEC

$fatpacked{"File/Spec/Cygwin.pm"} = <<'FILE_SPEC_CYGWIN';
  package File::Spec::Cygwin;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Cygwin - methods for Cygwin file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Cygwin; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  This module is still in beta.  Cygwin-knowledgeable folks are invited
  to offer patches and suggestions.
  
  =cut
  
  =pod
  
  =over 4
  
  =item canonpath
  
  Any C<\> (backslashes) are converted to C</> (forward slashes),
  and then File::Spec::Unix canonpath() is called on the result.
  
  =cut
  
  sub canonpath {
      my($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|\\|/|g;
  
      # Handle network path names beginning with double slash
      my $node = '';
      if ( $path =~ s@^(//[^/]+)(?:/|\z)@/@s ) {
          $node = $1;
      }
      return $node . $self->SUPER::canonpath($path);
  }
  
  sub catdir {
      my $self = shift;
      return unless @_;
  
      # Don't create something that looks like a //network/path
      if ($_[0] and ($_[0] eq '/' or $_[0] eq '\\')) {
          shift;
          return $self->SUPER::catdir('', @_);
      }
  
      $self->SUPER::catdir(@_);
  }
  
  =pod
  
  =item file_name_is_absolute
  
  True is returned if the file name begins with C<drive_letter:>,
  and if not, File::Spec::Unix file_name_is_absolute() is called.
  
  =cut
  
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return 1 if $file =~ m{^([a-z]:)?[\\/]}is; # C:/test
      return $self->SUPER::file_name_is_absolute($file);
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      /tmp
      $ENV{'TMP'}
      $ENV{'TEMP'}
      C:/temp
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp", $ENV{'TMP'}, $ENV{'TEMP'}, 'C:/temp' );
  }
  
  =item case_tolerant
  
  Override Unix. Cygwin case-tolerance depends on managed mount settings and
  as with MsWin32 on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Default: 1
  
  =cut
  
  sub case_tolerant {
    return 1 unless $^O eq 'cygwin'
      and defined &Cygwin::mount_flags;
  
    my $drive = shift;
    if (! $drive) {
        my @flags = split(/,/, Cygwin::mount_flags('/cygwin'));
        my $prefix = pop(@flags);
        if (! $prefix || $prefix eq 'cygdrive') {
            $drive = '/cygdrive/c';
        } elsif ($prefix eq '/') {
            $drive = '/c';
        } else {
            $drive = "$prefix/c";
        }
    }
    my $mntopts = Cygwin::mount_flags($drive);
    if ($mntopts and ($mntopts =~ /,managed/)) {
      return 0;
    }
    eval { require Win32API::File; } or return 1;
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
  
  1;
FILE_SPEC_CYGWIN

$fatpacked{"File/Spec/Epoc.pm"} = <<'FILE_SPEC_EPOC';
  package File::Spec::Epoc;
  
  use strict;
  use vars qw($VERSION @ISA);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  require File::Spec::Unix;
  @ISA = qw(File::Spec::Unix);
  
  =head1 NAME
  
  File::Spec::Epoc - methods for Epoc file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Epoc; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  This package is still work in progress ;-)
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =pod
  
  =over 4
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  
  =back
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s|/+|/|g;                             # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                        # xx/././xx -> xx/xx
      $path =~ s|^(\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(\.\./)+|/|s;                     # /../../xx -> xx
      $path =~  s|/\Z(?!\n)|| unless $path eq "/";          # xx/       -> xx
      return $path;
  }
  
  =pod
  
  =head1 AUTHOR
  
  o.flebbe@gmx.de
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
FILE_SPEC_EPOC

$fatpacked{"File/Spec/Functions.pm"} = <<'FILE_SPEC_FUNCTIONS';
  package File::Spec::Functions;
  
  use File::Spec;
  use strict;
  
  use vars qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS $VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  require Exporter;
  
  @ISA = qw(Exporter);
  
  @EXPORT = qw(
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  );
  
  @EXPORT_OK = qw(
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  );
  
  %EXPORT_TAGS = ( ALL => [ @EXPORT_OK, @EXPORT ] );
  
  foreach my $meth (@EXPORT, @EXPORT_OK) {
      my $sub = File::Spec->can($meth);
      no strict 'refs';
      *{$meth} = sub {&$sub('File::Spec', @_)};
  }
  
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::Functions - portably perform operations on file names
  
  =head1 SYNOPSIS
  
  	use File::Spec::Functions;
  	$x = catfile('a','b');
  
  =head1 DESCRIPTION
  
  This module exports convenience functions for all of the class methods
  provided by File::Spec.
  
  For a reference of available functions, please consult L<File::Spec::Unix>,
  which contains the entire set, and which is inherited by the modules for
  other platforms. For further information, please see L<File::Spec::Mac>,
  L<File::Spec::OS2>, L<File::Spec::Win32>, or L<File::Spec::VMS>.
  
  =head2 Exports
  
  The following functions are exported by default.
  
  	canonpath
  	catdir
  	catfile
  	curdir
  	rootdir
  	updir
  	no_upwards
  	file_name_is_absolute
  	path
  
  
  The following functions are exported only by request.
  
  	devnull
  	tmpdir
  	splitpath
  	splitdir
  	catpath
  	abs2rel
  	rel2abs
  	case_tolerant
  
  All the functions may be imported using the C<:ALL> tag.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  File::Spec, File::Spec::Unix, File::Spec::Mac, File::Spec::OS2,
  File::Spec::Win32, File::Spec::VMS, ExtUtils::MakeMaker
  
  =cut
  
FILE_SPEC_FUNCTIONS

$fatpacked{"File/Spec/Mac.pm"} = <<'FILE_SPEC_MAC';
  package File::Spec::Mac;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  my $macfiles;
  if ($^O eq 'MacOS') {
  	$macfiles = eval { require Mac::Files };
  }
  
  sub case_tolerant { 1 }
  
  
  =head1 NAME
  
  File::Spec::Mac - File::Spec for Mac OS (Classic)
  
  =head1 SYNOPSIS
  
   require File::Spec::Mac; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath
  
  On Mac OS, there's nothing to be done. Returns what it's given.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return $path;
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a path separated by colons
  (":") ending with a directory. Resulting paths are B<relative> by default,
  but can be forced to be absolute (but avoid this, see below). Automatically
  puts a trailing ":" on the end of the complete path, because that's what's
  done in MacPerl's environment and helps to distinguish a file path from a
  directory path.
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the resulting
  path is relative by default and I<not> absolute. This decision was made due
  to portability reasons. Since C<File::Spec-E<gt>catdir()> returns relative paths
  on all other operating systems, it will now also follow this convention on Mac
  OS. Note that this may break some existing scripts.
  
  The intended purpose of this routine is to concatenate I<directory names>.
  But because of the nature of Macintosh paths, some additional possibilities
  are allowed to make using this routine give reasonable results for some
  common situations. In other words, you are also allowed to concatenate
  I<paths> instead of directory names (strictly speaking, a string like ":a"
  is a path, but not a name, since it contains a punctuation character ":").
  
  So, beside calls like
  
      catdir("a") = ":a:"
      catdir("a","b") = ":a:b:"
      catdir() = ""                    (special case)
  
  calls like the following
  
      catdir(":a:") = ":a:"
      catdir(":a","b") = ":a:b:"
      catdir(":a:","b") = ":a:b:"
      catdir(":a:",":b:") = ":a:b:"
      catdir(":") = ":"
  
  are allowed.
  
  Here are the rules that are used in C<catdir()>; note that we try to be as
  compatible as possible to Unix:
  
  =over 2
  
  =item 1.
  
  The resulting path is relative by default, i.e. the resulting path will have a
  leading colon.
  
  =item 2.
  
  A trailing colon is added automatically to the resulting path, to denote a
  directory.
  
  =item 3.
  
  Generally, each argument has one leading ":" and one trailing ":"
  removed (if any). They are then joined together by a ":". Special
  treatment applies for arguments denoting updir paths like "::lib:",
  see (4), or arguments consisting solely of colons ("colon paths"),
  see (5).
  
  =item 4.
  
  When an updir path like ":::lib::" is passed as argument, the number
  of directories to climb up is handled correctly, not removing leading
  or trailing colons when necessary. E.g.
  
      catdir(":::a","::b","c")    = ":::a::b:c:"
      catdir(":::a::","::b","c")  = ":::a:::b:c:"
  
  =item 5.
  
  Adding a colon ":" or empty string "" to a path at I<any> position
  doesn't alter the path, i.e. these arguments are ignored. (When a ""
  is passed as the first argument, it has a special meaning, see
  (6)). This way, a colon ":" is handled like a "." (curdir) on Unix,
  while an empty string "" is generally ignored (see
  C<Unix-E<gt>canonpath()> ). Likewise, a "::" is handled like a ".."
  (updir), and a ":::" is handled like a "../.." etc.  E.g.
  
      catdir("a",":",":","b")   = ":a:b:"
      catdir("a",":","::",":b") = ":a::b:"
  
  =item 6.
  
  If the first argument is an empty string "" or is a volume name, i.e. matches
  the pattern /^[^:]+:/, the resulting path is B<absolute>.
  
  =item 7.
  
  Passing an empty string "" as the first argument to C<catdir()> is
  like passingC<File::Spec-E<gt>rootdir()> as the first argument, i.e.
  
      catdir("","a","b")          is the same as
  
      catdir(rootdir(),"a","b").
  
  This is true on Unix, where C<catdir("","a","b")> yields "/a/b" and
  C<rootdir()> is "/". Note that C<rootdir()> on Mac OS is the startup
  volume, which is the closest in concept to Unix' "/". This should help
  to run existing scripts originally written for Unix.
  
  =item 8.
  
  For absolute paths, some cleanup is done, to ensure that the volume
  name isn't immediately followed by updirs. This is invalid, because
  this would go beyond "root". Generally, these cases are handled like
  their Unix counterparts:
  
   Unix:
      Unix->catdir("","")                 =  "/"
      Unix->catdir("",".")                =  "/"
      Unix->catdir("","..")               =  "/"        # can't go
                                                        # beyond root
      Unix->catdir("",".","..","..","a")  =  "/a"
   Mac:
      Mac->catdir("","")                  =  rootdir()  # (e.g. "HD:")
      Mac->catdir("",":")                 =  rootdir()
      Mac->catdir("","::")                =  rootdir()  # can't go
                                                        # beyond root
      Mac->catdir("",":","::","::","a")   =  rootdir() . "a:"
                                                      # (e.g. "HD:a:")
  
  However, this approach is limited to the first arguments following
  "root" (again, see C<Unix-E<gt>canonpath()> ). If there are more
  arguments that move up the directory tree, an invalid path going
  beyond root can be created.
  
  =back
  
  As you've seen, you can force C<catdir()> to create an absolute path
  by passing either an empty string or a path that begins with a volume
  name as the first argument. However, you are strongly encouraged not
  to do so, since this is done only for backward compatibility. Newer
  versions of File::Spec come with a method called C<catpath()> (see
  below), that is designed to offer a portable solution for the creation
  of absolute paths.  It takes volume, directory and file portions and
  returns an entire path. While C<catdir()> is still suitable for the
  concatenation of I<directory names>, you are encouraged to use
  C<catpath()> to concatenate I<volume names> and I<directory
  paths>. E.g.
  
      $dir      = File::Spec->catdir("tmp","sources");
      $abs_path = File::Spec->catpath("MacintoshHD:", $dir,"");
  
  yields
  
      "MacintoshHD:tmp:sources:" .
  
  =cut
  
  sub catdir {
  	my $self = shift;
  	return '' unless @_;
  	my @args = @_;
  	my $first_arg;
  	my $relative;
  
  	# take care of the first argument
  
  	if ($args[0] eq '')  { # absolute path, rootdir
  		shift @args;
  		$relative = 0;
  		$first_arg = $self->rootdir;
  
  	} elsif ($args[0] =~ /^[^:]+:/) { # absolute path, volume name
  		$relative = 0;
  		$first_arg = shift @args;
  		# add a trailing ':' if need be (may be it's a path like HD:dir)
  		$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  
  	} else { # relative path
  		$relative = 1;
  		if ( $args[0] =~ /^::+\Z(?!\n)/ ) {
  			# updir colon path ('::', ':::' etc.), don't shift
  			$first_arg = ':';
  		} elsif ($args[0] eq ':') {
  			$first_arg = shift @args;
  		} else {
  			# add a trailing ':' if need be
  			$first_arg = shift @args;
  			$first_arg = "$first_arg:" unless ($first_arg =~ /:\Z(?!\n)/);
  		}
  	}
  
  	# For all other arguments,
  	# (a) ignore arguments that equal ':' or '',
  	# (b) handle updir paths specially:
  	#     '::' 			-> concatenate '::'
  	#     '::' . '::' 	-> concatenate ':::' etc.
  	# (c) add a trailing ':' if need be
  
  	my $result = $first_arg;
  	while (@args) {
  		my $arg = shift @args;
  		unless (($arg eq '') || ($arg eq ':')) {
  			if ($arg =~ /^::+\Z(?!\n)/ ) { # updir colon path like ':::'
  				my $updir_count = length($arg) - 1;
  				while ((@args) && ($args[0] =~ /^::+\Z(?!\n)/) ) { # while updir colon path
  					$arg = shift @args;
  					$updir_count += (length($arg) - 1);
  				}
  				$arg = (':' x $updir_count);
  			} else {
  				$arg =~ s/^://s; # remove a leading ':' if any
  				$arg = "$arg:" unless ($arg =~ /:\Z(?!\n)/); # ensure trailing ':'
  			}
  			$result .= $arg;
  		}#unless
  	}
  
  	if ( ($relative) && ($result !~ /^:/) ) {
  		# add a leading colon if need be
  		$result = ":$result";
  	}
  
  	unless ($relative) {
  		# remove updirs immediately following the volume name
  		$result =~ s/([^:]+:)(:*)(.*)\Z(?!\n)/$1$3/;
  	}
  
  	return $result;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename. Resulting paths are B<relative>
  by default, but can be forced to be absolute (but avoid this).
  
  B<IMPORTANT NOTE:> Beginning with version 1.3 of this module, the
  resulting path is relative by default and I<not> absolute. This
  decision was made due to portability reasons. Since
  C<File::Spec-E<gt>catfile()> returns relative paths on all other
  operating systems, it will now also follow this convention on Mac OS.
  Note that this may break some existing scripts.
  
  The last argument is always considered to be the file portion. Since
  C<catfile()> uses C<catdir()> (see above) for the concatenation of the
  directory portions (if any), the following with regard to relative and
  absolute paths is true:
  
      catfile("")     = ""
      catfile("file") = "file"
  
  but
  
      catfile("","")        = rootdir()         # (e.g. "HD:")
      catfile("","file")    = rootdir() . file  # (e.g. "HD:file")
      catfile("HD:","file") = "HD:file"
  
  This means that C<catdir()> is called only when there are two or more
  arguments, as one might expect.
  
  Note that the leading ":" is removed from the filename, so that
  
      catfile("a","b","file")  = ":a:b:file"    and
  
      catfile("a","b",":file") = ":a:b:file"
  
  give the same answer.
  
  To concatenate I<volume names>, I<directory paths> and I<filenames>,
  you are encouraged to use C<catpath()> (see below).
  
  =cut
  
  sub catfile {
      my $self = shift;
      return '' unless @_;
      my $file = pop @_;
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $file =~ s/^://s;
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representing the current directory. On Mac OS, this is ":".
  
  =cut
  
  sub curdir {
      return ":";
  }
  
  =item devnull
  
  Returns a string representing the null device. On Mac OS, this is "Dev:Null".
  
  =cut
  
  sub devnull {
      return "Dev:Null";
  }
  
  =item rootdir
  
  Returns a string representing the root directory.  Under MacPerl,
  returns the name of the startup volume, since that's the closest in
  concept, although other volumes aren't rooted there. The name has a
  trailing ":", because that's the correct specification for a volume
  name on Mac OS.
  
  If Mac::Files could not be loaded, the empty string is returned.
  
  =cut
  
  sub rootdir {
  #
  #  There's no real root directory on Mac OS. The name of the startup
  #  volume is returned, since that's the closest in concept.
  #
      return '' unless $macfiles;
      my $system = Mac::Files::FindFolder(&Mac::Files::kOnSystemDisk,
  	&Mac::Files::kSystemFolderType);
      $system =~ s/:.*\Z(?!\n)/:/s;
      return $system;
  }
  
  =item tmpdir
  
  Returns the contents of $ENV{TMPDIR}, if that directory exits or the
  current working directory otherwise. Under MacPerl, $ENV{TMPDIR} will
  contain a path like "MacintoshHD:Temporary Items:", which is a hidden
  directory on your startup volume.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR} );
  }
  
  =item updir
  
  Returns a string representing the parent directory. On Mac OS, this is "::".
  
  =cut
  
  sub updir {
      return "::";
  }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true, if it is an absolute path.
  If the path has a leading ":", it's a relative path. Otherwise, it's an
  absolute path, unless the path doesn't contain any colons, i.e. it's a name
  like "a". In this particular case, the path is considered to be relative
  (i.e. it is considered to be a filename). Use ":" in the appropriate place
  in the path if you want to distinguish unambiguously. As a special case,
  the filename '' is always considered to be absolute. Note that with version
  1.2 of File::Spec::Mac, this does no longer consult the local filesystem.
  
  E.g.
  
      File::Spec->file_name_is_absolute("a");         # false (relative)
      File::Spec->file_name_is_absolute(":a:b:");     # false (relative)
      File::Spec->file_name_is_absolute("MacintoshHD:");
                                                      # true (absolute)
      File::Spec->file_name_is_absolute("");          # true (absolute)
  
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      if ($file =~ /:/) {
  	return (! ($file =~ m/^:/s) );
      } elsif ( $file eq '' ) {
          return 1 ;
      } else {
  	return 0; # i.e. a file like "a"
      }
  }
  
  =item path
  
  Returns the null list for the MacPerl application, since the concept is
  usually meaningless under Mac OS. But if you're using the MacPerl tool under
  MPW, it gives back $ENV{Commands} suitably split, as is done in
  :lib:ExtUtils:MM_Mac.pm.
  
  =cut
  
  sub path {
  #
  #  The concept is meaningless under the MacPerl application.
  #  Under MPW, it has a meaning.
  #
      return unless exists $ENV{Commands};
      return split(/,/, $ENV{Commands});
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions.
  
  On Mac OS, assumes that the last part of the path is a filename unless
  $no_file is true or a trailing separator ":" is present.
  
  The volume portion is always returned with a trailing ":". The directory portion
  is always returned with a leading (to denote a relative path) and a trailing ":"
  (to denote a directory). The file portion is always returned I<without> a leading ":".
  Empty portions are returned as empty string ''.
  
  The results can be passed to C<catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file);
  
      if ( $nofile ) {
          ( $volume, $directory ) = $path =~ m|^((?:[^:]+:)?)(.*)|s;
      }
      else {
          $path =~
              m|^( (?: [^:]+: )? )
                 ( (?: .*: )? )
                 ( .* )
               |xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      $volume = '' unless defined($volume);
  	$directory = ":$directory" if ( $volume && $directory ); # take care of "HD::dir"
      if ($directory) {
          # Make sure non-empty directories begin and end in ':'
          $directory .= ':' unless (substr($directory,-1) eq ':');
          $directory = ":$directory" unless (substr($directory,0,1) eq ':');
      } else {
  	$directory = '';
      }
      $file = '' unless defined($file);
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of C<catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories should be only the directory portion of the path on systems
  that have the concept of a volume or that have path syntax that differentiates
  files from directories. Consider using C<splitpath()> otherwise.
  
  Unlike just splitting the directories on the separator, empty directory names
  (C<"">) can be returned. Since C<catdir()> on Mac OS always appends a trailing
  colon to distinguish a directory path from a file path, a single trailing colon
  will be ignored, i.e. there's no empty directory name after it.
  
  Hence, on Mac OS, both
  
      File::Spec->splitdir( ":a:b::c:" );    and
      File::Spec->splitdir( ":a:b::c" );
  
  yield:
  
      ( "a", "b", "::", "c")
  
  while
  
      File::Spec->splitdir( ":a:b::c::" );
  
  yields:
  
      ( "a", "b", "::", "c", "::")
  
  
  =cut
  
  sub splitdir {
  	my ($self, $path) = @_;
  	my @result = ();
  	my ($head, $sep, $tail, $volume, $directories);
  
  	return @result if ( (!defined($path)) || ($path eq '') );
  	return (':') if ($path eq ':');
  
  	( $volume, $sep, $directories ) = $path =~ m|^((?:[^:]+:)?)(:*)(.*)|s;
  
  	# deprecated, but handle it correctly
  	if ($volume) {
  		push (@result, $volume);
  		$sep .= ':';
  	}
  
  	while ($sep || $directories) {
  		if (length($sep) > 1) {
  			my $updir_count = length($sep) - 1;
  			for (my $i=0; $i<$updir_count; $i++) {
  				# push '::' updir_count times;
  				# simulate Unix '..' updirs
  				push (@result, '::');
  			}
  		}
  		$sep = '';
  		if ($directories) {
  			( $head, $sep, $tail ) = $directories =~ m|^((?:[^:]+)?)(:*)(.*)|s;
  			push (@result, $head);
  			$directories = $tail;
  		}
  	}
  	return @result;
  }
  
  
  =item catpath
  
      $path = File::Spec->catpath($volume,$directory,$file);
  
  Takes volume, directory and file portions and returns an entire path. On Mac OS,
  $volume, $directory and $file are concatenated.  A ':' is inserted if need be. You
  may pass an empty string for each portion. If all portions are empty, the empty
  string is returned. If $volume is empty, the result will be a relative path,
  beginning with a ':'. If $volume and $directory are empty, a leading ":" (if any)
  is removed form $file and the remainder is returned. If $file is empty, the
  resulting path will have a trailing ':'.
  
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( (! $volume) && (! $directory) ) {
  	$file =~ s/^:// if $file;
  	return $file ;
      }
  
      # We look for a volume in $volume, then in $directory, but not both
  
      my ($dir_volume, $dir_dirs) = $self->splitpath($directory, 1);
  
      $volume = $dir_volume unless length $volume;
      my $path = $volume; # may be ''
      $path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
  
      if ($directory) {
  	$directory = $dir_dirs if $volume;
  	$directory =~ s/^://; # remove leading ':' if any
  	$path .= $directory;
  	$path .= ':' unless (substr($path, -1) eq ':'); # ensure trailing ':'
      }
  
      if ($file) {
  	$file =~ s/^://; # remove leading ':' if any
  	$path .= $file;
      }
  
      return $path;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path and returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then the current working directory is used.
  If $base is relative, then it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  If $path and $base appear to be on two different volumes, we will not
  attempt to resolve the two paths, and we will instead simply return
  $path.  Note that previous versions of this module ignored the volume
  of $base, which resulted in garbage results part of the time.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is relative, it is converted to absolute form using C<rel2abs()>.
  This means that it is taken to be relative to the current working directory.
  
  Based on code written by Shigio Yamaguchi.
  
  
  =cut
  
  # maybe this should be done in canonpath() ?
  sub _resolve_updirs {
  	my $path = shift @_;
  	my $proceed;
  
  	# resolve any updirs, e.g. "HD:tmp::file" -> "HD:file"
  	do {
  		$proceed = ($path =~ s/^(.*):[^:]+::(.*?)\z/$1:$2/);
  	} while ($proceed);
  
  	return $path;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
  	$base = _resolve_updirs( $base ); # resolve updirs in $base
      }
      else {
  	$base = _resolve_updirs( $base );
      }
  
      # Split up paths - ignore $base's file
      my ( $path_vol, $path_dirs, $path_file ) =  $self->splitpath( $path );
      my ( $base_vol, $base_dirs )             =  $self->splitpath( $base );
  
      return $path unless lc( $path_vol ) eq lc( $base_vol );
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_dirs );
      my @basechunks = $self->splitdir( $base_dirs );
  	
      while ( @pathchunks &&
  	    @basechunks &&
  	    lc( $pathchunks[0] ) eq lc( $basechunks[0] ) ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @pathchunks now has the directories to descend in to.
      # ensure relative path, even if @pathchunks is empty
      $path_dirs = $self->catdir( ':', @pathchunks );
  
      # @basechunks now contains the number of directories to climb out of.
      $base_dirs = (':' x @basechunks) . ':' ;
  
      return $self->catpath( '', $self->catdir( $base_dirs, $path_dirs ), $path_file ) ;
  }
  
  =item rel2abs
  
  Converts a relative path to an absolute path:
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  Note that both paths are assumed to have a notation that distinguishes a
  directory path (with trailing ':') from a file path (without trailing ':').
  
  If $base is not present or '', then $base is set to the current working
  directory. If $base is relative, then it is converted to absolute form
  using C<rel2abs()>. This means that it is taken to be relative to the
  current working directory.
  
  If $base doesn't have a trailing colon, the last element of $base is
  assumed to be a filename.  This filename is ignored.  Otherwise all path
  components are assumed to be directories.
  
  If $path is already absolute, it is returned and $base is ignored.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base) = @_;
  
      if ( ! $self->file_name_is_absolute($path) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute($base) ) {
              $base = $self->rel2abs($base) ;
          }
  
  	# Split up paths
  
  	# ignore $path's volume
          my ( $path_dirs, $path_file ) = ($self->splitpath($path))[1,2] ;
  
          # ignore $base's file part
  	my ( $base_vol, $base_dirs ) = $self->splitpath($base) ;
  
  	# Glom them together
  	$path_dirs = ':' if ($path_dirs eq '');
  	$base_dirs =~ s/:$//; # remove trailing ':', if any
  	$base_dirs = $base_dirs . $path_dirs;
  
          $path = $self->catpath( $base_vol, $base_dirs, $path_file );
      }
      return $path;
  }
  
  
  =back
  
  =head1 AUTHORS
  
  See the authors list in I<File::Spec>. Mac OS support by Paul Schinder
  <schinder@pobox.com> and Thomas Wegner <wegner_thomas@yahoo.com>.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  1;
FILE_SPEC_MAC

$fatpacked{"File/Spec/OS2.pm"} = <<'FILE_SPEC_OS2';
  package File::Spec::OS2;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  sub devnull {
      return "/dev/nul";
  }
  
  sub case_tolerant {
      return 1;
  }
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m{^([a-z]:)?[\\/]}is);
  }
  
  sub path {
      my $path = $ENV{PATH};
      $path =~ s:\\:/:g;
      my @path = split(';',$path);
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  sub _cwd {
      # In OS/2 the "require Cwd" is unnecessary bloat.
      return Cwd::sys_cwd();
  }
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      my @d = @ENV{qw(TMPDIR TEMP TMP)};	# function call could autovivivy
      $tmpdir = $_[0]->_tmpdir( @d, '/tmp', '/'  );
  }
  
  sub catdir {
      my $self = shift;
      my @args = @_;
      foreach (@args) {
  	tr[\\][/];
          # append a backslash to each argument unless it has one there
          $_ .= "/" unless m{/$};
      }
      return $self->canonpath(join('', @args));
  }
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
  
      $path =~ s/^([a-z]:)/\l$1/s;
      $path =~ s|\\|/|g;
      $path =~ s|([^/])/+|$1/|g;                  # xx////xx  -> xx/xx
      $path =~ s|(/\.)+/|/|g;                     # xx/././xx -> xx/xx
      $path =~ s|^(\./)+(?=[^/])||s;		# ./xx      -> xx
      $path =~ s|/\Z(?!\n)||
               unless $path =~ m#^([a-z]:)?/\Z(?!\n)#si;# xx/       -> xx
      $path =~ s{^/\.\.$}{/};                     # /..    -> /
      1 while $path =~ s{^/\.\.}{};               # /../xx -> /xx
      return $path;
  }
  
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^( (?:[a-zA-Z]:|(?:\\\\|//)[^\\/]+[\\/][^\\/]+)? ) 
                   (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( (?: [a-zA-Z]: |
                        (?:\\\\|//)[^\\/]+[\\/][^\\/]+
                    )?
                  )
                  ( (?:.*[\\\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }xs;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      split m|[\\/]|, $directories, -1;
  }
  
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      $volume .= $1
          if ( $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '/' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  
  sub abs2rel {
      my($self,$path,$base) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          $path = $self->rel2abs( $path ) ;
      } else {
          $path = $self->canonpath( $path ) ;
      }
  
      # Figure out the effective $base and clean it up.
      if ( !defined( $base ) || $base eq '' ) {
  	$base = $self->_cwd();
      } elsif ( ! $self->file_name_is_absolute( $base ) ) {
          $base = $self->rel2abs( $base ) ;
      } else {
          $base = $self->canonpath( $base ) ;
      }
  
      # Split up paths
      my ( $path_volume, $path_directories, $path_file ) = $self->splitpath( $path, 1 ) ;
      my ( $base_volume, $base_directories ) = $self->splitpath( $base, 1 ) ;
      return $path unless $path_volume eq $base_volume;
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # No need to catdir, we know these are well formed.
      $path_directories = CORE::join( '/', @pathchunks );
      $base_directories = CORE::join( '/', @basechunks );
  
      # $base_directories now contains the directories the resulting relative
      # path must ascend out of before it can descend to $path_directory.  So, 
      # replace all names with $parentDir
  
      #FA Need to replace between backslashes...
      $base_directories =~ s|[^\\/]+|..|g ;
  
      # Glue the two together, using a separator if necessary, and preventing an
      # empty result.
  
      #FA Must check that new directories are not empty.
      if ( $path_directories ne '' && $base_directories ne '' ) {
          $path_directories = "$base_directories/$path_directories" ;
      } else {
          $path_directories = "$base_directories$path_directories" ;
      }
  
      return $self->canonpath( 
          $self->catpath( "", $path_directories, $path_file ) 
      ) ;
  }
  
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      if ( ! $self->file_name_is_absolute( $path ) ) {
  
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path, 1 ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base, 1 ) ;
  
          $path = $self->catpath( 
              $base_volume, 
              $self->catdir( $base_directories, $path_directories ), 
              $path_file
          ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::Spec::OS2 - methods for OS/2 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::OS2; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  Amongst the changes made for OS/2 are...
  
  =over 4
  
  =item tmpdir
  
  Modifies the list of places temp directory information is looked for.
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      /tmp
      /
  
  =item splitpath
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =cut
FILE_SPEC_OS2

$fatpacked{"File/Spec/Unix.pm"} = <<'FILE_SPEC_UNIX';
  package File::Spec::Unix;
  
  use strict;
  use vars qw($VERSION);
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  =head1 NAME
  
  File::Spec::Unix - File::Spec for Unix, base for other File::Spec modules
  
  =head1 SYNOPSIS
  
   require File::Spec::Unix; # Done automatically by File::Spec
  
  =head1 DESCRIPTION
  
  Methods for manipulating file specifications.  Other File::Spec
  modules, such as File::Spec::Mac, inherit from File::Spec::Unix and
  override specific methods.
  
  =head1 METHODS
  
  =over 2
  
  =item canonpath()
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminates successive slashes and successive "/.".
  
      $cpath = File::Spec->canonpath( $path ) ;
  
  Note that this does *not* collapse F<x/../y> sections into F<y>.  This
  is by design.  If F</foo> on your system is a symlink to F</bar/baz>,
  then F</foo/../quux> is actually F</bar/quux>, not F</quux> as a naive
  F<../>-removal would give you.  If you want to do this kind of
  processing, you probably want C<Cwd>'s C<realpath()> function to
  actually traverse the filesystem cleaning up paths like this.
  
  =cut
  
  sub canonpath {
      my ($self,$path) = @_;
      return unless defined $path;
      
      # Handle POSIX-style node names beginning with double slash (qnx, nto)
      # (POSIX says: "a pathname that begins with two successive slashes
      # may be interpreted in an implementation-defined manner, although
      # more than two leading slashes shall be treated as a single slash.")
      my $node = '';
      my $double_slashes_special = $^O eq 'qnx' || $^O eq 'nto';
  
  
      if ( $double_slashes_special
           && ( $path =~ s{^(//[^/]+)/?\z}{}s || $path =~ s{^(//[^/]+)/}{/}s ) ) {
        $node = $1;
      }
      # This used to be
      # $path =~ s|/+|/|g unless ($^O eq 'cygwin');
      # but that made tests 29, 30, 35, 46, and 213 (as of #13272) to fail
      # (Mainly because trailing "" directories didn't get stripped).
      # Why would cygwin avoid collapsing multiple slashes into one? --jhi
      $path =~ s|/{2,}|/|g;                            # xx////xx  -> xx/xx
      $path =~ s{(?:/\.)+(?:/|\z)}{/}g;                # xx/././xx -> xx/xx
      $path =~ s|^(?:\./)+||s unless $path eq "./";    # ./xx      -> xx
      $path =~ s|^/(?:\.\./)+|/|;                      # /../../xx -> xx
      $path =~ s|^/\.\.$|/|;                         # /..       -> /
      $path =~ s|/\z|| unless $path eq "/";          # xx/       -> xx
      return "$node$path";
  }
  
  =item catdir()
  
  Concatenate two or more directory names to form a complete path ending
  with a directory. But remove the trailing slash from the resulting
  string, because it doesn't look good, isn't necessary and confuses
  OS2. Of course, if this is the root directory, don't cut off the
  trailing slash :-)
  
  =cut
  
  sub catdir {
      my $self = shift;
  
      $self->canonpath(join('/', @_, '')); # '' because need a trailing '/'
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $file = $self->canonpath(pop @_);
      return $file unless @_;
      my $dir = $self->catdir(@_);
      $dir .= "/" unless substr($dir,-1) eq "/";
      return $dir.$file;
  }
  
  =item curdir
  
  Returns a string representation of the current directory.  "." on UNIX.
  
  =cut
  
  sub curdir { '.' }
  
  =item devnull
  
  Returns a string representation of the null device. "/dev/null" on UNIX.
  
  =cut
  
  sub devnull { '/dev/null' }
  
  =item rootdir
  
  Returns a string representation of the root directory.  "/" on UNIX.
  
  =cut
  
  sub rootdir { '/' }
  
  =item tmpdir
  
  Returns a string representation of the first writable directory from
  the following list or the current directory if none from the list are
  writable:
  
      $ENV{TMPDIR}
      /tmp
  
  If running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub _tmpdir {
      return $tmpdir if defined $tmpdir;
      my $self = shift;
      my @dirlist = @_;
      {
  	no strict 'refs';
  	if (${"\cTAINT"}) { # Check for taint mode on perl >= 5.8.0
              require Scalar::Util;
  	    @dirlist = grep { ! Scalar::Util::tainted($_) } @dirlist;
  	}
  	elsif ($] < 5.007) { # No ${^TAINT} before 5.8
  	    @dirlist = grep { eval { eval('1'.substr $_,0,0) } } @dirlist;
  	}
      }
      foreach (@dirlist) {
  	next unless defined && -d && -w _;
  	$tmpdir = $_;
  	last;
      }
      $tmpdir = $self->curdir unless defined $tmpdir;
      $tmpdir = defined $tmpdir && $self->canonpath($tmpdir);
      return $tmpdir;
  }
  
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( $ENV{TMPDIR}, "/tmp" );
  }
  
  =item updir
  
  Returns a string representation of the parent directory.  ".." on UNIX.
  
  =cut
  
  sub updir { '..' }
  
  =item no_upwards
  
  Given a list of file names, strip out those that refer to a parent
  directory. (Does not strip symlinks, only '.', '..', and equivalents.)
  
  =cut
  
  sub no_upwards {
      my $self = shift;
      return grep(!/^\.{1,2}\z/s, @_);
  }
  
  =item case_tolerant
  
  Returns a true or false value indicating, respectively, that alphabetic
  is not or is significant when comparing file specifications.
  
  =cut
  
  sub case_tolerant { 0 }
  
  =item file_name_is_absolute
  
  Takes as argument a path and returns true if it is an absolute path.
  
  This does not consult the local filesystem on Unix, Win32, OS/2 or Mac 
  OS (Classic).  It does consult the working environment for VMS (see
  L<File::Spec::VMS/file_name_is_absolute>).
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      return scalar($file =~ m:^/:s);
  }
  
  =item path
  
  Takes no argument, returns the environment variable PATH as an array.
  
  =cut
  
  sub path {
      return () unless exists $ENV{PATH};
      my @path = split(':', $ENV{PATH});
      foreach (@path) { $_ = '.' if $_ eq '' }
      return @path;
  }
  
  =item join
  
  join is the same as catfile.
  
  =cut
  
  sub join {
      my $self = shift;
      return $self->catfile(@_);
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. On systems
  with no concept of volume, returns '' for volume. 
  
  For systems with no syntax differentiating filenames from directories, 
  assumes that the last file is a path unless $no_file is true or a 
  trailing separator or /. or /.. is present. On Unix this means that $no_file
  true makes this return ( '', $path, '' ).
  
  The directory portion may or may not be returned with a trailing '/'.
  
  The results can be passed to L</catpath()> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
  
      my ($volume,$directory,$file) = ('','','');
  
      if ( $nofile ) {
          $directory = $path;
      }
      else {
          $path =~ m|^ ( (?: .* / (?: \.\.?\z )? )? ) ([^/]*) |xs;
          $directory = $1;
          $file      = $2;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L</catdir()>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, empty
  directory names (C<''>) can be returned, because these are significant
  on some OSs.
  
  On Unix,
  
      File::Spec->splitdir( "/a/b//c/" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      return split m|/|, $_[1], -1;  # Preserve trailing fields
  }
  
  
  =item catpath()
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and directory and file are concatenated.  A '/' is
  inserted if needed (though if the directory portion doesn't start with
  '/' it is not added).  On other OSs, $volume is significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      if ( $directory ne ''                && 
           $file ne ''                     && 
           substr( $directory, -1 ) ne '/' && 
           substr( $file, 0, 1 ) ne '/' 
      ) {
          $directory .= "/$file" ;
      }
      else {
          $directory .= $file ;
      }
  
      return $directory ;
  }
  
  =item abs2rel
  
  Takes a destination path and an optional base path returns a relative path
  from the base path to the destination path:
  
      $rel_path = File::Spec->abs2rel( $path ) ;
      $rel_path = File::Spec->abs2rel( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores the 
  $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is relative, it is converted to absolute form using L</rel2abs()>.
  This means that it is taken to be relative to L<cwd()|Cwd>.
  
  No checks against the filesystem are made, so the result may not be correct if
  C<$base> contains symbolic links.  (Apply
  L<Cwd::abs_path()|Cwd/abs_path> beforehand if that
  is a concern.)  On VMS, there is interaction with the working environment, as
  logicals and macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub abs2rel {
      my($self,$path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      ($path, $base) = map $self->canonpath($_), $path, $base;
  
      my $path_directories;
      my $base_directories;
  
      if (grep $self->file_name_is_absolute($_), $path, $base) {
  	($path, $base) = map $self->rel2abs($_), $path, $base;
  
  	my ($path_volume) = $self->splitpath($path, 1);
  	my ($base_volume) = $self->splitpath($base, 1);
  
  	# Can't relativize across volumes
  	return $path unless $path_volume eq $base_volume;
  
  	$path_directories = ($self->splitpath($path, 1))[1];
  	$base_directories = ($self->splitpath($base, 1))[1];
  
  	# For UNC paths, the user might give a volume like //foo/bar that
  	# strictly speaking has no directory portion.  Treat it as if it
  	# had the root directory for that volume.
  	if (!length($base_directories) and $self->file_name_is_absolute($base)) {
  	    $base_directories = $self->rootdir;
  	}
      }
      else {
  	my $wd= ($self->splitpath($self->_cwd(), 1))[1];
  	$path_directories = $self->catdir($wd, $path);
  	$base_directories = $self->catdir($wd, $base);
      }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my @basechunks = $self->splitdir( $base_directories );
  
      if ($base_directories eq $self->rootdir) {
        return $self->curdir if $path_directories eq $self->rootdir;
        shift @pathchunks;
        return $self->canonpath( $self->catpath('', $self->catdir( @pathchunks ), '') );
      }
  
      my @common;
      while (@pathchunks && @basechunks && $self->_same($pathchunks[0], $basechunks[0])) {
          push @common, shift @pathchunks ;
          shift @basechunks ;
      }
      return $self->curdir unless @pathchunks || @basechunks;
  
      # @basechunks now contains the directories the resulting relative path 
      # must ascend out of before it can descend to $path_directory.  If there
      # are updir components, we must descend into the corresponding directories
      # (this only works if they are no symlinks).
      my @reverse_base;
      while( defined(my $dir= shift @basechunks) ) {
  	if( $dir ne $self->updir ) {
  	    unshift @reverse_base, $self->updir;
  	    push @common, $dir;
  	}
  	elsif( @common ) {
  	    if( @reverse_base && $reverse_base[0] eq $self->updir ) {
  		shift @reverse_base;
  		pop @common;
  	    }
  	    else {
  		unshift @reverse_base, pop @common;
  	    }
  	}
      }
      my $result_dirs = $self->catdir( @reverse_base, @pathchunks );
      return $self->canonpath( $self->catpath('', $result_dirs, '') );
  }
  
  sub _same {
    $_[1] eq $_[2];
  }
  
  =item rel2abs()
  
  Converts a relative path to an absolute path. 
  
      $abs_path = File::Spec->rel2abs( $path ) ;
      $abs_path = File::Spec->rel2abs( $path, $base ) ;
  
  If $base is not present or '', then L<cwd()|Cwd> is used. If $base is
  relative, then it is converted to absolute form using
  L</rel2abs()>. This means that it is taken to be relative to
  L<cwd()|Cwd>.
  
  On systems that have a grammar that indicates filenames, this ignores
  the $base filename. Otherwise all path components are assumed to be
  directories.
  
  If $path is absolute, it is cleaned up and returned using L</canonpath()>.
  
  No checks against the filesystem are made.  On VMS, there is
  interaction with the working environment, as logicals and
  macros are expanded.
  
  Based on code written by Shigio Yamaguchi.
  
  =cut
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      # Clean up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
  	    $base = $self->_cwd();
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Glom them together
          $path = $self->catdir( $base, $path ) ;
      }
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  Please submit bug reports and patches to perlbug@perl.org.
  
  =head1 SEE ALSO
  
  L<File::Spec>
  
  =cut
  
  # Internal routine to File::Spec, no point in making this public since
  # it is the standard Cwd interface.  Most of the platform-specific
  # File::Spec subclasses use this.
  sub _cwd {
      require Cwd;
      Cwd::getcwd();
  }
  
  
  # Internal method to reduce xx\..\yy -> yy
  sub _collapse {
      my($fs, $path) = @_;
  
      my $updir  = $fs->updir;
      my $curdir = $fs->curdir;
  
      my($vol, $dirs, $file) = $fs->splitpath($path);
      my @dirs = $fs->splitdir($dirs);
      pop @dirs if @dirs && $dirs[-1] eq '';
  
      my @collapsed;
      foreach my $dir (@dirs) {
          if( $dir eq $updir              and   # if we have an updir
              @collapsed                  and   # and something to collapse
              length $collapsed[-1]       and   # and its not the rootdir
              $collapsed[-1] ne $updir    and   # nor another updir
              $collapsed[-1] ne $curdir         # nor the curdir
            ) 
          {                                     # then
              pop @collapsed;                   # collapse
          }
          else {                                # else
              push @collapsed, $dir;            # just hang onto it
          }
      }
  
      return $fs->catpath($vol,
                          $fs->catdir(@collapsed),
                          $file
                         );
  }
  
  
  1;
FILE_SPEC_UNIX

$fatpacked{"File/Spec/VMS.pm"} = <<'FILE_SPEC_VMS';
  package File::Spec::VMS;
  
  use strict;
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  use File::Basename;
  use VMS::Filespec;
  
  =head1 NAME
  
  File::Spec::VMS - methods for VMS file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::VMS; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  The default behavior is to allow either VMS or Unix syntax on input and to 
  return VMS syntax on output unless Unix syntax has been explicity requested
  via the C<DECC$FILENAME_UNIX_REPORT> CRTL feature.
  
  =over 4
  
  =cut
  
  # Need to look up the feature settings.  The preferred way is to use the
  # VMS::Feature module, but that may not be available to dual life modules.
  
  my $use_feature;
  BEGIN {
      if (eval { local $SIG{__DIE__}; require VMS::Feature; }) {
          $use_feature = 1;
      }
  }
  
  # Need to look up the UNIX report mode.  This may become a dynamic mode
  # in the future.
  sub _unix_rpt {
      my $unix_rpt;
      if ($use_feature) {
          $unix_rpt = VMS::Feature::current("filename_unix_report");
      } else {
          my $env_unix_rpt = $ENV{'DECC$FILENAME_UNIX_REPORT'} || '';
          $unix_rpt = $env_unix_rpt =~ /^[ET1]/i; 
      }
      return $unix_rpt;
  }
  
  =item canonpath (override)
  
  Removes redundant portions of file specifications and returns results
  in native syntax unless Unix filename reporting has been enabled.
  
  =cut
  
  
  sub canonpath {
      my($self,$path) = @_;
  
      return undef unless defined $path;
  
      my $unix_rpt = $self->_unix_rpt;
  
      if ($path =~ m|/|) {
        my $pathify = $path =~ m|/\Z(?!\n)|;
        $path = $self->SUPER::canonpath($path);
  
        return $path if $unix_rpt;
        $path = $pathify ? vmspath($path) : vmsify($path);
      }
  
      $path =~ s/(?<!\^)</[/;			# < and >       ==> [ and ]
      $path =~ s/(?<!\^)>/]/;
      $path =~ s/(?<!\^)\]\[\./\.\]\[/g;		# ][.		==> .][
      $path =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $path =~ s/(?<!\^)\[000000\./\[/g;		# [000000.	==> [
      $path =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $path =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar     ==> foo.bar
      1 while ($path =~ s/(?<!\^)([\[\.])(-+)\.(-+)([\.\]])/$1$2$3$4/);
  						# That loop does the following
  						# with any amount of dashes:
  						# .-.-.		==> .--.
  						# [-.-.		==> [--.
  						# .-.-]		==> .--]
  						# [-.-]		==> [--]
      1 while ($path =~ s/(?<!\^)([\[\.])[^\]\.]+\.-(-+)([\]\.])/$1$2$3/);
  						# That loop does the following
  						# with any amount (minimum 2)
  						# of dashes:
  						# .foo.--.	==> .-.
  						# .foo.--]	==> .-]
  						# [foo.--.	==> [-.
  						# [foo.--]	==> [-]
  						#
  						# And then, the remaining cases
      $path =~ s/(?<!\^)\[\.-/[-/;		# [.-		==> [-
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\./\./g;	# .foo.-.	==> .
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\./\[/g;	# [foo.-.	==> [
      $path =~ s/(?<!\^)\.[^\]\.]+\.-\]/\]/g;	# .foo.-]	==> ]
  						# [foo.-]       ==> [000000]
      $path =~ s/(?<!\^)\[[^\]\.]+\.-\]/\[000000\]/g;
  						# []		==>
      $path =~ s/(?<!\^)\[\]// unless $path eq '[]';
      return $unix_rpt ? unixify($path) : $path;
  }
  
  =item catdir (override)
  
  Concatenates a list of file specifications, and returns the result as a
  native directory specification unless the Unix filename reporting feature
  has been enabled.  No check is made for "impossible" cases (e.g. elements
  other than the first being absolute filespecs).
  
  =cut
  
  sub catdir {
      my $self = shift;
      my $dir = pop;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my @dirs = grep {defined() && length()} @_;
  
      my $rslt;
      if (@dirs) {
  	my $path = (@dirs == 1 ? $dirs[0] : $self->catdir(@dirs));
  	my ($spath,$sdir) = ($path,$dir);
  	$spath =~ s/\.dir\Z(?!\n)//i; $sdir =~ s/\.dir\Z(?!\n)//i; 
  
  	if ($unix_rpt) {
  	    $spath = unixify($spath) unless $spath =~ m#/#;
  	    $sdir= unixify($sdir) unless $sdir =~ m#/#;
              return $self->SUPER::catdir($spath, $sdir)
  	}
  
  	$sdir = $self->eliminate_macros($sdir) unless $sdir =~ /^[\w\-]+\Z(?!\n)/s;
  	$rslt = $self->fixpath($self->eliminate_macros($spath)."/$sdir",1);
  
  	# Special case for VMS absolute directory specs: these will have
  	# had device prepended during trip through Unix syntax in
  	# eliminate_macros(), since Unix syntax has no way to express
  	# "absolute from the top of this device's directory tree".
  	if ($spath =~ /^[\[<][^.\-]/s) { $rslt =~ s/^[^\[<]+//s; }
  
      } else {
  	# Single directory. Return an empty string on null input; otherwise
  	# just return a canonical path.
  
  	if    (not defined $dir or not length $dir) {
  	    $rslt = '';
  	} else {
  	    $rslt = $unix_rpt ? $dir : vmspath($dir);
  	}
      }
      return $self->canonpath($rslt);
  }
  
  =item catfile (override)
  
  Concatenates a list of directory specifications with a filename specification
  to build a path.
  
  =cut
  
  sub catfile {
      my $self = shift;
      my $tfile = pop();
      my $file = $self->canonpath($tfile);
      my @files = grep {defined() && length()} @_;
  
      my $unix_rpt = $self->_unix_rpt;
  
      my $rslt;
      if (@files) {
  	my $path = (@files == 1 ? $files[0] : $self->catdir(@files));
  	my $spath = $path;
  
          # Something building a VMS path in pieces may try to pass a
          # directory name in filename format, so normalize it.
  	$spath =~ s/\.dir\Z(?!\n)//i;
  
          # If the spath ends with a directory delimiter and the file is bare,
          # then just concatenate them.
  	if ($spath =~ /^(?<!\^)[^\)\]\/:>]+\)\Z(?!\n)/s && basename($file) eq $file) {
  	    $rslt = "$spath$file";
  	} else {
             $rslt = $self->eliminate_macros($spath);
             $rslt .= (defined($rslt) && length($rslt) ? '/' : '') . unixify($file);
             $rslt = vmsify($rslt) unless $unix_rpt;
  	}
      }
      else {
          # Only passed a single file?
          my $xfile = (defined($file) && length($file)) ? $file : '';
  
          $rslt = $unix_rpt ? $file : vmsify($file);
      }
      return $self->canonpath($rslt) unless $unix_rpt;
  
      # In Unix report mode, do not strip off redundant path information.
      return $rslt;
  }
  
  
  =item curdir (override)
  
  Returns a string representation of the current directory: '[]' or '.'
  
  =cut
  
  sub curdir {
      my $self = shift @_;
      return '.' if ($self->_unix_rpt);
      return '[]';
  }
  
  =item devnull (override)
  
  Returns a string representation of the null device: '_NLA0:' or '/dev/null'
  
  =cut
  
  sub devnull {
      my $self = shift @_;
      return '/dev/null' if ($self->_unix_rpt);
      return "_NLA0:";
  }
  
  =item rootdir (override)
  
  Returns a string representation of the root directory: 'SYS$DISK:[000000]'
  or '/'
  
  =cut
  
  sub rootdir {
      my $self = shift @_;
      if ($self->_unix_rpt) {
         # Root may exist, try it first.
         my $try = '/';
         my ($dev1, $ino1) = stat('/');
         my ($dev2, $ino2) = stat('.');
  
         # Perl falls back to '.' if it can not determine '/'
         if (($dev1 != $dev2) || ($ino1 != $ino2)) {
             return $try;
         }
         # Fall back to UNIX format sys$disk.
         return '/sys$disk/';
      }
      return 'SYS$DISK:[000000]';
  }
  
  =item tmpdir (override)
  
  Returns a string representation of the first writable directory
  from the following list or '' if none are writable:
  
      /tmp if C<DECC$FILENAME_UNIX_REPORT> is enabled.
      sys$scratch:
      $ENV{TMPDIR}
  
  Since perl 5.8.0, if running under taint mode, and if $ENV{TMPDIR}
  is tainted, it is not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      my $self = shift @_;
      return $tmpdir if defined $tmpdir;
      if ($self->_unix_rpt) {
          $tmpdir = $self->_tmpdir('/tmp', '/sys$scratch', $ENV{TMPDIR});
          return $tmpdir;
      }
  
      $tmpdir = $self->_tmpdir( 'sys$scratch:', $ENV{TMPDIR} );
  }
  
  =item updir (override)
  
  Returns a string representation of the parent directory: '[-]' or '..'
  
  =cut
  
  sub updir {
      my $self = shift @_;
      return '..' if ($self->_unix_rpt);
      return '[-]';
  }
  
  =item case_tolerant (override)
  
  VMS file specification syntax is case-tolerant.
  
  =cut
  
  sub case_tolerant {
      return 1;
  }
  
  =item path (override)
  
  Translate logical name DCL$PATH as a searchlist, rather than trying
  to C<split> string value of C<$ENV{'PATH'}>.
  
  =cut
  
  sub path {
      my (@dirs,$dir,$i);
      while ($dir = $ENV{'DCL$PATH;' . $i++}) { push(@dirs,$dir); }
      return @dirs;
  }
  
  =item file_name_is_absolute (override)
  
  Checks for VMS directory spec as well as Unix separators.
  
  =cut
  
  sub file_name_is_absolute {
      my ($self,$file) = @_;
      # If it's a logical name, expand it.
      $file = $ENV{$file} while $file =~ /^[\w\$\-]+\Z(?!\n)/s && $ENV{$file};
      return scalar($file =~ m!^/!s             ||
  		  $file =~ m![<\[][^.\-\]>]!  ||
  		  $file =~ /:[^<\[]/);
  }
  
  =item splitpath (override)
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Passing a true value for C<$no_file> indicates that the path being
  split only contains directory components, even on systems where you
  can usually (when not supporting a foreign syntax) tell the difference
  between directories and files at a glance.
  
  =cut
  
  sub splitpath {
      my($self,$path, $nofile) = @_;
      my($dev,$dir,$file)      = ('','','');
      my $vmsify_path = vmsify($path);
  
      if ( $nofile ) {
          #vmsify('d1/d2/d3') returns '[.d1.d2]d3'
          #vmsify('/d1/d2/d3') returns 'd1:[d2]d3'
          if( $vmsify_path =~ /(.*)\](.+)/ ){
              $vmsify_path = $1.'.'.$2.']';
          }
          $vmsify_path =~ /(.+:)?(.*)/s;
          $dir = defined $2 ? $2 : ''; # dir can be '0'
          return ($1 || '',$dir,$file);
      }
      else {
          $vmsify_path =~ /(.+:)?([\[<].*[\]>])?(.*)/s;
          return ($1 || '',$2 || '',$3);
      }
  }
  
  =item splitdir (override)
  
  Split a directory specification into the components.
  
  =cut
  
  sub splitdir {
      my($self,$dirspec) = @_;
      my @dirs = ();
      return @dirs if ( (!defined $dirspec) || ('' eq $dirspec) );
  
      $dirspec =~ s/(?<!\^)</[/;                  # < and >	==> [ and ]
      $dirspec =~ s/(?<!\^)>/]/;
      $dirspec =~ s/(?<!\^)\]\[\./\.\]\[/g;	# ][.		==> .][
      $dirspec =~ s/(?<!\^)\[000000\.\]\[/\[/g;	# [000000.][	==> [
      $dirspec =~ s/(?<!\^)\[000000\./\[/g;	# [000000.	==> [
      $dirspec =~ s/(?<!\^)\.\]\[000000\]/\]/g;	# .][000000]	==> ]
      $dirspec =~ s/(?<!\^)\.\]\[/\./g;		# foo.][bar	==> foo.bar
      while ($dirspec =~ s/(^|[\[\<\.])\-(\-+)($|[\]\>\.])/$1-.$2$3/g) {}
  						# That loop does the following
  						# with any amount of dashes:
  						# .--.		==> .-.-.
  						# [--.		==> [-.-.
  						# .--]		==> .-.-]
  						# [--]		==> [-.-]
      $dirspec = "[$dirspec]" unless $dirspec =~ /(?<!\^)[\[<]/; # make legal
      $dirspec =~ s/^(\[|<)\./$1/;
      @dirs = split /(?<!\^)\./, vmspath($dirspec);
      $dirs[0] =~ s/^[\[<]//s;  $dirs[-1] =~ s/[\]>]\Z(?!\n)//s;
      @dirs;
  }
  
  
  =item catpath (override)
  
  Construct a complete filespec.
  
  =cut
  
  sub catpath {
      my($self,$dev,$dir,$file) = @_;
      
      # We look for a volume in $dev, then in $dir, but not both
      my ($dir_volume, $dir_dir, $dir_file) = $self->splitpath($dir);
      $dev = $dir_volume unless length $dev;
      $dir = length $dir_file ? $self->catfile($dir_dir, $dir_file) : $dir_dir;
      
      if ($dev =~ m|^(?<!\^)/+([^/]+)|) { $dev = "$1:"; }
      else { $dev .= ':' unless $dev eq '' or $dev =~ /:\Z(?!\n)/; }
      if (length($dev) or length($dir)) {
          $dir = "[$dir]" unless $dir =~ /(?<!\^)[\[<\/]/;
          $dir = vmspath($dir);
      }
      $dir = '' if length($dev) && ($dir eq '[]' || $dir eq '<>');
      "$dev$dir$file";
  }
  
  =item abs2rel (override)
  
  Attempt to convert an absolute file specification to a relative specification.
  
  =cut
  
  sub abs2rel {
      my $self = shift;
      return vmspath(File::Spec::Unix::abs2rel( $self, @_ ))
          if grep m{/}, @_;
  
      my($path,$base) = @_;
      $base = $self->_cwd() unless defined $base and length $base;
  
      for ($path, $base) { $_ = $self->canonpath($_) }
  
      # Are we even starting $path on the same (node::)device as $base?  Note that
      # logical paths or nodename differences may be on the "same device" 
      # but the comparison that ignores device differences so as to concatenate 
      # [---] up directory specs is not even a good idea in cases where there is 
      # a logical path difference between $path and $base nodename and/or device.
      # Hence we fall back to returning the absolute $path spec
      # if there is a case blind device (or node) difference of any sort
      # and we do not even try to call $parse() or consult %ENV for $trnlnm()
      # (this module needs to run on non VMS platforms after all).
      
      my ($path_volume, $path_directories, $path_file) = $self->splitpath($path);
      my ($base_volume, $base_directories, $base_file) = $self->splitpath($base);
      return $path unless lc($path_volume) eq lc($base_volume);
  
      for ($path, $base) { $_ = $self->rel2abs($_) }
  
      # Now, remove all leading components that are the same
      my @pathchunks = $self->splitdir( $path_directories );
      my $pathchunks = @pathchunks;
      unshift(@pathchunks,'000000') unless $pathchunks[0] eq '000000';
      my @basechunks = $self->splitdir( $base_directories );
      my $basechunks = @basechunks;
      unshift(@basechunks,'000000') unless $basechunks[0] eq '000000';
  
      while ( @pathchunks && 
              @basechunks && 
              lc( $pathchunks[0] ) eq lc( $basechunks[0] ) 
            ) {
          shift @pathchunks ;
          shift @basechunks ;
      }
  
      # @basechunks now contains the directories to climb out of,
      # @pathchunks now has the directories to descend in to.
      if ((@basechunks > 0) || ($basechunks != $pathchunks)) {
        $path_directories = join '.', ('-' x @basechunks, @pathchunks) ;
      }
      else {
        $path_directories = join '.', @pathchunks;
      }
      $path_directories = '['.$path_directories.']';
      return $self->canonpath( $self->catpath( '', $path_directories, $path_file ) ) ;
  }
  
  
  =item rel2abs (override)
  
  Return an absolute file specification from a relative one.
  
  =cut
  
  sub rel2abs {
      my $self = shift ;
      my ($path,$base ) = @_;
      return undef unless defined $path;
      if ($path =~ m/\//) {
         $path = ( -d $path || $path =~ m/\/\z/  # educated guessing about
                    ? vmspath($path)             # whether it's a directory
                    : vmsify($path) );
      }
      $base = vmspath($base) if defined $base && $base =~ m/\//;
  
      # Clean up and split up $path
      if ( ! $self->file_name_is_absolute( $path ) ) {
          # Figure out the effective $base and clean it up.
          if ( !defined( $base ) || $base eq '' ) {
              $base = $self->_cwd;
          }
          elsif ( ! $self->file_name_is_absolute( $base ) ) {
              $base = $self->rel2abs( $base ) ;
          }
          else {
              $base = $self->canonpath( $base ) ;
          }
  
          # Split up paths
          my ( $path_directories, $path_file ) =
              ($self->splitpath( $path ))[1,2] ;
  
          my ( $base_volume, $base_directories ) =
              $self->splitpath( $base ) ;
  
          $path_directories = '' if $path_directories eq '[]' ||
                                    $path_directories eq '<>';
          my $sep = '' ;
          $sep = '.'
              if ( $base_directories =~ m{[^.\]>]\Z(?!\n)} &&
                   $path_directories =~ m{^[^.\[<]}s
              ) ;
          $base_directories = "$base_directories$sep$path_directories";
          $base_directories =~ s{\.?[\]>][\[<]\.?}{.};
  
          $path = $self->catpath( $base_volume, $base_directories, $path_file );
     }
  
      return $self->canonpath( $path ) ;
  }
  
  
  # eliminate_macros() and fixpath() are MakeMaker-specific methods
  # which are used inside catfile() and catdir().  MakeMaker has its own
  # copies as of 6.06_03 which are the canonical ones.  We leave these
  # here, in peace, so that File::Spec continues to work with MakeMakers
  # prior to 6.06_03.
  # 
  # Please consider these two methods deprecated.  Do not patch them,
  # patch the ones in ExtUtils::MM_VMS instead.
  #
  # Update:  MakeMaker 6.48 is still using these routines on VMS.
  # so they need to be kept up to date with ExtUtils::MM_VMS.
  
  sub eliminate_macros {
      my($self,$path) = @_;
      return '' unless (defined $path) && ($path ne '');
      $self = {} unless ref $self;
  
      if ($path =~ /\s/) {
        return join ' ', map { $self->eliminate_macros($_) } split /\s+/, $path;
      }
  
      my $npath = unixify($path);
      # sometimes unixify will return a string with an off-by-one trailing null
      $npath =~ s{\0$}{};
  
      my($complex) = 0;
      my($head,$macro,$tail);
  
      # perform m##g in scalar context so it acts as an iterator
      while ($npath =~ m#(.*?)\$\((\S+?)\)(.*)#gs) { 
          if (defined $self->{$2}) {
              ($head,$macro,$tail) = ($1,$2,$3);
              if (ref $self->{$macro}) {
                  if (ref $self->{$macro} eq 'ARRAY') {
                      $macro = join ' ', @{$self->{$macro}};
                  }
                  else {
                      print "Note: can't expand macro \$($macro) containing ",ref($self->{$macro}),
                            "\n\t(using MMK-specific deferred substitutuon; MMS will break)\n";
                      $macro = "\cB$macro\cB";
                      $complex = 1;
                  }
              }
              else { ($macro = unixify($self->{$macro})) =~ s#/\Z(?!\n)##; }
              $npath = "$head$macro$tail";
          }
      }
      if ($complex) { $npath =~ s#\cB(.*?)\cB#\${$1}#gs; }
      $npath;
  }
  
  # Deprecated.  See the note above for eliminate_macros().
  
  # Catchall routine to clean up problem MM[SK]/Make macros.  Expands macros
  # in any directory specification, in order to avoid juxtaposing two
  # VMS-syntax directories when MM[SK] is run.  Also expands expressions which
  # are all macro, so that we can tell how long the expansion is, and avoid
  # overrunning DCL's command buffer when MM[KS] is running.
  
  # fixpath() checks to see whether the result matches the name of a
  # directory in the current default directory and returns a directory or
  # file specification accordingly.  C<$is_dir> can be set to true to
  # force fixpath() to consider the path to be a directory or false to force
  # it to be a file.
  
  sub fixpath {
      my($self,$path,$force_path) = @_;
      return '' unless $path;
      $self = bless {}, $self unless ref $self;
      my($fixedpath,$prefix,$name);
  
      if ($path =~ /\s/) {
        return join ' ',
               map { $self->fixpath($_,$force_path) }
  	     split /\s+/, $path;
      }
  
      if ($path =~ m#^\$\([^\)]+\)\Z(?!\n)#s || $path =~ m#[/:>\]]#) { 
          if ($force_path or $path =~ /(?:DIR\)|\])\Z(?!\n)/) {
              $fixedpath = vmspath($self->eliminate_macros($path));
          }
          else {
              $fixedpath = vmsify($self->eliminate_macros($path));
          }
      }
      elsif ((($prefix,$name) = ($path =~ m#^\$\(([^\)]+)\)(.+)#s)) && $self->{$prefix}) {
          my($vmspre) = $self->eliminate_macros("\$($prefix)");
          # is it a dir or just a name?
          $vmspre = ($vmspre =~ m|/| or $prefix =~ /DIR\Z(?!\n)/) ? vmspath($vmspre) : '';
          $fixedpath = ($vmspre ? $vmspre : $self->{$prefix}) . $name;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      else {
          $fixedpath = $path;
          $fixedpath = vmspath($fixedpath) if $force_path;
      }
      # No hints, so we try to guess
      if (!defined($force_path) and $fixedpath !~ /[:>(.\]]/) {
          $fixedpath = vmspath($fixedpath) if -d $fixedpath;
      }
  
      # Trim off root dirname if it's had other dirs inserted in front of it.
      $fixedpath =~ s/\.000000([\]>])/$1/;
      # Special case for VMS absolute directory specs: these will have had device
      # prepended during trip through Unix syntax in eliminate_macros(), since
      # Unix syntax has no way to express "absolute from the top of this device's
      # directory tree".
      if ($path =~ /^[\[>][^.\-]/) { $fixedpath =~ s/^[^\[<]+//; }
      $fixedpath;
  }
  
  
  =back
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  An explanation of VMS file specs can be found at
  L<http://h71000.www7.hp.com/doc/731FINAL/4506/4506pro_014.html#apps_locating_naming_files>.
  
  =cut
  
  1;
FILE_SPEC_VMS

$fatpacked{"File/Spec/Win32.pm"} = <<'FILE_SPEC_WIN32';
  package File::Spec::Win32;
  
  use strict;
  
  use vars qw(@ISA $VERSION);
  require File::Spec::Unix;
  
  $VERSION = '3.40';
  $VERSION =~ tr/_//;
  
  @ISA = qw(File::Spec::Unix);
  
  # Some regexes we use for path splitting
  my $DRIVE_RX = '[a-zA-Z]:';
  my $UNC_RX = '(?:\\\\\\\\|//)[^\\\\/]+[\\\\/][^\\\\/]+';
  my $VOL_RX = "(?:$DRIVE_RX|$UNC_RX)";
  
  
  =head1 NAME
  
  File::Spec::Win32 - methods for Win32 file specs
  
  =head1 SYNOPSIS
  
   require File::Spec::Win32; # Done internally by File::Spec if needed
  
  =head1 DESCRIPTION
  
  See File::Spec::Unix for a documentation of the methods provided
  there. This package overrides the implementation of these methods, not
  the semantics.
  
  =over 4
  
  =item devnull
  
  Returns a string representation of the null device.
  
  =cut
  
  sub devnull {
      return "nul";
  }
  
  sub rootdir { '\\' }
  
  
  =item tmpdir
  
  Returns a string representation of the first existing directory
  from the following list:
  
      $ENV{TMPDIR}
      $ENV{TEMP}
      $ENV{TMP}
      SYS:/temp
      C:\system\temp
      C:/temp
      /tmp
      /
  
  The SYS:/temp is preferred in Novell NetWare and the C:\system\temp
  for Symbian (the File::Spec::Win32 is used also for those platforms).
  
  Since Perl 5.8.0, if running under taint mode, and if the environment
  variables are tainted, they are not used.
  
  =cut
  
  my $tmpdir;
  sub tmpdir {
      return $tmpdir if defined $tmpdir;
      $tmpdir = $_[0]->_tmpdir( map( $ENV{$_}, qw(TMPDIR TEMP TMP) ),
  			      'SYS:/temp',
  			      'C:\system\temp',
  			      'C:/temp',
  			      '/tmp',
  			      '/'  );
  }
  
  =item case_tolerant
  
  MSWin32 case-tolerance depends on GetVolumeInformation() $ouFsFlags == FS_CASE_SENSITIVE,
  indicating the case significance when comparing file specifications.
  Since XP FS_CASE_SENSITIVE is effectively disabled for the NT subsubsystem.
  See http://cygwin.com/ml/cygwin/2007-07/msg00891.html
  Default: 1
  
  =cut
  
  sub case_tolerant {
    eval { require Win32API::File; } or return 1;
    my $drive = shift || "C:";
    my $osFsType = "\0"x256;
    my $osVolName = "\0"x256;
    my $ouFsFlags = 0;
    Win32API::File::GetVolumeInformation($drive, $osVolName, 256, [], [], $ouFsFlags, $osFsType, 256 );
    if ($ouFsFlags & Win32API::File::FS_CASE_SENSITIVE()) { return 0; }
    else { return 1; }
  }
  
  =item file_name_is_absolute
  
  As of right now, this returns 2 if the path is absolute with a
  volume, 1 if it's absolute with no volume, 0 otherwise.
  
  =cut
  
  sub file_name_is_absolute {
  
      my ($self,$file) = @_;
  
      if ($file =~ m{^($VOL_RX)}o) {
        my $vol = $1;
        return ($vol =~ m{^$UNC_RX}o ? 2
  	      : $file =~ m{^$DRIVE_RX[\\/]}o ? 2
  	      : 0);
      }
      return $file =~  m{^[\\/]} ? 1 : 0;
  }
  
  =item catfile
  
  Concatenate one or more directory names and a filename to form a
  complete path ending with a filename
  
  =cut
  
  sub catfile {
      shift;
  
      # Legacy / compatibility support
      #
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catfile('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub catdir {
      shift;
  
      # Legacy / compatibility support
      #
      return ""
      	unless @_;
      shift, return _canon_cat( "/", @_ )
  	if $_[0] eq "";
  
      # Compatibility with File::Spec <= 3.26:
      #     catdir('A:', 'foo') should return 'A:\foo'.
      return _canon_cat( ($_[0].'\\'), @_[1..$#_] )
          if $_[0] =~ m{^$DRIVE_RX\z}o;
  
      return _canon_cat( @_ );
  }
  
  sub path {
      my @path = split(';', $ENV{PATH});
      s/"//g for @path;
      @path = grep length, @path;
      unshift(@path, ".");
      return @path;
  }
  
  =item canonpath
  
  No physical check on the filesystem, but a logical cleanup of a
  path. On UNIX eliminated successive slashes and successive "/.".
  On Win32 makes 
  
  	dir1\dir2\dir3\..\..\dir4 -> \dir\dir4 and even
  	dir1\dir2\dir3\...\dir4   -> \dir\dir4
  
  =cut
  
  sub canonpath {
      # Legacy / compatibility support
      #
      return $_[1] if !defined($_[1]) or $_[1] eq '';
      return _canon_cat( $_[1] );
  }
  
  =item splitpath
  
      ($volume,$directories,$file) = File::Spec->splitpath( $path );
      ($volume,$directories,$file) = File::Spec->splitpath( $path,
                                                            $no_file );
  
  Splits a path into volume, directory, and filename portions. Assumes that 
  the last file is a path unless the path ends in '\\', '\\.', '\\..'
  or $no_file is true.  On Win32 this means that $no_file true makes this return 
  ( $volume, $path, '' ).
  
  Separators accepted are \ and /.
  
  Volumes can be drive letters or UNC sharenames (\\server\share).
  
  The results can be passed to L</catpath> to get back a path equivalent to
  (usually identical to) the original path.
  
  =cut
  
  sub splitpath {
      my ($self,$path, $nofile) = @_;
      my ($volume,$directory,$file) = ('','','');
      if ( $nofile ) {
          $path =~ 
              m{^ ( $VOL_RX ? ) (.*) }sox;
          $volume    = $1;
          $directory = $2;
      }
      else {
          $path =~ 
              m{^ ( $VOL_RX ? )
                  ( (?:.*[\\/](?:\.\.?\Z(?!\n))?)? )
                  (.*)
               }sox;
          $volume    = $1;
          $directory = $2;
          $file      = $3;
      }
  
      return ($volume,$directory,$file);
  }
  
  
  =item splitdir
  
  The opposite of L<catdir()|File::Spec/catdir>.
  
      @dirs = File::Spec->splitdir( $directories );
  
  $directories must be only the directory portion of the path on systems 
  that have the concept of a volume or that have path syntax that differentiates
  files from directories.
  
  Unlike just splitting the directories on the separator, leading empty and 
  trailing directory entries can be returned, because these are significant
  on some OSs. So,
  
      File::Spec->splitdir( "/a/b/c" );
  
  Yields:
  
      ( '', 'a', 'b', '', 'c', '' )
  
  =cut
  
  sub splitdir {
      my ($self,$directories) = @_ ;
      #
      # split() likes to forget about trailing null fields, so here we
      # check to be sure that there will not be any before handling the
      # simple case.
      #
      if ( $directories !~ m|[\\/]\Z(?!\n)| ) {
          return split( m|[\\/]|, $directories );
      }
      else {
          #
          # since there was a trailing separator, add a file name to the end, 
          # then do the split, then replace it with ''.
          #
          my( @directories )= split( m|[\\/]|, "${directories}dummy" ) ;
          $directories[ $#directories ]= '' ;
          return @directories ;
      }
  }
  
  
  =item catpath
  
  Takes volume, directory and file portions and returns an entire path. Under
  Unix, $volume is ignored, and this is just like catfile(). On other OSs,
  the $volume become significant.
  
  =cut
  
  sub catpath {
      my ($self,$volume,$directory,$file) = @_;
  
      # If it's UNC, make sure the glue separator is there, reusing
      # whatever separator is first in the $volume
      my $v;
      $volume .= $v
          if ( (($v) = $volume =~ m@^([\\/])[\\/][^\\/]+[\\/][^\\/]+\Z(?!\n)@s) &&
               $directory =~ m@^[^\\/]@s
             ) ;
  
      $volume .= $directory ;
  
      # If the volume is not just A:, make sure the glue separator is 
      # there, reusing whatever separator is first in the $volume if possible.
      if ( $volume !~ m@^[a-zA-Z]:\Z(?!\n)@s &&
           $volume =~ m@[^\\/]\Z(?!\n)@      &&
           $file   =~ m@[^\\/]@
         ) {
          $volume =~ m@([\\/])@ ;
          my $sep = $1 ? $1 : '\\' ;
          $volume .= $sep ;
      }
  
      $volume .= $file ;
  
      return $volume ;
  }
  
  sub _same {
    lc($_[1]) eq lc($_[2]);
  }
  
  sub rel2abs {
      my ($self,$path,$base ) = @_;
  
      my $is_abs = $self->file_name_is_absolute($path);
  
      # Check for volume (should probably document the '2' thing...)
      return $self->canonpath( $path ) if $is_abs == 2;
  
      if ($is_abs) {
        # It's missing a volume, add one
        my $vol = ($self->splitpath( $self->_cwd() ))[0];
        return $self->canonpath( $vol . $path );
      }
  
      if ( !defined( $base ) || $base eq '' ) {
        require Cwd ;
        $base = Cwd::getdcwd( ($self->splitpath( $path ))[0] ) if defined &Cwd::getdcwd ;
        $base = $self->_cwd() unless defined $base ;
      }
      elsif ( ! $self->file_name_is_absolute( $base ) ) {
        $base = $self->rel2abs( $base ) ;
      }
      else {
        $base = $self->canonpath( $base ) ;
      }
  
      my ( $path_directories, $path_file ) =
        ($self->splitpath( $path, 1 ))[1,2] ;
  
      my ( $base_volume, $base_directories ) =
        $self->splitpath( $base, 1 ) ;
  
      $path = $self->catpath( 
  			   $base_volume, 
  			   $self->catdir( $base_directories, $path_directories ), 
  			   $path_file
  			  ) ;
  
      return $self->canonpath( $path ) ;
  }
  
  =back
  
  =head2 Note For File::Spec::Win32 Maintainers
  
  Novell NetWare inherits its File::Spec behaviour from File::Spec::Win32.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2004,2007 by the Perl 5 Porters.  All rights reserved.
  
  This program is free software; you can redistribute it and/or modify
  it under the same terms as Perl itself.
  
  =head1 SEE ALSO
  
  See L<File::Spec> and L<File::Spec::Unix>.  This package overrides the
  implementation of these methods, not the semantics.
  
  =cut
  
  
  sub _canon_cat				# @path -> path
  {
      my ($first, @rest) = @_;
  
      my $volume = $first =~ s{ \A ([A-Za-z]:) ([\\/]?) }{}x	# drive letter
      	       ? ucfirst( $1 ).( $2 ? "\\" : "" )
  	       : $first =~ s{ \A (?:\\\\|//) ([^\\/]+)
  				 (?: [\\/] ([^\\/]+) )?
  	       			 [\\/]? }{}xs			# UNC volume
  	       ? "\\\\$1".( defined $2 ? "\\$2" : "" )."\\"
  	       : $first =~ s{ \A [\\/] }{}x			# root dir
  	       ? "\\"
  	       : "";
      my $path   = join "\\", $first, @rest;
  
      $path =~ tr#\\/#\\\\#s;		# xx/yy --> xx\yy & xx\\yy --> xx\yy
  
      					# xx/././yy --> xx/yy
      $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		\.
  		(?:\\\.)*		# and more
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}gx;
  
      # XXX I do not know whether more dots are supported by the OS supporting
      #     this ... annotation (NetWare or symbian but not MSWin32).
      #     Then .... could easily become ../../.. etc:
      # Replace \.\.\. by (\.\.\.+)  and substitute with
      # { $1 . ".." . "\\.." x (length($2)-2) }gex
  	     				# ... --> ../..
      $path =~ s{ (\A|\\)			# at begin or after a slash
      		\.\.\.
  		(?=\\|\z) 		# at end or followed by slash
  	     }{$1..\\..}gx;
      					# xx\yy\..\zz --> xx\zz
      while ( $path =~ s{(?:
  		(?:\A|\\)		# at begin or after a slash
  		[^\\]+			# rip this 'yy' off
  		\\\.\.
  		(?<!\A\.\.\\\.\.)	# do *not* replace ^..\..
  		(?<!\\\.\.\\\.\.)	# do *not* replace \..\..
  		(?:\\|\z) 		# at end or followed by slash
  	       )+			# performance boost -- I do not know why
  	     }{\\}sx ) {}
  
      $path =~ s#\A\\##;			# \xx --> xx  NOTE: this is *not* root
      $path =~ s#\\\z##;			# xx\ --> xx
  
      if ( $volume =~ m#\\\z# )
      {					# <vol>\.. --> <vol>\
  	$path =~ s{ \A			# at begin
  		    \.\.
  		    (?:\\\.\.)*		# and more
  		    (?:\\|\z) 		# at end or followed by slash
  		 }{}x;
  
  	return $1			# \\HOST\SHARE\ --> \\HOST\SHARE
  	    if    $path eq ""
  	      and $volume =~ m#\A(\\\\.*)\\\z#s;
      }
      return $path ne "" || $volume ? $volume.$path : ".";
  }
  
  1;
FILE_SPEC_WIN32

$fatpacked{"File/Temp.pm"} = <<'FILE_TEMP';
  package File::Temp;
  
  =head1 NAME
  
  File::Temp - return name and handle of a temporary file safely
  
  =begin __INTERNALS
  
  =head1 PORTABILITY
  
  This section is at the top in order to provide easier access to
  porters.  It is not expected to be rendered by a standard pod
  formatting tool. Please skip straight to the SYNOPSIS section if you
  are not trying to port this module to a new platform.
  
  This module is designed to be portable across operating systems and it
  currently supports Unix, VMS, DOS, OS/2, Windows and Mac OS
  (Classic). When porting to a new OS there are generally three main
  issues that have to be solved:
  
  =over 4
  
  =item *
  
  Can the OS unlink an open file? If it can not then the
  C<_can_unlink_opened_file> method should be modified.
  
  =item *
  
  Are the return values from C<stat> reliable? By default all the
  return values from C<stat> are compared when unlinking a temporary
  file using the filename and the handle. Operating systems other than
  unix do not always have valid entries in all fields. If utility function
  C<File::Temp::unlink0> fails then the C<stat> comparison should be
  modified accordingly.
  
  =item *
  
  Security. Systems that can not support a test for the sticky bit
  on a directory can not use the MEDIUM and HIGH security tests.
  The C<_can_do_level> method should be modified accordingly.
  
  =back
  
  =end __INTERNALS
  
  =head1 SYNOPSIS
  
    use File::Temp qw/ tempfile tempdir /;
  
    $fh = tempfile();
    ($fh, $filename) = tempfile();
  
    ($fh, $filename) = tempfile( $template, DIR => $dir);
    ($fh, $filename) = tempfile( $template, SUFFIX => '.dat');
    ($fh, $filename) = tempfile( $template, TMPDIR => 1 );
  
    binmode( $fh, ":utf8" );
  
    $dir = tempdir( CLEANUP => 1 );
    ($fh, $filename) = tempfile( DIR => $dir );
  
  Object interface:
  
    require File::Temp;
    use File::Temp ();
    use File::Temp qw/ :seekable /;
  
    $fh = File::Temp->new();
    $fname = $fh->filename;
  
    $fh = File::Temp->new(TEMPLATE => $template);
    $fname = $fh->filename;
  
    $tmp = File::Temp->new( UNLINK => 0, SUFFIX => '.dat' );
    print $tmp "Some data\n";
    print "Filename is $tmp\n";
    $tmp->seek( 0, SEEK_END );
  
  The following interfaces are provided for compatibility with
  existing APIs. They should not be used in new code.
  
  MkTemp family:
  
    use File::Temp qw/ :mktemp  /;
  
    ($fh, $file) = mkstemp( "tmpfileXXXXX" );
    ($fh, $file) = mkstemps( "tmpfileXXXXXX", $suffix);
  
    $tmpdir = mkdtemp( $template );
  
    $unopened_file = mktemp( $template );
  
  POSIX functions:
  
    use File::Temp qw/ :POSIX /;
  
    $file = tmpnam();
    $fh = tmpfile();
  
    ($fh, $file) = tmpnam();
  
  Compatibility functions:
  
    $unopened_file = File::Temp::tempnam( $dir, $pfx );
  
  =head1 DESCRIPTION
  
  C<File::Temp> can be used to create and open temporary files in a safe
  way.  There is both a function interface and an object-oriented
  interface.  The File::Temp constructor or the tempfile() function can
  be used to return the name and the open filehandle of a temporary
  file.  The tempdir() function can be used to create a temporary
  directory.
  
  The security aspect of temporary file creation is emphasized such that
  a filehandle and filename are returned together.  This helps guarantee
  that a race condition can not occur where the temporary file is
  created by another process between checking for the existence of the
  file and its opening.  Additional security levels are provided to
  check, for example, that the sticky bit is set on world writable
  directories.  See L<"safe_level"> for more information.
  
  For compatibility with popular C library functions, Perl implementations of
  the mkstemp() family of functions are provided. These are, mkstemp(),
  mkstemps(), mkdtemp() and mktemp().
  
  Additionally, implementations of the standard L<POSIX|POSIX>
  tmpnam() and tmpfile() functions are provided if required.
  
  Implementations of mktemp(), tmpnam(), and tempnam() are provided,
  but should be used with caution since they return only a filename
  that was valid when function was called, so cannot guarantee
  that the file will not exist by the time the caller opens the filename.
  
  Filehandles returned by these functions support the seekable methods.
  
  =cut
  
  # 5.6.0 gives us S_IWOTH, S_IWGRP, our and auto-vivifying filehandls
  # People would like a version on 5.004 so give them what they want :-)
  use 5.004;
  use strict;
  use Carp;
  use File::Spec 0.8;
  use Cwd ();
  use File::Path qw/ rmtree /;
  use Fcntl 1.03;
  use IO::Seekable;               # For SEEK_*
  use Errno;
  use Scalar::Util 'refaddr';
  require VMS::Stdio if $^O eq 'VMS';
  
  # pre-emptively load Carp::Heavy. If we don't when we run out of file
  # handles and attempt to call croak() we get an error message telling
  # us that Carp::Heavy won't load rather than an error telling us we
  # have run out of file handles. We either preload croak() or we
  # switch the calls to croak from _gettemp() to use die.
  eval { require Carp::Heavy; };
  
  # Need the Symbol package if we are running older perl
  require Symbol if $] < 5.006;
  
  ### For the OO interface
  use base qw/ IO::Handle IO::Seekable /;
  use overload '""' => "STRINGIFY", '0+' => "NUMIFY",
    fallback => 1;
  
  # use 'our' on v5.6.0
  use vars qw($VERSION @EXPORT_OK %EXPORT_TAGS $DEBUG $KEEP_ALL);
  
  $DEBUG = 0;
  $KEEP_ALL = 0;
  
  # We are exporting functions
  
  use base qw/Exporter/;
  
  # Export list - to allow fine tuning of export table
  
  @EXPORT_OK = qw{
                   tempfile
                   tempdir
                   tmpnam
                   tmpfile
                   mktemp
                   mkstemp
                   mkstemps
                   mkdtemp
                   unlink0
                   cleanup
                   SEEK_SET
                   SEEK_CUR
                   SEEK_END
               };
  
  # Groups of functions for export
  
  %EXPORT_TAGS = (
                  'POSIX' => [qw/ tmpnam tmpfile /],
                  'mktemp' => [qw/ mktemp mkstemp mkstemps mkdtemp/],
                  'seekable' => [qw/ SEEK_SET SEEK_CUR SEEK_END /],
                 );
  
  # add contents of these tags to @EXPORT
  Exporter::export_tags('POSIX','mktemp','seekable');
  
  # Version number
  
  $VERSION = '0.23';
  
  # This is a list of characters that can be used in random filenames
  
  my @CHARS = (qw/ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
                   a b c d e f g h i j k l m n o p q r s t u v w x y z
                   0 1 2 3 4 5 6 7 8 9 _
                 /);
  
  # Maximum number of tries to make a temp file before failing
  
  use constant MAX_TRIES => 1000;
  
  # Minimum number of X characters that should be in a template
  use constant MINX => 4;
  
  # Default template when no template supplied
  
  use constant TEMPXXX => 'X' x 10;
  
  # Constants for the security level
  
  use constant STANDARD => 0;
  use constant MEDIUM   => 1;
  use constant HIGH     => 2;
  
  # OPENFLAGS. If we defined the flag to use with Sysopen here this gives
  # us an optimisation when many temporary files are requested
  
  my $OPENFLAGS = O_CREAT | O_EXCL | O_RDWR;
  my $LOCKFLAG;
  
  unless ($^O eq 'MacOS') {
    for my $oflag (qw/ NOFOLLOW BINARY LARGEFILE NOINHERIT /) {
      my ($bit, $func) = (0, "Fcntl::O_" . $oflag);
      no strict 'refs';
      $OPENFLAGS |= $bit if eval {
        # Make sure that redefined die handlers do not cause problems
        # e.g. CGI::Carp
        local $SIG{__DIE__} = sub {};
        local $SIG{__WARN__} = sub {};
        $bit = &$func();
        1;
      };
    }
    # Special case O_EXLOCK
    $LOCKFLAG = eval {
      local $SIG{__DIE__} = sub {};
      local $SIG{__WARN__} = sub {};
      &Fcntl::O_EXLOCK();
    };
  }
  
  # On some systems the O_TEMPORARY flag can be used to tell the OS
  # to automatically remove the file when it is closed. This is fine
  # in most cases but not if tempfile is called with UNLINK=>0 and
  # the filename is requested -- in the case where the filename is to
  # be passed to another routine. This happens on windows. We overcome
  # this by using a second open flags variable
  
  my $OPENTEMPFLAGS = $OPENFLAGS;
  unless ($^O eq 'MacOS') {
    for my $oflag (qw/ TEMPORARY /) {
      my ($bit, $func) = (0, "Fcntl::O_" . $oflag);
      local($@);
      no strict 'refs';
      $OPENTEMPFLAGS |= $bit if eval {
        # Make sure that redefined die handlers do not cause problems
        # e.g. CGI::Carp
        local $SIG{__DIE__} = sub {};
        local $SIG{__WARN__} = sub {};
        $bit = &$func();
        1;
      };
    }
  }
  
  # Private hash tracking which files have been created by each process id via the OO interface
  my %FILES_CREATED_BY_OBJECT;
  
  # INTERNAL ROUTINES - not to be used outside of package
  
  # Generic routine for getting a temporary filename
  # modelled on OpenBSD _gettemp() in mktemp.c
  
  # The template must contain X's that are to be replaced
  # with the random values
  
  #  Arguments:
  
  #  TEMPLATE   - string containing the XXXXX's that is converted
  #           to a random filename and opened if required
  
  # Optionally, a hash can also be supplied containing specific options
  #   "open" => if true open the temp file, else just return the name
  #             default is 0
  #   "mkdir"=> if true, we are creating a temp directory rather than tempfile
  #             default is 0
  #   "suffixlen" => number of characters at end of PATH to be ignored.
  #                  default is 0.
  #   "unlink_on_close" => indicates that, if possible,  the OS should remove
  #                        the file as soon as it is closed. Usually indicates
  #                        use of the O_TEMPORARY flag to sysopen.
  #                        Usually irrelevant on unix
  #   "use_exlock" => Indicates that O_EXLOCK should be used. Default is true.
  
  # Optionally a reference to a scalar can be passed into the function
  # On error this will be used to store the reason for the error
  #   "ErrStr"  => \$errstr
  
  # "open" and "mkdir" can not both be true
  # "unlink_on_close" is not used when "mkdir" is true.
  
  # The default options are equivalent to mktemp().
  
  # Returns:
  #   filehandle - open file handle (if called with doopen=1, else undef)
  #   temp name  - name of the temp file or directory
  
  # For example:
  #   ($fh, $name) = _gettemp($template, "open" => 1);
  
  # for the current version, failures are associated with
  # stored in an error string and returned to give the reason whilst debugging
  # This routine is not called by any external function
  sub _gettemp {
  
    croak 'Usage: ($fh, $name) = _gettemp($template, OPTIONS);'
      unless scalar(@_) >= 1;
  
    # the internal error string - expect it to be overridden
    # Need this in case the caller decides not to supply us a value
    # need an anonymous scalar
    my $tempErrStr;
  
    # Default options
    my %options = (
                   "open" => 0,
                   "mkdir" => 0,
                   "suffixlen" => 0,
                   "unlink_on_close" => 0,
                   "use_exlock" => 1,
                   "ErrStr" => \$tempErrStr,
                  );
  
    # Read the template
    my $template = shift;
    if (ref($template)) {
      # Use a warning here since we have not yet merged ErrStr
      carp "File::Temp::_gettemp: template must not be a reference";
      return ();
    }
  
    # Check that the number of entries on stack are even
    if (scalar(@_) % 2 != 0) {
      # Use a warning here since we have not yet merged ErrStr
      carp "File::Temp::_gettemp: Must have even number of options";
      return ();
    }
  
    # Read the options and merge with defaults
    %options = (%options, @_)  if @_;
  
    # Make sure the error string is set to undef
    ${$options{ErrStr}} = undef;
  
    # Can not open the file and make a directory in a single call
    if ($options{"open"} && $options{"mkdir"}) {
      ${$options{ErrStr}} = "doopen and domkdir can not both be true\n";
      return ();
    }
  
    # Find the start of the end of the  Xs (position of last X)
    # Substr starts from 0
    my $start = length($template) - 1 - $options{"suffixlen"};
  
    # Check that we have at least MINX x X (e.g. 'XXXX") at the end of the string
    # (taking suffixlen into account). Any fewer is insecure.
  
    # Do it using substr - no reason to use a pattern match since
    # we know where we are looking and what we are looking for
  
    if (substr($template, $start - MINX + 1, MINX) ne 'X' x MINX) {
      ${$options{ErrStr}} = "The template must end with at least ".
        MINX . " 'X' characters\n";
      return ();
    }
  
    # Replace all the X at the end of the substring with a
    # random character or just all the XX at the end of a full string.
    # Do it as an if, since the suffix adjusts which section to replace
    # and suffixlen=0 returns nothing if used in the substr directly
    # and generate a full path from the template
  
    my $path = _replace_XX($template, $options{"suffixlen"});
  
  
    # Split the path into constituent parts - eventually we need to check
    # whether the directory exists
    # We need to know whether we are making a temp directory
    # or a tempfile
  
    my ($volume, $directories, $file);
    my $parent;                   # parent directory
    if ($options{"mkdir"}) {
      # There is no filename at the end
      ($volume, $directories, $file) = File::Spec->splitpath( $path, 1);
  
      # The parent is then $directories without the last directory
      # Split the directory and put it back together again
      my @dirs = File::Spec->splitdir($directories);
  
      # If @dirs only has one entry (i.e. the directory template) that means
      # we are in the current directory
      if ($#dirs == 0) {
        $parent = File::Spec->curdir;
      } else {
  
        if ($^O eq 'VMS') {     # need volume to avoid relative dir spec
          $parent = File::Spec->catdir($volume, @dirs[0..$#dirs-1]);
          $parent = 'sys$disk:[]' if $parent eq '';
        } else {
  
          # Put it back together without the last one
          $parent = File::Spec->catdir(@dirs[0..$#dirs-1]);
  
          # ...and attach the volume (no filename)
          $parent = File::Spec->catpath($volume, $parent, '');
        }
  
      }
  
    } else {
  
      # Get rid of the last filename (use File::Basename for this?)
      ($volume, $directories, $file) = File::Spec->splitpath( $path );
  
      # Join up without the file part
      $parent = File::Spec->catpath($volume,$directories,'');
  
      # If $parent is empty replace with curdir
      $parent = File::Spec->curdir
        unless $directories ne '';
  
    }
  
    # Check that the parent directories exist
    # Do this even for the case where we are simply returning a name
    # not a file -- no point returning a name that includes a directory
    # that does not exist or is not writable
  
    unless (-e $parent) {
      ${$options{ErrStr}} = "Parent directory ($parent) does not exist";
      return ();
    }
    unless (-d $parent) {
      ${$options{ErrStr}} = "Parent directory ($parent) is not a directory";
      return ();
    }
  
    # Check the stickiness of the directory and chown giveaway if required
    # If the directory is world writable the sticky bit
    # must be set
  
    if (File::Temp->safe_level == MEDIUM) {
      my $safeerr;
      unless (_is_safe($parent,\$safeerr)) {
        ${$options{ErrStr}} = "Parent directory ($parent) is not safe ($safeerr)";
        return ();
      }
    } elsif (File::Temp->safe_level == HIGH) {
      my $safeerr;
      unless (_is_verysafe($parent, \$safeerr)) {
        ${$options{ErrStr}} = "Parent directory ($parent) is not safe ($safeerr)";
        return ();
      }
    }
  
  
    # Now try MAX_TRIES time to open the file
    for (my $i = 0; $i < MAX_TRIES; $i++) {
  
      # Try to open the file if requested
      if ($options{"open"}) {
        my $fh;
  
        # If we are running before perl5.6.0 we can not auto-vivify
        if ($] < 5.006) {
          $fh = &Symbol::gensym;
        }
  
        # Try to make sure this will be marked close-on-exec
        # XXX: Win32 doesn't respect this, nor the proper fcntl,
        #      but may have O_NOINHERIT. This may or may not be in Fcntl.
        local $^F = 2;
  
        # Attempt to open the file
        my $open_success = undef;
        if ( $^O eq 'VMS' and $options{"unlink_on_close"} && !$KEEP_ALL) {
          # make it auto delete on close by setting FAB$V_DLT bit
          $fh = VMS::Stdio::vmssysopen($path, $OPENFLAGS, 0600, 'fop=dlt');
          $open_success = $fh;
        } else {
          my $flags = ( ($options{"unlink_on_close"} && !$KEEP_ALL) ?
                        $OPENTEMPFLAGS :
                        $OPENFLAGS );
          $flags |= $LOCKFLAG if (defined $LOCKFLAG && $options{use_exlock});
          $open_success = sysopen($fh, $path, $flags, 0600);
        }
        if ( $open_success ) {
  
          # in case of odd umask force rw
          chmod(0600, $path);
  
          # Opened successfully - return file handle and name
          return ($fh, $path);
  
        } else {
  
          # Error opening file - abort with error
          # if the reason was anything but EEXIST
          unless ($!{EEXIST}) {
            ${$options{ErrStr}} = "Could not create temp file $path: $!";
            return ();
          }
  
          # Loop round for another try
  
        }
      } elsif ($options{"mkdir"}) {
  
        # Open the temp directory
        if (mkdir( $path, 0700)) {
          # in case of odd umask
          chmod(0700, $path);
  
          return undef, $path;
        } else {
  
          # Abort with error if the reason for failure was anything
          # except EEXIST
          unless ($!{EEXIST}) {
            ${$options{ErrStr}} = "Could not create directory $path: $!";
            return ();
          }
  
          # Loop round for another try
  
        }
  
      } else {
  
        # Return true if the file can not be found
        # Directory has been checked previously
  
        return (undef, $path) unless -e $path;
  
        # Try again until MAX_TRIES
  
      }
  
      # Did not successfully open the tempfile/dir
      # so try again with a different set of random letters
      # No point in trying to increment unless we have only
      # 1 X say and the randomness could come up with the same
      # file MAX_TRIES in a row.
  
      # Store current attempt - in principal this implies that the
      # 3rd time around the open attempt that the first temp file
      # name could be generated again. Probably should store each
      # attempt and make sure that none are repeated
  
      my $original = $path;
      my $counter = 0;            # Stop infinite loop
      my $MAX_GUESS = 50;
  
      do {
  
        # Generate new name from original template
        $path = _replace_XX($template, $options{"suffixlen"});
  
        $counter++;
  
      } until ($path ne $original || $counter > $MAX_GUESS);
  
      # Check for out of control looping
      if ($counter > $MAX_GUESS) {
        ${$options{ErrStr}} = "Tried to get a new temp name different to the previous value $MAX_GUESS times.\nSomething wrong with template?? ($template)";
        return ();
      }
  
    }
  
    # If we get here, we have run out of tries
    ${ $options{ErrStr} } = "Have exceeded the maximum number of attempts ("
      . MAX_TRIES . ") to open temp file/dir";
  
    return ();
  
  }
  
  # Internal routine to replace the XXXX... with random characters
  # This has to be done by _gettemp() every time it fails to
  # open a temp file/dir
  
  # Arguments:  $template (the template with XXX),
  #             $ignore   (number of characters at end to ignore)
  
  # Returns:    modified template
  
  sub _replace_XX {
  
    croak 'Usage: _replace_XX($template, $ignore)'
      unless scalar(@_) == 2;
  
    my ($path, $ignore) = @_;
  
    # Do it as an if, since the suffix adjusts which section to replace
    # and suffixlen=0 returns nothing if used in the substr directly
    # Alternatively, could simply set $ignore to length($path)-1
    # Don't want to always use substr when not required though.
    my $end = ( $] >= 5.006 ? "\\z" : "\\Z" );
  
    if ($ignore) {
      substr($path, 0, - $ignore) =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge;
    } else {
      $path =~ s/X(?=X*$end)/$CHARS[ int( rand( @CHARS ) ) ]/ge;
    }
    return $path;
  }
  
  # Internal routine to force a temp file to be writable after
  # it is created so that we can unlink it. Windows seems to occasionally
  # force a file to be readonly when written to certain temp locations
  sub _force_writable {
    my $file = shift;
    chmod 0600, $file;
  }
  
  
  # internal routine to check to see if the directory is safe
  # First checks to see if the directory is not owned by the
  # current user or root. Then checks to see if anyone else
  # can write to the directory and if so, checks to see if
  # it has the sticky bit set
  
  # Will not work on systems that do not support sticky bit
  
  #Args:  directory path to check
  #       Optionally: reference to scalar to contain error message
  # Returns true if the path is safe and false otherwise.
  # Returns undef if can not even run stat() on the path
  
  # This routine based on version written by Tom Christiansen
  
  # Presumably, by the time we actually attempt to create the
  # file or directory in this directory, it may not be safe
  # anymore... Have to run _is_safe directly after the open.
  
  sub _is_safe {
  
    my $path = shift;
    my $err_ref = shift;
  
    # Stat path
    my @info = stat($path);
    unless (scalar(@info)) {
      $$err_ref = "stat(path) returned no values";
      return 0;
    }
    ;
    return 1 if $^O eq 'VMS';     # owner delete control at file level
  
    # Check to see whether owner is neither superuser (or a system uid) nor me
    # Use the effective uid from the $> variable
    # UID is in [4]
    if ($info[4] > File::Temp->top_system_uid() && $info[4] != $>) {
  
      Carp::cluck(sprintf "uid=$info[4] topuid=%s euid=$> path='$path'",
                  File::Temp->top_system_uid());
  
      $$err_ref = "Directory owned neither by root nor the current user"
        if ref($err_ref);
      return 0;
    }
  
    # check whether group or other can write file
    # use 066 to detect either reading or writing
    # use 022 to check writability
    # Do it with S_IWOTH and S_IWGRP for portability (maybe)
    # mode is in info[2]
    if (($info[2] & &Fcntl::S_IWGRP) ||  # Is group writable?
        ($info[2] & &Fcntl::S_IWOTH) ) { # Is world writable?
      # Must be a directory
      unless (-d $path) {
        $$err_ref = "Path ($path) is not a directory"
          if ref($err_ref);
        return 0;
      }
      # Must have sticky bit set
      unless (-k $path) {
        $$err_ref = "Sticky bit not set on $path when dir is group|world writable"
          if ref($err_ref);
        return 0;
      }
    }
  
    return 1;
  }
  
  # Internal routine to check whether a directory is safe
  # for temp files. Safer than _is_safe since it checks for
  # the possibility of chown giveaway and if that is a possibility
  # checks each directory in the path to see if it is safe (with _is_safe)
  
  # If _PC_CHOWN_RESTRICTED is not set, does the full test of each
  # directory anyway.
  
  # Takes optional second arg as scalar ref to error reason
  
  sub _is_verysafe {
  
    # Need POSIX - but only want to bother if really necessary due to overhead
    require POSIX;
  
    my $path = shift;
    print "_is_verysafe testing $path\n" if $DEBUG;
    return 1 if $^O eq 'VMS';     # owner delete control at file level
  
    my $err_ref = shift;
  
    # Should Get the value of _PC_CHOWN_RESTRICTED if it is defined
    # and If it is not there do the extensive test
    local($@);
    my $chown_restricted;
    $chown_restricted = &POSIX::_PC_CHOWN_RESTRICTED()
      if eval { &POSIX::_PC_CHOWN_RESTRICTED(); 1};
  
    # If chown_resticted is set to some value we should test it
    if (defined $chown_restricted) {
  
      # Return if the current directory is safe
      return _is_safe($path,$err_ref) if POSIX::sysconf( $chown_restricted );
  
    }
  
    # To reach this point either, the _PC_CHOWN_RESTRICTED symbol
    # was not available or the symbol was there but chown giveaway
    # is allowed. Either way, we now have to test the entire tree for
    # safety.
  
    # Convert path to an absolute directory if required
    unless (File::Spec->file_name_is_absolute($path)) {
      $path = File::Spec->rel2abs($path);
    }
  
    # Split directory into components - assume no file
    my ($volume, $directories, undef) = File::Spec->splitpath( $path, 1);
  
    # Slightly less efficient than having a function in File::Spec
    # to chop off the end of a directory or even a function that
    # can handle ../ in a directory tree
    # Sometimes splitdir() returns a blank at the end
    # so we will probably check the bottom directory twice in some cases
    my @dirs = File::Spec->splitdir($directories);
  
    # Concatenate one less directory each time around
    foreach my $pos (0.. $#dirs) {
      # Get a directory name
      my $dir = File::Spec->catpath($volume,
                                    File::Spec->catdir(@dirs[0.. $#dirs - $pos]),
                                    ''
                                   );
  
      print "TESTING DIR $dir\n" if $DEBUG;
  
      # Check the directory
      return 0 unless _is_safe($dir,$err_ref);
  
    }
  
    return 1;
  }
  
  
  
  # internal routine to determine whether unlink works on this
  # platform for files that are currently open.
  # Returns true if we can, false otherwise.
  
  # Currently WinNT, OS/2 and VMS can not unlink an opened file
  # On VMS this is because the O_EXCL flag is used to open the
  # temporary file. Currently I do not know enough about the issues
  # on VMS to decide whether O_EXCL is a requirement.
  
  sub _can_unlink_opened_file {
  
    if (grep { $^O eq $_ } qw/MSWin32 os2 VMS dos MacOS haiku/) {
      return 0;
    } else {
      return 1;
    }
  
  }
  
  # internal routine to decide which security levels are allowed
  # see safe_level() for more information on this
  
  # Controls whether the supplied security level is allowed
  
  #   $cando = _can_do_level( $level )
  
  sub _can_do_level {
  
    # Get security level
    my $level = shift;
  
    # Always have to be able to do STANDARD
    return 1 if $level == STANDARD;
  
    # Currently, the systems that can do HIGH or MEDIUM are identical
    if ( $^O eq 'MSWin32' || $^O eq 'os2' || $^O eq 'cygwin' || $^O eq 'dos' || $^O eq 'MacOS' || $^O eq 'mpeix') {
      return 0;
    } else {
      return 1;
    }
  
  }
  
  # This routine sets up a deferred unlinking of a specified
  # filename and filehandle. It is used in the following cases:
  #  - Called by unlink0 if an opened file can not be unlinked
  #  - Called by tempfile() if files are to be removed on shutdown
  #  - Called by tempdir() if directories are to be removed on shutdown
  
  # Arguments:
  #   _deferred_unlink( $fh, $fname, $isdir );
  #
  #   - filehandle (so that it can be explicitly closed if open
  #   - filename   (the thing we want to remove)
  #   - isdir      (flag to indicate that we are being given a directory)
  #                 [and hence no filehandle]
  
  # Status is not referred to since all the magic is done with an END block
  
  {
    # Will set up two lexical variables to contain all the files to be
    # removed. One array for files, another for directories They will
    # only exist in this block.
  
    #  This means we only have to set up a single END block to remove
    #  all files. 
  
    # in order to prevent child processes inadvertently deleting the parent
    # temp files we use a hash to store the temp files and directories
    # created by a particular process id.
  
    # %files_to_unlink contains values that are references to an array of
    # array references containing the filehandle and filename associated with
    # the temp file.
    my (%files_to_unlink, %dirs_to_unlink);
  
    # Set up an end block to use these arrays
    END {
      local($., $@, $!, $^E, $?);
      cleanup(at_exit => 1);
    }
  
    # Cleanup function. Always triggered on END (with at_exit => 1) but
    # can be invoked manually.
    sub cleanup {
      my %h = @_;
      my $at_exit = delete $h{at_exit};
      $at_exit = 0 if not defined $at_exit;
      { my @k = sort keys %h; die "unrecognized parameters: @k" if @k }
  
      if (!$KEEP_ALL) {
        # Files
        my @files = (exists $files_to_unlink{$$} ?
                     @{ $files_to_unlink{$$} } : () );
        foreach my $file (@files) {
          # close the filehandle without checking its state
          # in order to make real sure that this is closed
          # if its already closed then I dont care about the answer
          # probably a better way to do this
          close($file->[0]);      # file handle is [0]
  
          if (-f $file->[1]) {       # file name is [1]
            _force_writable( $file->[1] ); # for windows
            unlink $file->[1] or warn "Error removing ".$file->[1];
          }
        }
        # Dirs
        my @dirs = (exists $dirs_to_unlink{$$} ?
                    @{ $dirs_to_unlink{$$} } : () );
        my ($cwd, $cwd_to_remove);
        foreach my $dir (@dirs) {
          if (-d $dir) {
            # Some versions of rmtree will abort if you attempt to remove
            # the directory you are sitting in. For automatic cleanup
            # at program exit, we avoid this by chdir()ing out of the way
            # first. If not at program exit, it's best not to mess with the
            # current directory, so just let it fail with a warning.
            if ($at_exit) {
              $cwd = Cwd::abs_path(File::Spec->curdir) if not defined $cwd;
              my $abs = Cwd::abs_path($dir);
              if ($abs eq $cwd) {
                $cwd_to_remove = $dir;
                next;
              }
            }
            eval { rmtree($dir, $DEBUG, 0); };
            warn $@ if ($@ && $^W);
          }
        }
  
        if (defined $cwd_to_remove) {
          # We do need to clean up the current directory, and everything
          # else is done, so get out of there and remove it.
          chdir $cwd_to_remove or die "cannot chdir to $cwd_to_remove: $!";
          my $updir = File::Spec->updir;
          chdir $updir or die "cannot chdir to $updir: $!";
          eval { rmtree($cwd_to_remove, $DEBUG, 0); };
          warn $@ if ($@ && $^W);
        }
  
        # clear the arrays
        @{ $files_to_unlink{$$} } = ()
          if exists $files_to_unlink{$$};
        @{ $dirs_to_unlink{$$} } = ()
          if exists $dirs_to_unlink{$$};
      }
    }
  
  
    # This is the sub called to register a file for deferred unlinking
    # This could simply store the input parameters and defer everything
    # until the END block. For now we do a bit of checking at this
    # point in order to make sure that (1) we have a file/dir to delete
    # and (2) we have been called with the correct arguments.
    sub _deferred_unlink {
  
      croak 'Usage:  _deferred_unlink($fh, $fname, $isdir)'
        unless scalar(@_) == 3;
  
      my ($fh, $fname, $isdir) = @_;
  
      warn "Setting up deferred removal of $fname\n"
        if $DEBUG;
  
      # make sure we save the absolute path for later cleanup
      # OK to untaint because we only ever use this internally
      # as a file path, never interpolating into the shell
      $fname = Cwd::abs_path($fname);
      ($fname) = $fname =~ /^(.*)$/;
  
      # If we have a directory, check that it is a directory
      if ($isdir) {
  
        if (-d $fname) {
  
          # Directory exists so store it
          # first on VMS turn []foo into [.foo] for rmtree
          $fname = VMS::Filespec::vmspath($fname) if $^O eq 'VMS';
          $dirs_to_unlink{$$} = [] 
            unless exists $dirs_to_unlink{$$};
          push (@{ $dirs_to_unlink{$$} }, $fname);
  
        } else {
          carp "Request to remove directory $fname could not be completed since it does not exist!\n" if $^W;
        }
  
      } else {
  
        if (-f $fname) {
  
          # file exists so store handle and name for later removal
          $files_to_unlink{$$} = []
            unless exists $files_to_unlink{$$};
          push(@{ $files_to_unlink{$$} }, [$fh, $fname]);
  
        } else {
          carp "Request to remove file $fname could not be completed since it is not there!\n" if $^W;
        }
  
      }
  
    }
  
  
  }
  
  # normalize argument keys to upper case and do consistent handling
  # of leading template vs TEMPLATE
  sub _parse_args {
    my $leading_template = (scalar(@_) % 2 == 1 ? shift(@_) : '' );
    my %args = @_;
    %args = map { uc($_), $args{$_} } keys %args;
  
    # template (store it in an array so that it will
    # disappear from the arg list of tempfile)
    my @template = (
      exists $args{TEMPLATE}  ? $args{TEMPLATE} :
      $leading_template       ? $leading_template : ()
    );
    delete $args{TEMPLATE};
  
    return( \@template, \%args );
  }
  
  =head1 OBJECT-ORIENTED INTERFACE
  
  This is the primary interface for interacting with
  C<File::Temp>. Using the OO interface a temporary file can be created
  when the object is constructed and the file can be removed when the
  object is no longer required.
  
  Note that there is no method to obtain the filehandle from the
  C<File::Temp> object. The object itself acts as a filehandle.  The object
  isa C<IO::Handle> and isa C<IO::Seekable> so all those methods are
  available.
  
  Also, the object is configured such that it stringifies to the name of the
  temporary file and so can be compared to a filename directly.  It numifies
  to the C<refaddr> the same as other handles and so can be compared to other
  handles with C<==>.
  
      $fh eq $filename       # as a string
      $fh != \*STDOUT        # as a number
  
  =over 4
  
  =item B<new>
  
  Create a temporary file object.
  
    my $tmp = File::Temp->new();
  
  by default the object is constructed as if C<tempfile>
  was called without options, but with the additional behaviour
  that the temporary file is removed by the object destructor
  if UNLINK is set to true (the default).
  
  Supported arguments are the same as for C<tempfile>: UNLINK
  (defaulting to true), DIR, EXLOCK and SUFFIX. Additionally, the filename
  template is specified using the TEMPLATE option. The OPEN option
  is not supported (the file is always opened).
  
   $tmp = File::Temp->new( TEMPLATE => 'tempXXXXX',
                          DIR => 'mydir',
                          SUFFIX => '.dat');
  
  Arguments are case insensitive.
  
  Can call croak() if an error occurs.
  
  =cut
  
  sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
  
    my ($maybe_template, $args) = _parse_args(@_);
  
    # see if they are unlinking (defaulting to yes)
    my $unlink = (exists $args->{UNLINK} ? $args->{UNLINK} : 1 );
    delete $args->{UNLINK};
  
    # Protect OPEN
    delete $args->{OPEN};
  
    # Open the file and retain file handle and file name
    my ($fh, $path) = tempfile( @$maybe_template, %$args );
  
    print "Tmp: $fh - $path\n" if $DEBUG;
  
    # Store the filename in the scalar slot
    ${*$fh} = $path;
  
    # Cache the filename by pid so that the destructor can decide whether to remove it
    $FILES_CREATED_BY_OBJECT{$$}{$path} = 1;
  
    # Store unlink information in hash slot (plus other constructor info)
    %{*$fh} = %$args;
  
    # create the object
    bless $fh, $class;
  
    # final method-based configuration
    $fh->unlink_on_destroy( $unlink );
  
    return $fh;
  }
  
  =item B<newdir>
  
  Create a temporary directory using an object oriented interface.
  
    $dir = File::Temp->newdir();
  
  By default the directory is deleted when the object goes out of scope.
  
  Supports the same options as the C<tempdir> function. Note that directories
  created with this method default to CLEANUP => 1.
  
    $dir = File::Temp->newdir( $template, %options );
  
  A template may be specified either with a leading template or
  with a TEMPLATE argument.
  
  =cut
  
  sub newdir {
    my $self = shift;
  
    my ($maybe_template, $args) = _parse_args(@_);
  
    # handle CLEANUP without passing CLEANUP to tempdir
    my $cleanup = (exists $args->{CLEANUP} ? $args->{CLEANUP} : 1 );
    delete $args->{CLEANUP};
  
    my $tempdir = tempdir( @$maybe_template, %$args);
  
    # get a safe absolute path for cleanup, just like
    # happens in _deferred_unlink
    my $real_dir = Cwd::abs_path( $tempdir );
    ($real_dir) = $real_dir =~ /^(.*)$/;
  
    return bless { DIRNAME => $tempdir,
                   REALNAME => $real_dir,
                   CLEANUP => $cleanup,
                   LAUNCHPID => $$,
                 }, "File::Temp::Dir";
  }
  
  =item B<filename>
  
  Return the name of the temporary file associated with this object
  (if the object was created using the "new" constructor).
  
    $filename = $tmp->filename;
  
  This method is called automatically when the object is used as
  a string.
  
  =cut
  
  sub filename {
    my $self = shift;
    return ${*$self};
  }
  
  sub STRINGIFY {
    my $self = shift;
    return $self->filename;
  }
  
  # For reference, can't use '0+'=>\&Scalar::Util::refaddr directly because
  # refaddr() demands one parameter only, whereas overload.pm calls with three
  # even for unary operations like '0+'.
  sub NUMIFY {
    return refaddr($_[0]);
  }
  
  =item B<dirname>
  
  Return the name of the temporary directory associated with this
  object (if the object was created using the "newdir" constructor).
  
    $dirname = $tmpdir->dirname;
  
  This method is called automatically when the object is used in string context.
  
  =item B<unlink_on_destroy>
  
  Control whether the file is unlinked when the object goes out of scope.
  The file is removed if this value is true and $KEEP_ALL is not.
  
   $fh->unlink_on_destroy( 1 );
  
  Default is for the file to be removed.
  
  =cut
  
  sub unlink_on_destroy {
    my $self = shift;
    if (@_) {
      ${*$self}{UNLINK} = shift;
    }
    return ${*$self}{UNLINK};
  }
  
  =item B<DESTROY>
  
  When the object goes out of scope, the destructor is called. This
  destructor will attempt to unlink the file (using L<unlink1|"unlink1">)
  if the constructor was called with UNLINK set to 1 (the default state
  if UNLINK is not specified).
  
  No error is given if the unlink fails.
  
  If the object has been passed to a child process during a fork, the
  file will be deleted when the object goes out of scope in the parent.
  
  For a temporary directory object the directory will be removed unless
  the CLEANUP argument was used in the constructor (and set to false) or
  C<unlink_on_destroy> was modified after creation.  Note that if a temp
  directory is your current directory, it cannot be removed - a warning
  will be given in this case.  C<chdir()> out of the directory before
  letting the object go out of scope.
  
  If the global variable $KEEP_ALL is true, the file or directory
  will not be removed.
  
  =cut
  
  sub DESTROY {
    local($., $@, $!, $^E, $?);
    my $self = shift;
  
    # Make sure we always remove the file from the global hash
    # on destruction. This prevents the hash from growing uncontrollably
    # and post-destruction there is no reason to know about the file.
    my $file = $self->filename;
    my $was_created_by_proc;
    if (exists $FILES_CREATED_BY_OBJECT{$$}{$file}) {
      $was_created_by_proc = 1;
      delete $FILES_CREATED_BY_OBJECT{$$}{$file};
    }
  
    if (${*$self}{UNLINK} && !$KEEP_ALL) {
      print "# --------->   Unlinking $self\n" if $DEBUG;
  
      # only delete if this process created it
      return unless $was_created_by_proc;
  
      # The unlink1 may fail if the file has been closed
      # by the caller. This leaves us with the decision
      # of whether to refuse to remove the file or simply
      # do an unlink without test. Seems to be silly
      # to do this when we are trying to be careful
      # about security
      _force_writable( $file ); # for windows
      unlink1( $self, $file )
        or unlink($file);
    }
  }
  
  =back
  
  =head1 FUNCTIONS
  
  This section describes the recommended interface for generating
  temporary files and directories.
  
  =over 4
  
  =item B<tempfile>
  
  This is the basic function to generate temporary files.
  The behaviour of the file can be changed using various options:
  
    $fh = tempfile();
    ($fh, $filename) = tempfile();
  
  Create a temporary file in  the directory specified for temporary
  files, as specified by the tmpdir() function in L<File::Spec>.
  
    ($fh, $filename) = tempfile($template);
  
  Create a temporary file in the current directory using the supplied
  template.  Trailing `X' characters are replaced with random letters to
  generate the filename.  At least four `X' characters must be present
  at the end of the template.
  
    ($fh, $filename) = tempfile($template, SUFFIX => $suffix)
  
  Same as previously, except that a suffix is added to the template
  after the `X' translation.  Useful for ensuring that a temporary
  filename has a particular extension when needed by other applications.
  But see the WARNING at the end.
  
    ($fh, $filename) = tempfile($template, DIR => $dir);
  
  Translates the template as before except that a directory name
  is specified.
  
    ($fh, $filename) = tempfile($template, TMPDIR => 1);
  
  Equivalent to specifying a DIR of "File::Spec->tmpdir", writing the file
  into the same temporary directory as would be used if no template was
  specified at all.
  
    ($fh, $filename) = tempfile($template, UNLINK => 1);
  
  Return the filename and filehandle as before except that the file is
  automatically removed when the program exits (dependent on
  $KEEP_ALL). Default is for the file to be removed if a file handle is
  requested and to be kept if the filename is requested. In a scalar
  context (where no filename is returned) the file is always deleted
  either (depending on the operating system) on exit or when it is
  closed (unless $KEEP_ALL is true when the temp file is created).
  
  Use the object-oriented interface if fine-grained control of when
  a file is removed is required.
  
  If the template is not specified, a template is always
  automatically generated. This temporary file is placed in tmpdir()
  (L<File::Spec>) unless a directory is specified explicitly with the
  DIR option.
  
    $fh = tempfile( DIR => $dir );
  
  If called in scalar context, only the filehandle is returned and the
  file will automatically be deleted when closed on operating systems
  that support this (see the description of tmpfile() elsewhere in this
  document).  This is the preferred mode of operation, as if you only
  have a filehandle, you can never create a race condition by fumbling
  with the filename. On systems that can not unlink an open file or can
  not mark a file as temporary when it is opened (for example, Windows
  NT uses the C<O_TEMPORARY> flag) the file is marked for deletion when
  the program ends (equivalent to setting UNLINK to 1). The C<UNLINK>
  flag is ignored if present.
  
    (undef, $filename) = tempfile($template, OPEN => 0);
  
  This will return the filename based on the template but
  will not open this file.  Cannot be used in conjunction with
  UNLINK set to true. Default is to always open the file
  to protect from possible race conditions. A warning is issued
  if warnings are turned on. Consider using the tmpnam()
  and mktemp() functions described elsewhere in this document
  if opening the file is not required.
  
  If the operating system supports it (for example BSD derived systems), the 
  filehandle will be opened with O_EXLOCK (open with exclusive file lock). 
  This can sometimes cause problems if the intention is to pass the filename 
  to another system that expects to take an exclusive lock itself (such as 
  DBD::SQLite) whilst ensuring that the tempfile is not reused. In this 
  situation the "EXLOCK" option can be passed to tempfile. By default EXLOCK 
  will be true (this retains compatibility with earlier releases).
  
    ($fh, $filename) = tempfile($template, EXLOCK => 0);
  
  Options can be combined as required.
  
  Will croak() if there is an error.
  
  =cut
  
  sub tempfile {
    if ( @_ && $_[0] eq 'File::Temp' ) {
        croak "'tempfile' can't be called as a method";
    }
    # Can not check for argument count since we can have any
    # number of args
  
    # Default options
    my %options = (
                   "DIR"    => undef, # Directory prefix
                   "SUFFIX" => '',    # Template suffix
                   "UNLINK" => 0,     # Do not unlink file on exit
                   "OPEN"   => 1,     # Open file
                   "TMPDIR" => 0, # Place tempfile in tempdir if template specified
                   "EXLOCK" => 1, # Open file with O_EXLOCK
                  );
  
    # Check to see whether we have an odd or even number of arguments
    my ($maybe_template, $args) = _parse_args(@_);
    my $template = @$maybe_template ? $maybe_template->[0] : undef;
  
    # Read the options and merge with defaults
    %options = (%options, %$args);
  
    # First decision is whether or not to open the file
    if (! $options{"OPEN"}) {
  
      warn "tempfile(): temporary filename requested but not opened.\nPossibly unsafe, consider using tempfile() with OPEN set to true\n"
        if $^W;
  
    }
  
    if ($options{"DIR"} and $^O eq 'VMS') {
  
      # on VMS turn []foo into [.foo] for concatenation
      $options{"DIR"} = VMS::Filespec::vmspath($options{"DIR"});
    }
  
    # Construct the template
  
    # Have a choice of trying to work around the mkstemp/mktemp/tmpnam etc
    # functions or simply constructing a template and using _gettemp()
    # explicitly. Go for the latter
  
    # First generate a template if not defined and prefix the directory
    # If no template must prefix the temp directory
    if (defined $template) {
      # End up with current directory if neither DIR not TMPDIR are set
      if ($options{"DIR"}) {
  
        $template = File::Spec->catfile($options{"DIR"}, $template);
  
      } elsif ($options{TMPDIR}) {
  
        $template = File::Spec->catfile(File::Spec->tmpdir, $template );
  
      }
  
    } else {
  
      if ($options{"DIR"}) {
  
        $template = File::Spec->catfile($options{"DIR"}, TEMPXXX);
  
      } else {
  
        $template = File::Spec->catfile(File::Spec->tmpdir, TEMPXXX);
  
      }
  
    }
  
    # Now add a suffix
    $template .= $options{"SUFFIX"};
  
    # Determine whether we should tell _gettemp to unlink the file
    # On unix this is irrelevant and can be worked out after the file is
    # opened (simply by unlinking the open filehandle). On Windows or VMS
    # we have to indicate temporary-ness when we open the file. In general
    # we only want a true temporary file if we are returning just the
    # filehandle - if the user wants the filename they probably do not
    # want the file to disappear as soon as they close it (which may be
    # important if they want a child process to use the file)
    # For this reason, tie unlink_on_close to the return context regardless
    # of OS.
    my $unlink_on_close = ( wantarray ? 0 : 1);
  
    # Create the file
    my ($fh, $path, $errstr);
    croak "Error in tempfile() using template $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => $options{'OPEN'},
                                      "mkdir"=> 0 ,
                                      "unlink_on_close" => $unlink_on_close,
                                      "suffixlen" => length($options{'SUFFIX'}),
                                      "ErrStr" => \$errstr,
                                      "use_exlock" => $options{EXLOCK},
                                     ) );
  
    # Set up an exit handler that can do whatever is right for the
    # system. This removes files at exit when requested explicitly or when
    # system is asked to unlink_on_close but is unable to do so because
    # of OS limitations.
    # The latter should be achieved by using a tied filehandle.
    # Do not check return status since this is all done with END blocks.
    _deferred_unlink($fh, $path, 0) if $options{"UNLINK"};
  
    # Return
    if (wantarray()) {
  
      if ($options{'OPEN'}) {
        return ($fh, $path);
      } else {
        return (undef, $path);
      }
  
    } else {
  
      # Unlink the file. It is up to unlink0 to decide what to do with
      # this (whether to unlink now or to defer until later)
      unlink0($fh, $path) or croak "Error unlinking file $path using unlink0";
  
      # Return just the filehandle.
      return $fh;
    }
  
  
  }
  
  =item B<tempdir>
  
  This is the recommended interface for creation of temporary
  directories.  By default the directory will not be removed on exit
  (that is, it won't be temporary; this behaviour can not be changed
  because of issues with backwards compatibility). To enable removal
  either use the CLEANUP option which will trigger removal on program
  exit, or consider using the "newdir" method in the object interface which
  will allow the directory to be cleaned up when the object goes out of
  scope.
  
  The behaviour of the function depends on the arguments:
  
    $tempdir = tempdir();
  
  Create a directory in tmpdir() (see L<File::Spec|File::Spec>).
  
    $tempdir = tempdir( $template );
  
  Create a directory from the supplied template. This template is
  similar to that described for tempfile(). `X' characters at the end
  of the template are replaced with random letters to construct the
  directory name. At least four `X' characters must be in the template.
  
    $tempdir = tempdir ( DIR => $dir );
  
  Specifies the directory to use for the temporary directory.
  The temporary directory name is derived from an internal template.
  
    $tempdir = tempdir ( $template, DIR => $dir );
  
  Prepend the supplied directory name to the template. The template
  should not include parent directory specifications itself. Any parent
  directory specifications are removed from the template before
  prepending the supplied directory.
  
    $tempdir = tempdir ( $template, TMPDIR => 1 );
  
  Using the supplied template, create the temporary directory in
  a standard location for temporary files. Equivalent to doing
  
    $tempdir = tempdir ( $template, DIR => File::Spec->tmpdir);
  
  but shorter. Parent directory specifications are stripped from the
  template itself. The C<TMPDIR> option is ignored if C<DIR> is set
  explicitly.  Additionally, C<TMPDIR> is implied if neither a template
  nor a directory are supplied.
  
    $tempdir = tempdir( $template, CLEANUP => 1);
  
  Create a temporary directory using the supplied template, but
  attempt to remove it (and all files inside it) when the program
  exits. Note that an attempt will be made to remove all files from
  the directory even if they were not created by this module (otherwise
  why ask to clean it up?). The directory removal is made with
  the rmtree() function from the L<File::Path|File::Path> module.
  Of course, if the template is not specified, the temporary directory
  will be created in tmpdir() and will also be removed at program exit.
  
  Will croak() if there is an error.
  
  =cut
  
  # '
  
  sub tempdir  {
    if ( @_ && $_[0] eq 'File::Temp' ) {
        croak "'tempdir' can't be called as a method";
    }
  
    # Can not check for argument count since we can have any
    # number of args
  
    # Default options
    my %options = (
                   "CLEANUP"    => 0, # Remove directory on exit
                   "DIR"        => '', # Root directory
                   "TMPDIR"     => 0,  # Use tempdir with template
                  );
  
    # Check to see whether we have an odd or even number of arguments
    my ($maybe_template, $args) = _parse_args(@_);
    my $template = @$maybe_template ? $maybe_template->[0] : undef;
  
    # Read the options and merge with defaults
    %options = (%options, %$args);
  
    # Modify or generate the template
  
    # Deal with the DIR and TMPDIR options
    if (defined $template) {
  
      # Need to strip directory path if using DIR or TMPDIR
      if ($options{'TMPDIR'} || $options{'DIR'}) {
  
        # Strip parent directory from the filename
        #
        # There is no filename at the end
        $template = VMS::Filespec::vmspath($template) if $^O eq 'VMS';
        my ($volume, $directories, undef) = File::Spec->splitpath( $template, 1);
  
        # Last directory is then our template
        $template = (File::Spec->splitdir($directories))[-1];
  
        # Prepend the supplied directory or temp dir
        if ($options{"DIR"}) {
  
          $template = File::Spec->catdir($options{"DIR"}, $template);
  
        } elsif ($options{TMPDIR}) {
  
          # Prepend tmpdir
          $template = File::Spec->catdir(File::Spec->tmpdir, $template);
  
        }
  
      }
  
    } else {
  
      if ($options{"DIR"}) {
  
        $template = File::Spec->catdir($options{"DIR"}, TEMPXXX);
  
      } else {
  
        $template = File::Spec->catdir(File::Spec->tmpdir, TEMPXXX);
  
      }
  
    }
  
    # Create the directory
    my $tempdir;
    my $suffixlen = 0;
    if ($^O eq 'VMS') {           # dir names can end in delimiters
      $template =~ m/([\.\]:>]+)$/;
      $suffixlen = length($1);
    }
    if ( ($^O eq 'MacOS') && (substr($template, -1) eq ':') ) {
      # dir name has a trailing ':'
      ++$suffixlen;
    }
  
    my $errstr;
    croak "Error in tempdir() using $template: $errstr"
      unless ((undef, $tempdir) = _gettemp($template,
                                           "open" => 0,
                                           "mkdir"=> 1 ,
                                           "suffixlen" => $suffixlen,
                                           "ErrStr" => \$errstr,
                                          ) );
  
    # Install exit handler; must be dynamic to get lexical
    if ( $options{'CLEANUP'} && -d $tempdir) {
      _deferred_unlink(undef, $tempdir, 1);
    }
  
    # Return the dir name
    return $tempdir;
  
  }
  
  =back
  
  =head1 MKTEMP FUNCTIONS
  
  The following functions are Perl implementations of the
  mktemp() family of temp file generation system calls.
  
  =over 4
  
  =item B<mkstemp>
  
  Given a template, returns a filehandle to the temporary file and the name
  of the file.
  
    ($fh, $name) = mkstemp( $template );
  
  In scalar context, just the filehandle is returned.
  
  The template may be any filename with some number of X's appended
  to it, for example F</tmp/temp.XXXX>. The trailing X's are replaced
  with unique alphanumeric combinations.
  
  Will croak() if there is an error.
  
  =cut
  
  
  
  sub mkstemp {
  
    croak "Usage: mkstemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
  
    my ($fh, $path, $errstr);
    croak "Error in mkstemp using $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => 1,
                                      "mkdir"=> 0 ,
                                      "suffixlen" => 0,
                                      "ErrStr" => \$errstr,
                                     ) );
  
    if (wantarray()) {
      return ($fh, $path);
    } else {
      return $fh;
    }
  
  }
  
  
  =item B<mkstemps>
  
  Similar to mkstemp(), except that an extra argument can be supplied
  with a suffix to be appended to the template.
  
    ($fh, $name) = mkstemps( $template, $suffix );
  
  For example a template of C<testXXXXXX> and suffix of C<.dat>
  would generate a file similar to F<testhGji_w.dat>.
  
  Returns just the filehandle alone when called in scalar context.
  
  Will croak() if there is an error.
  
  =cut
  
  sub mkstemps {
  
    croak "Usage: mkstemps(template, suffix)"
      if scalar(@_) != 2;
  
  
    my $template = shift;
    my $suffix   = shift;
  
    $template .= $suffix;
  
    my ($fh, $path, $errstr);
    croak "Error in mkstemps using $template: $errstr"
      unless (($fh, $path) = _gettemp($template,
                                      "open" => 1,
                                      "mkdir"=> 0 ,
                                      "suffixlen" => length($suffix),
                                      "ErrStr" => \$errstr,
                                     ) );
  
    if (wantarray()) {
      return ($fh, $path);
    } else {
      return $fh;
    }
  
  }
  
  =item B<mkdtemp>
  
  Create a directory from a template. The template must end in
  X's that are replaced by the routine.
  
    $tmpdir_name = mkdtemp($template);
  
  Returns the name of the temporary directory created.
  
  Directory must be removed by the caller.
  
  Will croak() if there is an error.
  
  =cut
  
  #' # for emacs
  
  sub mkdtemp {
  
    croak "Usage: mkdtemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
    my $suffixlen = 0;
    if ($^O eq 'VMS') {           # dir names can end in delimiters
      $template =~ m/([\.\]:>]+)$/;
      $suffixlen = length($1);
    }
    if ( ($^O eq 'MacOS') && (substr($template, -1) eq ':') ) {
      # dir name has a trailing ':'
      ++$suffixlen;
    }
    my ($junk, $tmpdir, $errstr);
    croak "Error creating temp directory from template $template\: $errstr"
      unless (($junk, $tmpdir) = _gettemp($template,
                                          "open" => 0,
                                          "mkdir"=> 1 ,
                                          "suffixlen" => $suffixlen,
                                          "ErrStr" => \$errstr,
                                         ) );
  
    return $tmpdir;
  
  }
  
  =item B<mktemp>
  
  Returns a valid temporary filename but does not guarantee
  that the file will not be opened by someone else.
  
    $unopened_file = mktemp($template);
  
  Template is the same as that required by mkstemp().
  
  Will croak() if there is an error.
  
  =cut
  
  sub mktemp {
  
    croak "Usage: mktemp(template)"
      if scalar(@_) != 1;
  
    my $template = shift;
  
    my ($tmpname, $junk, $errstr);
    croak "Error getting name to temp file from template $template: $errstr"
      unless (($junk, $tmpname) = _gettemp($template,
                                           "open" => 0,
                                           "mkdir"=> 0 ,
                                           "suffixlen" => 0,
                                           "ErrStr" => \$errstr,
                                          ) );
  
    return $tmpname;
  }
  
  =back
  
  =head1 POSIX FUNCTIONS
  
  This section describes the re-implementation of the tmpnam()
  and tmpfile() functions described in L<POSIX>
  using the mkstemp() from this module.
  
  Unlike the L<POSIX|POSIX> implementations, the directory used
  for the temporary file is not specified in a system include
  file (C<P_tmpdir>) but simply depends on the choice of tmpdir()
  returned by L<File::Spec|File::Spec>. On some implementations this
  location can be set using the C<TMPDIR> environment variable, which
  may not be secure.
  If this is a problem, simply use mkstemp() and specify a template.
  
  =over 4
  
  =item B<tmpnam>
  
  When called in scalar context, returns the full name (including path)
  of a temporary file (uses mktemp()). The only check is that the file does
  not already exist, but there is no guarantee that that condition will
  continue to apply.
  
    $file = tmpnam();
  
  When called in list context, a filehandle to the open file and
  a filename are returned. This is achieved by calling mkstemp()
  after constructing a suitable template.
  
    ($fh, $file) = tmpnam();
  
  If possible, this form should be used to prevent possible
  race conditions.
  
  See L<File::Spec/tmpdir> for information on the choice of temporary
  directory for a particular operating system.
  
  Will croak() if there is an error.
  
  =cut
  
  sub tmpnam {
  
    # Retrieve the temporary directory name
    my $tmpdir = File::Spec->tmpdir;
  
    croak "Error temporary directory is not writable"
      if $tmpdir eq '';
  
    # Use a ten character template and append to tmpdir
    my $template = File::Spec->catfile($tmpdir, TEMPXXX);
  
    if (wantarray() ) {
      return mkstemp($template);
    } else {
      return mktemp($template);
    }
  
  }
  
  =item B<tmpfile>
  
  Returns the filehandle of a temporary file.
  
    $fh = tmpfile();
  
  The file is removed when the filehandle is closed or when the program
  exits. No access to the filename is provided.
  
  If the temporary file can not be created undef is returned.
  Currently this command will probably not work when the temporary
  directory is on an NFS file system.
  
  Will croak() if there is an error.
  
  =cut
  
  sub tmpfile {
  
    # Simply call tmpnam() in a list context
    my ($fh, $file) = tmpnam();
  
    # Make sure file is removed when filehandle is closed
    # This will fail on NFS
    unlink0($fh, $file)
      or return undef;
  
    return $fh;
  
  }
  
  =back
  
  =head1 ADDITIONAL FUNCTIONS
  
  These functions are provided for backwards compatibility
  with common tempfile generation C library functions.
  
  They are not exported and must be addressed using the full package
  name.
  
  =over 4
  
  =item B<tempnam>
  
  Return the name of a temporary file in the specified directory
  using a prefix. The file is guaranteed not to exist at the time
  the function was called, but such guarantees are good for one
  clock tick only.  Always use the proper form of C<sysopen>
  with C<O_CREAT | O_EXCL> if you must open such a filename.
  
    $filename = File::Temp::tempnam( $dir, $prefix );
  
  Equivalent to running mktemp() with $dir/$prefixXXXXXXXX
  (using unix file convention as an example)
  
  Because this function uses mktemp(), it can suffer from race conditions.
  
  Will croak() if there is an error.
  
  =cut
  
  sub tempnam {
  
    croak 'Usage tempnam($dir, $prefix)' unless scalar(@_) == 2;
  
    my ($dir, $prefix) = @_;
  
    # Add a string to the prefix
    $prefix .= 'XXXXXXXX';
  
    # Concatenate the directory to the file
    my $template = File::Spec->catfile($dir, $prefix);
  
    return mktemp($template);
  
  }
  
  =back
  
  =head1 UTILITY FUNCTIONS
  
  Useful functions for dealing with the filehandle and filename.
  
  =over 4
  
  =item B<unlink0>
  
  Given an open filehandle and the associated filename, make a safe
  unlink. This is achieved by first checking that the filename and
  filehandle initially point to the same file and that the number of
  links to the file is 1 (all fields returned by stat() are compared).
  Then the filename is unlinked and the filehandle checked once again to
  verify that the number of links on that file is now 0.  This is the
  closest you can come to making sure that the filename unlinked was the
  same as the file whose descriptor you hold.
  
    unlink0($fh, $path)
       or die "Error unlinking file $path safely";
  
  Returns false on error but croaks() if there is a security
  anomaly. The filehandle is not closed since on some occasions this is
  not required.
  
  On some platforms, for example Windows NT, it is not possible to
  unlink an open file (the file must be closed first). On those
  platforms, the actual unlinking is deferred until the program ends and
  good status is returned. A check is still performed to make sure that
  the filehandle and filename are pointing to the same thing (but not at
  the time the end block is executed since the deferred removal may not
  have access to the filehandle).
  
  Additionally, on Windows NT not all the fields returned by stat() can
  be compared. For example, the C<dev> and C<rdev> fields seem to be
  different.  Also, it seems that the size of the file returned by stat()
  does not always agree, with C<stat(FH)> being more accurate than
  C<stat(filename)>, presumably because of caching issues even when
  using autoflush (this is usually overcome by waiting a while after
  writing to the tempfile before attempting to C<unlink0> it).
  
  Finally, on NFS file systems the link count of the file handle does
  not always go to zero immediately after unlinking. Currently, this
  command is expected to fail on NFS disks.
  
  This function is disabled if the global variable $KEEP_ALL is true
  and an unlink on open file is supported. If the unlink is to be deferred
  to the END block, the file is still registered for removal.
  
  This function should not be called if you are using the object oriented
  interface since the it will interfere with the object destructor deleting
  the file.
  
  =cut
  
  sub unlink0 {
  
    croak 'Usage: unlink0(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    cmpstat($fh, $path) or return 0;
  
    # attempt remove the file (does not work on some platforms)
    if (_can_unlink_opened_file()) {
  
      # return early (Without unlink) if we have been instructed to retain files.
      return 1 if $KEEP_ALL;
  
      # XXX: do *not* call this on a directory; possible race
      #      resulting in recursive removal
      croak "unlink0: $path has become a directory!" if -d $path;
      unlink($path) or return 0;
  
      # Stat the filehandle
      my @fh = stat $fh;
  
      print "Link count = $fh[3] \n" if $DEBUG;
  
      # Make sure that the link count is zero
      # - Cygwin provides deferred unlinking, however,
      #   on Win9x the link count remains 1
      # On NFS the link count may still be 1 but we can't know that
      # we are on NFS.  Since we can't be sure, we'll defer it
  
      return 1 if $fh[3] == 0 || $^O eq 'cygwin';
    }
    # fall-through if we can't unlink now
    _deferred_unlink($fh, $path, 0);
    return 1;
  }
  
  =item B<cmpstat>
  
  Compare C<stat> of filehandle with C<stat> of provided filename.  This
  can be used to check that the filename and filehandle initially point
  to the same file and that the number of links to the file is 1 (all
  fields returned by stat() are compared).
  
    cmpstat($fh, $path)
       or die "Error comparing handle with file";
  
  Returns false if the stat information differs or if the link count is
  greater than 1. Calls croak if there is a security anomaly.
  
  On certain platforms, for example Windows, not all the fields returned by stat()
  can be compared. For example, the C<dev> and C<rdev> fields seem to be
  different in Windows.  Also, it seems that the size of the file
  returned by stat() does not always agree, with C<stat(FH)> being more
  accurate than C<stat(filename)>, presumably because of caching issues
  even when using autoflush (this is usually overcome by waiting a while
  after writing to the tempfile before attempting to C<unlink0> it).
  
  Not exported by default.
  
  =cut
  
  sub cmpstat {
  
    croak 'Usage: cmpstat(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    warn "Comparing stat\n"
      if $DEBUG;
  
    # Stat the filehandle - which may be closed if someone has manually
    # closed the file. Can not turn off warnings without using $^W
    # unless we upgrade to 5.006 minimum requirement
    my @fh;
    {
      local ($^W) = 0;
      @fh = stat $fh;
    }
    return unless @fh;
  
    if ($fh[3] > 1 && $^W) {
      carp "unlink0: fstat found too many links; SB=@fh" if $^W;
    }
  
    # Stat the path
    my @path = stat $path;
  
    unless (@path) {
      carp "unlink0: $path is gone already" if $^W;
      return;
    }
  
    # this is no longer a file, but may be a directory, or worse
    unless (-f $path) {
      confess "panic: $path is no longer a file: SB=@fh";
    }
  
    # Do comparison of each member of the array
    # On WinNT dev and rdev seem to be different
    # depending on whether it is a file or a handle.
    # Cannot simply compare all members of the stat return
    # Select the ones we can use
    my @okstat = (0..$#fh);       # Use all by default
    if ($^O eq 'MSWin32') {
      @okstat = (1,2,3,4,5,7,8,9,10);
    } elsif ($^O eq 'os2') {
      @okstat = (0, 2..$#fh);
    } elsif ($^O eq 'VMS') {      # device and file ID are sufficient
      @okstat = (0, 1);
    } elsif ($^O eq 'dos') {
      @okstat = (0,2..7,11..$#fh);
    } elsif ($^O eq 'mpeix') {
      @okstat = (0..4,8..10);
    }
  
    # Now compare each entry explicitly by number
    for (@okstat) {
      print "Comparing: $_ : $fh[$_] and $path[$_]\n" if $DEBUG;
      # Use eq rather than == since rdev, blksize, and blocks (6, 11,
      # and 12) will be '' on platforms that do not support them.  This
      # is fine since we are only comparing integers.
      unless ($fh[$_] eq $path[$_]) {
        warn "Did not match $_ element of stat\n" if $DEBUG;
        return 0;
      }
    }
  
    return 1;
  }
  
  =item B<unlink1>
  
  Similar to C<unlink0> except after file comparison using cmpstat, the
  filehandle is closed prior to attempting to unlink the file. This
  allows the file to be removed without using an END block, but does
  mean that the post-unlink comparison of the filehandle state provided
  by C<unlink0> is not available.
  
    unlink1($fh, $path)
       or die "Error closing and unlinking file";
  
  Usually called from the object destructor when using the OO interface.
  
  Not exported by default.
  
  This function is disabled if the global variable $KEEP_ALL is true.
  
  Can call croak() if there is a security anomaly during the stat()
  comparison.
  
  =cut
  
  sub unlink1 {
    croak 'Usage: unlink1(filehandle, filename)'
      unless scalar(@_) == 2;
  
    # Read args
    my ($fh, $path) = @_;
  
    cmpstat($fh, $path) or return 0;
  
    # Close the file
    close( $fh ) or return 0;
  
    # Make sure the file is writable (for windows)
    _force_writable( $path );
  
    # return early (without unlink) if we have been instructed to retain files.
    return 1 if $KEEP_ALL;
  
    # remove the file
    return unlink($path);
  }
  
  =item B<cleanup>
  
  Calling this function will cause any temp files or temp directories
  that are registered for removal to be removed. This happens automatically
  when the process exits but can be triggered manually if the caller is sure
  that none of the temp files are required. This method can be registered as
  an Apache callback.
  
  Note that if a temp directory is your current directory, it cannot be
  removed.  C<chdir()> out of the directory first before calling
  C<cleanup()>. (For the cleanup at program exit when the CLEANUP flag
  is set, this happens automatically.)
  
  On OSes where temp files are automatically removed when the temp file
  is closed, calling this function will have no effect other than to remove
  temporary directories (which may include temporary files).
  
    File::Temp::cleanup();
  
  Not exported by default.
  
  =back
  
  =head1 PACKAGE VARIABLES
  
  These functions control the global state of the package.
  
  =over 4
  
  =item B<safe_level>
  
  Controls the lengths to which the module will go to check the safety of the
  temporary file or directory before proceeding.
  Options are:
  
  =over 8
  
  =item STANDARD
  
  Do the basic security measures to ensure the directory exists and is
  writable, that temporary files are opened only if they do not already
  exist, and that possible race conditions are avoided.  Finally the
  L<unlink0|"unlink0"> function is used to remove files safely.
  
  =item MEDIUM
  
  In addition to the STANDARD security, the output directory is checked
  to make sure that it is owned either by root or the user running the
  program. If the directory is writable by group or by other, it is then
  checked to make sure that the sticky bit is set.
  
  Will not work on platforms that do not support the C<-k> test
  for sticky bit.
  
  =item HIGH
  
  In addition to the MEDIUM security checks, also check for the
  possibility of ``chown() giveaway'' using the L<POSIX|POSIX>
  sysconf() function. If this is a possibility, each directory in the
  path is checked in turn for safeness, recursively walking back to the
  root directory.
  
  For platforms that do not support the L<POSIX|POSIX>
  C<_PC_CHOWN_RESTRICTED> symbol (for example, Windows NT) it is
  assumed that ``chown() giveaway'' is possible and the recursive test
  is performed.
  
  =back
  
  The level can be changed as follows:
  
    File::Temp->safe_level( File::Temp::HIGH );
  
  The level constants are not exported by the module.
  
  Currently, you must be running at least perl v5.6.0 in order to
  run with MEDIUM or HIGH security. This is simply because the
  safety tests use functions from L<Fcntl|Fcntl> that are not
  available in older versions of perl. The problem is that the version
  number for Fcntl is the same in perl 5.6.0 and in 5.005_03 even though
  they are different versions.
  
  On systems that do not support the HIGH or MEDIUM safety levels
  (for example Win NT or OS/2) any attempt to change the level will
  be ignored. The decision to ignore rather than raise an exception
  allows portable programs to be written with high security in mind
  for the systems that can support this without those programs failing
  on systems where the extra tests are irrelevant.
  
  If you really need to see whether the change has been accepted
  simply examine the return value of C<safe_level>.
  
    $newlevel = File::Temp->safe_level( File::Temp::HIGH );
    die "Could not change to high security"
        if $newlevel != File::Temp::HIGH;
  
  =cut
  
  {
    # protect from using the variable itself
    my $LEVEL = STANDARD;
    sub safe_level {
      my $self = shift;
      if (@_) {
        my $level = shift;
        if (($level != STANDARD) && ($level != MEDIUM) && ($level != HIGH)) {
          carp "safe_level: Specified level ($level) not STANDARD, MEDIUM or HIGH - ignoring\n" if $^W;
        } else {
          # Don't allow this on perl 5.005 or earlier
          if ($] < 5.006 && $level != STANDARD) {
            # Cant do MEDIUM or HIGH checks
            croak "Currently requires perl 5.006 or newer to do the safe checks";
          }
          # Check that we are allowed to change level
          # Silently ignore if we can not.
          $LEVEL = $level if _can_do_level($level);
        }
      }
      return $LEVEL;
    }
  }
  
  =item TopSystemUID
  
  This is the highest UID on the current system that refers to a root
  UID. This is used to make sure that the temporary directory is
  owned by a system UID (C<root>, C<bin>, C<sys> etc) rather than
  simply by root.
  
  This is required since on many unix systems C</tmp> is not owned
  by root.
  
  Default is to assume that any UID less than or equal to 10 is a root
  UID.
  
    File::Temp->top_system_uid(10);
    my $topid = File::Temp->top_system_uid;
  
  This value can be adjusted to reduce security checking if required.
  The value is only relevant when C<safe_level> is set to MEDIUM or higher.
  
  =cut
  
  {
    my $TopSystemUID = 10;
    $TopSystemUID = 197108 if $^O eq 'interix'; # "Administrator"
    sub top_system_uid {
      my $self = shift;
      if (@_) {
        my $newuid = shift;
        croak "top_system_uid: UIDs should be numeric"
          unless $newuid =~ /^\d+$/s;
        $TopSystemUID = $newuid;
      }
      return $TopSystemUID;
    }
  }
  
  =item B<$KEEP_ALL>
  
  Controls whether temporary files and directories should be retained
  regardless of any instructions in the program to remove them
  automatically.  This is useful for debugging but should not be used in
  production code.
  
    $File::Temp::KEEP_ALL = 1;
  
  Default is for files to be removed as requested by the caller.
  
  In some cases, files will only be retained if this variable is true
  when the file is created. This means that you can not create a temporary
  file, set this variable and expect the temp file to still be around
  when the program exits.
  
  =item B<$DEBUG>
  
  Controls whether debugging messages should be enabled.
  
    $File::Temp::DEBUG = 1;
  
  Default is for debugging mode to be disabled.
  
  =back
  
  =head1 WARNING
  
  For maximum security, endeavour always to avoid ever looking at,
  touching, or even imputing the existence of the filename.  You do not
  know that that filename is connected to the same file as the handle
  you have, and attempts to check this can only trigger more race
  conditions.  It's far more secure to use the filehandle alone and
  dispense with the filename altogether.
  
  If you need to pass the handle to something that expects a filename
  then on a unix system you can use C<"/dev/fd/" . fileno($fh)> for
  arbitrary programs. Perl code that uses the 2-argument version of
  C<< open >> can be passed C<< "+<=&" . fileno($fh) >>. Otherwise you
  will need to pass the filename. You will have to clear the
  close-on-exec bit on that file descriptor before passing it to another
  process.
  
      use Fcntl qw/F_SETFD F_GETFD/;
      fcntl($tmpfh, F_SETFD, 0)
          or die "Can't clear close-on-exec flag on temp fh: $!\n";
  
  =head2 Temporary files and NFS
  
  Some problems are associated with using temporary files that reside
  on NFS file systems and it is recommended that a local filesystem
  is used whenever possible. Some of the security tests will most probably
  fail when the temp file is not local. Additionally, be aware that
  the performance of I/O operations over NFS will not be as good as for
  a local disk.
  
  =head2 Forking
  
  In some cases files created by File::Temp are removed from within an
  END block. Since END blocks are triggered when a child process exits
  (unless C<POSIX::_exit()> is used by the child) File::Temp takes care
  to only remove those temp files created by a particular process ID. This
  means that a child will not attempt to remove temp files created by the
  parent process.
  
  If you are forking many processes in parallel that are all creating
  temporary files, you may need to reset the random number seed using
  srand(EXPR) in each child else all the children will attempt to walk
  through the same set of random file names and may well cause
  themselves to give up if they exceed the number of retry attempts.
  
  =head2 Directory removal
  
  Note that if you have chdir'ed into the temporary directory and it is
  subsequently cleaned up (either in the END block or as part of object
  destruction), then you will get a warning from File::Path::rmtree().
  
  =head2 Taint mode
  
  If you need to run code under taint mode, updating to the latest
  L<File::Spec> is highly recommended.
  
  =head2 BINMODE
  
  The file returned by File::Temp will have been opened in binary mode
  if such a mode is available. If that is not correct, use the C<binmode()>
  function to change the mode of the filehandle.
  
  Note that you can modify the encoding of a file opened by File::Temp
  also by using C<binmode()>.
  
  =head1 HISTORY
  
  Originally began life in May 1999 as an XS interface to the system
  mkstemp() function. In March 2000, the OpenBSD mkstemp() code was
  translated to Perl for total control of the code's
  security checking, to ensure the presence of the function regardless of
  operating system and to help with portability. The module was shipped
  as a standard part of perl from v5.6.1.
  
  =head1 SEE ALSO
  
  L<POSIX/tmpnam>, L<POSIX/tmpfile>, L<File::Spec>, L<File::Path>
  
  See L<IO::File> and L<File::MkTemp>, L<Apache::TempFile> for
  different implementations of temporary file handling.
  
  See L<File::Tempdir> for an alternative object-oriented wrapper for
  the C<tempdir> function.
  
  =head1 AUTHOR
  
  Tim Jenness E<lt>tjenness@cpan.orgE<gt>
  
  Copyright (C) 2007-2010 Tim Jenness.
  Copyright (C) 1999-2007 Tim Jenness and the UK Particle Physics and
  Astronomy Research Council. All Rights Reserved.  This program is free
  software; you can redistribute it and/or modify it under the same
  terms as Perl itself.
  
  Original Perl implementation loosely based on the OpenBSD C code for
  mkstemp(). Thanks to Tom Christiansen for suggesting that this module
  should be written and providing ideas for code improvements and
  security enhancements.
  
  =cut
  
  package File::Temp::Dir;
  
  use File::Path qw/ rmtree /;
  use strict;
  use overload '""' => "STRINGIFY",
    '0+' => \&File::Temp::NUMIFY,
    fallback => 1;
  
  # private class specifically to support tempdir objects
  # created by File::Temp->newdir
  
  # ostensibly the same method interface as File::Temp but without
  # inheriting all the IO::Seekable methods and other cruft
  
  # Read-only - returns the name of the temp directory
  
  sub dirname {
    my $self = shift;
    return $self->{DIRNAME};
  }
  
  sub STRINGIFY {
    my $self = shift;
    return $self->dirname;
  }
  
  sub unlink_on_destroy {
    my $self = shift;
    if (@_) {
      $self->{CLEANUP} = shift;
    }
    return $self->{CLEANUP};
  }
  
  sub DESTROY {
    my $self = shift;
    local($., $@, $!, $^E, $?);
    if ($self->unlink_on_destroy && 
        $$ == $self->{LAUNCHPID} && !$File::Temp::KEEP_ALL) {
      if (-d $self->{REALNAME}) {
        # Some versions of rmtree will abort if you attempt to remove
        # the directory you are sitting in. We protect that and turn it
        # into a warning. We do this because this occurs during object
        # destruction and so can not be caught by the user.
        eval { rmtree($self->{REALNAME}, $File::Temp::DEBUG, 0); };
        warn $@ if ($@ && $^W);
      }
    }
  }
  
  
  1;
  
  # vim: ts=2 sts=2 sw=2 et:
FILE_TEMP

$fatpacked{"File/chdir.pm"} = <<'FILE_CHDIR';
  package File::chdir;
  use 5.004;
  use strict;
  use vars qw($VERSION @ISA @EXPORT $CWD @CWD);
  # ABSTRACT: a more sensible way to change directories
  our $VERSION = '0.1008'; # VERSION
  
  require Exporter;
  @ISA = qw(Exporter);
  @EXPORT = qw(*CWD);
  
  use Carp;
  use Cwd 3.16;
  use File::Spec::Functions 3.27 qw/canonpath splitpath catpath splitdir catdir/;
  
  tie $CWD, 'File::chdir::SCALAR' or die "Can't tie \$CWD";
  tie @CWD, 'File::chdir::ARRAY'  or die "Can't tie \@CWD";
  
  sub _abs_path {
      # Otherwise we'll never work under taint mode.
      my($cwd) = Cwd::getcwd =~ /(.*)/s;
      # Run through File::Spec, since everything else uses it
      return canonpath($cwd);
  }
  
  # splitpath but also split directory
  sub _split_cwd {
      my ($vol, $dir) = splitpath(_abs_path, 1);
      my @dirs = splitdir( $dir );
      shift @dirs; # get rid of leading empty "root" directory
      return ($vol, @dirs);
  }
  
  # catpath, but take list of directories
  # restore the empty root dir and provide an empty file to avoid warnings
  sub _catpath {
      my ($vol, @dirs) = @_;
      return catpath($vol, catdir(q{}, @dirs), q{});
  }
  
  sub _chdir {
      # Untaint target directory
      my ($new_dir) = $_[0] =~ /(.*)/s;
  
      local $Carp::CarpLevel = $Carp::CarpLevel + 1;
      if ( ! CORE::chdir($new_dir) ) {
          croak "Failed to change directory to '$new_dir': $!";
      };
      return 1;
  }
  
  {
      package File::chdir::SCALAR;
      use Carp;
  
      BEGIN {
          *_abs_path = \&File::chdir::_abs_path;
          *_chdir = \&File::chdir::_chdir;
          *_split_cwd = \&File::chdir::_split_cwd;
          *_catpath = \&File::chdir::_catpath;
      }
  
      sub TIESCALAR {
          bless [], $_[0];
      }
  
      # To be safe, in case someone chdir'd out from under us, we always
      # check the Cwd explicitly.
      sub FETCH {
          return _abs_path;
      }
  
      sub STORE {
          return unless defined $_[1];
          _chdir($_[1]);
      }
  }
  
  
  {
      package File::chdir::ARRAY;
      use Carp;
  
      BEGIN {
          *_abs_path = \&File::chdir::_abs_path;
          *_chdir = \&File::chdir::_chdir;
          *_split_cwd = \&File::chdir::_split_cwd;
          *_catpath = \&File::chdir::_catpath;
      }
  
      sub TIEARRAY {
          bless {}, $_[0];
      }
  
      sub FETCH {
          my($self, $idx) = @_;
          my ($vol, @cwd) = _split_cwd;
          return $cwd[$idx];
      }
  
      sub STORE {
          my($self, $idx, $val) = @_;
  
          my ($vol, @cwd) = _split_cwd;
          if( $self->{Cleared} ) {
              @cwd = ();
              $self->{Cleared} = 0;
          }
  
          $cwd[$idx] = $val;
          my $dir = _catpath($vol,@cwd);
  
          _chdir($dir);
          return $cwd[$idx];
      }
  
      sub FETCHSIZE {
          my ($vol, @cwd) = _split_cwd;
          return scalar @cwd;
      }
      sub STORESIZE {}
  
      sub PUSH {
          my($self) = shift;
  
          my $dir = _catpath(_split_cwd, @_);
          _chdir($dir);
          return $self->FETCHSIZE;
      }
  
      sub POP {
          my($self) = shift;
  
          my ($vol, @cwd) = _split_cwd;
          my $popped = pop @cwd;
          my $dir = _catpath($vol,@cwd);
          _chdir($dir);
          return $popped;
      }
  
      sub SHIFT {
          my($self) = shift;
  
          my ($vol, @cwd) = _split_cwd;
          my $shifted = shift @cwd;
          my $dir = _catpath($vol,@cwd);
          _chdir($dir);
          return $shifted;
      }
  
      sub UNSHIFT {
          my($self) = shift;
  
          my ($vol, @cwd) = _split_cwd;
          my $dir = _catpath($vol, @_, @cwd);
          _chdir($dir);
          return $self->FETCHSIZE;
      }
  
      sub CLEAR  {
          my($self) = shift;
          $self->{Cleared} = 1;
      }
  
      sub SPLICE {
          my $self = shift;
          my $offset = shift || 0;
          my $len = shift || $self->FETCHSIZE - $offset;
          my @new_dirs = @_;
  
          my ($vol, @cwd) = _split_cwd;
          my @orig_dirs = splice @cwd, $offset, $len, @new_dirs;
          my $dir = _catpath($vol, @cwd);
          _chdir($dir);
          return @orig_dirs;
      }
  
      sub EXTEND { }
      sub EXISTS {
          my($self, $idx) = @_;
          return $self->FETCHSIZE >= $idx ? 1 : 0;
      }
  
      sub DELETE {
          my($self, $idx) = @_;
          croak "Can't delete except at the end of \@CWD"
              if $idx < $self->FETCHSIZE - 1;
          local $Carp::CarpLevel = $Carp::CarpLevel + 1;
          $self->POP;
      }
  }
  
  1;
  
  __END__
  
  =pod
  
  =head1 NAME
  
  File::chdir - a more sensible way to change directories
  
  =head1 VERSION
  
  version 0.1008
  
  =head1 SYNOPSIS
  
     use File::chdir;
   
     $CWD = "/foo/bar";     # now in /foo/bar
     {
         local $CWD = "/moo/baz";  # now in /moo/baz
         ...
     }
   
     # still in /foo/bar!
  
  =head1 DESCRIPTION
  
  Perl's C<<< chdir() >>> has the unfortunate problem of being very, very, very
  global.  If any part of your program calls C<<< chdir() >>> or if any library
  you use calls C<<< chdir() >>>, it changes the current working directory for
  the B<whole> program.
  
  This sucks.
  
  File::chdir gives you an alternative, C<<< $CWD >>> and C<<< @CWD >>>.  These two
  variables combine all the power of C<<< chdir() >>>, L<File::Spec> and L<Cwd>.
  
  =head1 $CWD
  
  Use the C<<< $CWD >>> variable instead of C<<< chdir() >>> and Cwd.
  
       use File::chdir;
       $CWD = $dir;  # just like chdir($dir)!
       print $CWD;   # prints the current working directory
  
  It can be localized, and it does the right thing.
  
       $CWD = "/foo";      # it's /foo out here.
       {
           local $CWD = "/bar";  # /bar in here
       }
       # still /foo out here!
  
  C<<< $CWD >>> always returns the absolute path in the native form for the
  operating system.
  
  C<<< $CWD >>> and normal C<<< chdir() >>> work together just fine.
  
  =head1 @CWD
  
  C<<< @CWD >>> represents the current working directory as an array, each
  directory in the path is an element of the array.  This can often make
  the directory easier to manipulate, and you don't have to fumble with
  C<<< File::Spec->splitpath >>> and C<<< File::Spec->catdir >>> to make portable code.
  
     # Similar to chdir("/usr/local/src/perl")
     @CWD = qw(usr local src perl);
  
  pop, push, shift, unshift and splice all work.  pop and push are
  probably the most useful.
  
     pop @CWD;                 # same as chdir(File::Spec->updir)
     push @CWD, 'some_dir'     # same as chdir('some_dir')
  
  C<<< @CWD >>> and C<<< $CWD >>> both work fine together.
  
  B<NOTE> Due to a perl bug you can't localize C<<< @CWD >>>.  See L</CAVEATS> for a work around.
  
  =head1 EXAMPLES
  
  (We omit the C<<< use File::chdir >>> from these examples for terseness)
  
  Here's C<<< $CWD >>> instead of C<<< chdir() >>>:
  
       $CWD = 'foo';           # chdir('foo')
  
  and now instead of Cwd.
  
       print $CWD;             # use Cwd;  print Cwd::abs_path
  
  you can even do zsh style C<<< cd foo bar >>>
  
       $CWD = '/usr/local/foo';
       $CWD =~ s/usr/var/;
  
  if you want to localize that, make sure you get the parens right
  
       {
           (local $CWD) =~ s/usr/var/;
           ...
       }
  
  It's most useful for writing polite subroutines which don't leave the
  program in some strange directory:
  
       sub foo {
           local $CWD = 'some/other/dir';
           ...do your work...
       }
  
  which is much simpler than the equivalent:
  
       sub foo {
           use Cwd;
           my $orig_dir = Cwd::getcwd;
           chdir('some/other/dir');
   
           ...do your work...
   
           chdir($orig_dir);
       }
  
  C<<< @CWD >>> comes in handy when you want to start moving up and down the
  directory hierarchy in a cross-platform manner without having to use
  File::Spec.
  
       pop @CWD;                   # chdir(File::Spec->updir);
       push @CWD, 'some', 'dir'    # chdir(File::Spec->catdir(qw(some dir)));
  
  You can easily change your parent directory:
  
       # chdir from /some/dir/bar/moo to /some/dir/foo/moo
       $CWD[-2] = 'foo';
  
  =head1 CAVEATS
  
  =head3 C<<< local @CWD >>> does not work.
  
  C<<< local @CWD >>> will not localize C<<< @CWD >>>.  This is a bug in Perl, you
  can't localize tied arrays.  As a work around localizing $CWD will
  effectively localize @CWD.
  
       {
           local $CWD;
           pop @CWD;
           ...
       }
  
  =head3 Assigning to C<<< @CWD >>> calls C<<< chdir() >>> for each element
  
       @CWD = qw/a b c d/;
  
  Internally, Perl clears C<<< @CWD >>> and assigns each element in turn.  Thus, this
  code above will do this:
  
       chdir 'a';
       chdir 'a/b';
       chdir 'a/b/c';
       chdir 'a/b/c/d';
  
  Generally, avoid assigning to C<<< @CWD >>> and just use push and pop instead.
  
  =head3 Volumes not handled
  
  There is currently no way to change the current volume via File::chdir.
  
  =head1 NOTES
  
  C<<< $CWD >>> returns the current directory using native path separators, i.e. \
  on Win32.  This ensures that C<<< $CWD >>> will compare correctly with directories
  created using File::Spec.  For example:
  
       my $working_dir = File::Spec->catdir( $CWD, "foo" );
       $CWD = $working_dir;
       doing_stuff_might_chdir();
       is( $CWD, $working_dir, "back to original working_dir?" );
  
  Deleting the last item of C<<< @CWD >>> will act like a pop.  Deleting from the
  middle will throw an exception.
  
       delete @CWD[-1]; # OK
       delete @CWD[-2]; # Dies
  
  What should %CWD do?  Something with volumes?
  
       # chdir to C:\Program Files\Sierra\Half Life ?
       $CWD{C} = '\\Program Files\\Sierra\\Half Life';
  
  =head1 DIAGNOSTICS
  
  If an error is encountered when changing C<<< $CWD >>> or C<<< @CWD >>>, one of
  the following exceptions will be thrown:
  
  =over
  
  =item *
  
  I<Can't delete except at the end of @CWD>
  
  =item *
  
  I<Failed to change directory to '$dir'>
  
  =back
  
  =head1 HISTORY
  
  Michael wanted C<<< local chdir >>> to work.  p5p didn't.  But it wasn't over!
  Was it over when the Germans bombed Pearl Harbor?  Hell, no!
  
  Abigail andE<sol>or Bryan Warnock suggested the C<<< $CWD >>> thing (Michael forgets
  which).  They were right.
  
  The C<<< chdir() >>> override was eliminated in 0.04.
  
  David became co-maintainer with 0.06_01 to fix some chronic
  Win32 path bugs.
  
  As of 0.08, if changing C<<< $CWD >>> or C<<< @CWD >>> fails to change the directory, an
  error will be thrown.
  
  =head1 SEE ALSO
  
  L<File::pushd>, L<File::Spec>, L<Cwd>, L<perlfunc/chdir>,
  "Animal House" L<http://www.imdb.com/title/tt0077975/quotes>
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://rt.cpan.org/Public/Dist/Display.html?Name=File-chdir>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/file-chdir>
  
    git clone git://github.com/dagolden/file-chdir.git
  
  =head1 AUTHORS
  
  =over 4
  
  =item *
  
  David A Golden <dagolden@cpan.org>
  
  =item *
  
  Michael G Schwern <schwern@pobox.com> (original author)
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is copyright (c) 2012 by Michael G Schwern and David A Golden.
  
  This is free software; you can redistribute it and/or modify it under
  the same terms as the Perl 5 programming language system itself.
  
  =cut
FILE_CHDIR

$fatpacked{"File/stat.pm"} = <<'FILE_STAT';
  package File::stat;
  use 5.006;
  
  use strict;
  use warnings;
  use warnings::register;
  use Carp;
  
  BEGIN { *warnif = \&warnings::warnif }
  
  our(@EXPORT, @EXPORT_OK, %EXPORT_TAGS);
  
  our $VERSION = '1.07';
  
  my @fields;
  BEGIN { 
      use Exporter   ();
      @EXPORT      = qw(stat lstat);
      @fields      = qw( $st_dev	   $st_ino    $st_mode 
  		       $st_nlink   $st_uid    $st_gid 
  		       $st_rdev    $st_size 
  		       $st_atime   $st_mtime  $st_ctime 
  		       $st_blksize $st_blocks
  		    );
      @EXPORT_OK   = ( @fields, "stat_cando" );
      %EXPORT_TAGS = ( FIELDS => [ @fields, @EXPORT ] );
  }
  use vars @fields;
  
  use Fcntl qw(S_IRUSR S_IWUSR S_IXUSR);
  
  BEGIN {
      # These constants will croak on use if the platform doesn't define
      # them. It's important to avoid inflicting that on the user.
      no strict 'refs';
      for (qw(suid sgid svtx)) {
          my $val = eval { &{"Fcntl::S_I\U$_"} };
          *{"_$_"} = defined $val ? sub { $_[0] & $val ? 1 : "" } : sub { "" };
      }
      for (qw(SOCK CHR BLK REG DIR LNK)) {
          *{"S_IS$_"} = defined eval { &{"Fcntl::S_IF$_"} }
              ? \&{"Fcntl::S_IS$_"} : sub { "" };
      }
      # FIFO flag and macro don't quite follow the S_IF/S_IS pattern above
      # RT #111638
      *{"S_ISFIFO"} = defined &Fcntl::S_IFIFO
        ? \&Fcntl::S_ISFIFO : sub { "" };
  }
  
  # from doio.c
  sub _ingroup {
      my ($gid, $eff)   = @_;
  
      # I am assuming that since VMS doesn't have getgroups(2), $) will
      # always only contain a single entry.
      $^O eq "VMS"    and return $_[0] == $);
  
      my ($egid, @supp) = split " ", $);
      my ($rgid)        = split " ", $(;
  
      $gid == ($eff ? $egid : $rgid)  and return 1;
      grep $gid == $_, @supp          and return 1;
  
      return "";
  }
  
  # VMS uses the Unix version of the routine, even though this is very
  # suboptimal. VMS has a permissions structure that doesn't really fit
  # into struct stat, and unlike on Win32 the normal -X operators respect
  # that, but unfortunately by the time we get here we've already lost the
  # information we need. It looks to me as though if we were to preserve
  # the st_devnam entry of vmsish.h's fake struct stat (which actually
  # holds the filename) it might be possible to do this right, but both
  # getting that value out of the struct (perl's stat doesn't return it)
  # and interpreting it later would require this module to have an XS
  # component (at which point we might as well just call Perl_cando and
  # have done with it).
      
  if (grep $^O eq $_, qw/os2 MSWin32 dos/) {
  
      # from doio.c
      *cando = sub { ($_[0][2] & $_[1]) ? 1 : "" };
  }
  else {
  
      # from doio.c
      *cando = sub {
          my ($s, $mode, $eff) = @_;
          my $uid = $eff ? $> : $<;
          my ($stmode, $stuid, $stgid) = @$s[2,4,5];
  
          # This code basically assumes that the rwx bits of the mode are
          # the 0777 bits, but so does Perl_cando.
  
          if ($uid == 0 && $^O ne "VMS") {
              # If we're root on unix
              # not testing for executable status => all file tests are true
              return 1 if !($mode & 0111);
              # testing for executable status =>
              # for a file, any x bit will do
              # for a directory, always true
              return 1 if $stmode & 0111 || S_ISDIR($stmode);
              return "";
          }
  
          if ($stuid == $uid) {
              $stmode & $mode         and return 1;
          }
          elsif (_ingroup($stgid, $eff)) {
              $stmode & ($mode >> 3)  and return 1;
          }
          else {
              $stmode & ($mode >> 6)  and return 1;
          }
          return "";
      };
  }
  
  # alias for those who don't like objects
  *stat_cando = \&cando;
  
  my %op = (
      r => sub { cando($_[0], S_IRUSR, 1) },
      w => sub { cando($_[0], S_IWUSR, 1) },
      x => sub { cando($_[0], S_IXUSR, 1) },
      o => sub { $_[0][4] == $>           },
  
      R => sub { cando($_[0], S_IRUSR, 0) },
      W => sub { cando($_[0], S_IWUSR, 0) },
      X => sub { cando($_[0], S_IXUSR, 0) },
      O => sub { $_[0][4] == $<           },
  
      e => sub { 1 },
      z => sub { $_[0][7] == 0    },
      s => sub { $_[0][7]         },
  
      f => sub { S_ISREG ($_[0][2]) },
      d => sub { S_ISDIR ($_[0][2]) },
      l => sub { S_ISLNK ($_[0][2]) },
      p => sub { S_ISFIFO($_[0][2]) },
      S => sub { S_ISSOCK($_[0][2]) },
      b => sub { S_ISBLK ($_[0][2]) },
      c => sub { S_ISCHR ($_[0][2]) },
  
      u => sub { _suid($_[0][2]) },
      g => sub { _sgid($_[0][2]) },
      k => sub { _svtx($_[0][2]) },
  
      M => sub { ($^T - $_[0][9] ) / 86400 },
      C => sub { ($^T - $_[0][10]) / 86400 },
      A => sub { ($^T - $_[0][8] ) / 86400 },
  );
  
  use constant HINT_FILETEST_ACCESS => 0x00400000;
  
  # we need fallback=>1 or stringifying breaks
  use overload 
      fallback => 1,
      -X => sub {
          my ($s, $op) = @_;
  
          if (index("rwxRWX", $op) >= 0) {
              (caller 0)[8] & HINT_FILETEST_ACCESS
                  and warnif("File::stat ignores use filetest 'access'");
  
              $^O eq "VMS" and warnif("File::stat ignores VMS ACLs");
  
              # It would be nice to have a warning about using -l on a
              # non-lstat, but that would require an extra member in the
              # object.
          }
  
          if ($op{$op}) {
              return $op{$op}->($_[0]);
          }
          else {
              croak "-$op is not implemented on a File::stat object";
          }
      };
  
  # Class::Struct forbids use of @ISA
  sub import { goto &Exporter::import }
  
  use Class::Struct qw(struct);
  struct 'File::stat' => [
       map { $_ => '$' } qw{
  	 dev ino mode nlink uid gid rdev size
  	 atime mtime ctime blksize blocks
       }
  ];
  
  sub populate (@) {
      return unless @_;
      my $stob = new();
      @$stob = (
  	$st_dev, $st_ino, $st_mode, $st_nlink, $st_uid, $st_gid, $st_rdev,
          $st_size, $st_atime, $st_mtime, $st_ctime, $st_blksize, $st_blocks ) 
  	    = @_;
      return $stob;
  } 
  
  sub lstat ($)  { populate(CORE::lstat(shift)) }
  
  sub stat ($) {
      my $arg = shift;
      my $st = populate(CORE::stat $arg);
      return $st if defined $st;
  	my $fh;
      {
  		local $!;
  		no strict 'refs';
  		require Symbol;
  		$fh = \*{ Symbol::qualify( $arg, caller() )};
  		return unless defined fileno $fh;
  	}
      return populate(CORE::stat $fh);
  }
  
  1;
  __END__
  
  =head1 NAME
  
  File::stat - by-name interface to Perl's built-in stat() functions
  
  =head1 SYNOPSIS
  
   use File::stat;
   $st = stat($file) or die "No $file: $!";
   if ( ($st->mode & 0111) && $st->nlink > 1) ) {
       print "$file is executable with lotsa links\n";
   } 
  
   if ( -x $st ) {
       print "$file is executable\n";
   }
  
   use Fcntl "S_IRUSR";
   if ( $st->cando(S_IRUSR, 1) ) {
       print "My effective uid can read $file\n";
   }
  
   use File::stat qw(:FIELDS);
   stat($file) or die "No $file: $!";
   if ( ($st_mode & 0111) && ($st_nlink > 1) ) {
       print "$file is executable with lotsa links\n";
   } 
  
  =head1 DESCRIPTION
  
  This module's default exports override the core stat() 
  and lstat() functions, replacing them with versions that return 
  "File::stat" objects.  This object has methods that
  return the similarly named structure field name from the
  stat(2) function; namely,
  dev,
  ino,
  mode,
  nlink,
  uid,
  gid,
  rdev,
  size,
  atime,
  mtime,
  ctime,
  blksize,
  and
  blocks.  
  
  As of version 1.02 (provided with perl 5.12) the object provides C<"-X">
  overloading, so you can call filetest operators (C<-f>, C<-x>, and so
  on) on it. It also provides a C<< ->cando >> method, called like
  
   $st->cando( ACCESS, EFFECTIVE )
  
  where I<ACCESS> is one of C<S_IRUSR>, C<S_IWUSR> or C<S_IXUSR> from the
  L<Fcntl|Fcntl> module, and I<EFFECTIVE> indicates whether to use
  effective (true) or real (false) ids. The method interprets the C<mode>,
  C<uid> and C<gid> fields, and returns whether or not the current process
  would be allowed the specified access.
  
  If you don't want to use the objects, you may import the C<< ->cando >>
  method into your namespace as a regular function called C<stat_cando>.
  This takes an arrayref containing the return values of C<stat> or
  C<lstat> as its first argument, and interprets it for you.
  
  You may also import all the structure fields directly into your namespace
  as regular variables using the :FIELDS import tag.  (Note that this still
  overrides your stat() and lstat() functions.)  Access these fields as
  variables named with a preceding C<st_> in front their method names.
  Thus, C<$stat_obj-E<gt>dev()> corresponds to $st_dev if you import
  the fields.
  
  To access this functionality without the core overrides,
  pass the C<use> an empty import list, and then access
  function functions with their full qualified names.
  On the other hand, the built-ins are still available
  via the C<CORE::> pseudo-package.
  
  =head1 BUGS
  
  As of Perl 5.8.0 after using this module you cannot use the implicit
  C<$_> or the special filehandle C<_> with stat() or lstat(), trying
  to do so leads into strange errors.  The workaround is for C<$_> to
  be explicit
  
      my $stat_obj = stat $_;
  
  and for C<_> to explicitly populate the object using the unexported
  and undocumented populate() function with CORE::stat():
  
      my $stat_obj = File::stat::populate(CORE::stat(_));
  
  =head1 ERRORS
  
  =over 4
  
  =item -%s is not implemented on a File::stat object
  
  The filetest operators C<-t>, C<-T> and C<-B> are not implemented, as
  they require more information than just a stat buffer.
  
  =back
  
  =head1 WARNINGS
  
  These can all be disabled with
  
      no warnings "File::stat";
  
  =over 4
  
  =item File::stat ignores use filetest 'access'
  
  You have tried to use one of the C<-rwxRWX> filetests with C<use
  filetest 'access'> in effect. C<File::stat> will ignore the pragma, and
  just use the information in the C<mode> member as usual.
  
  =item File::stat ignores VMS ACLs
  
  VMS systems have a permissions structure that cannot be completely
  represented in a stat buffer, and unlike on other systems the builtin
  filetest operators respect this. The C<File::stat> overloads, however,
  do not, since the information required is not available.
  
  =back
  
  =head1 NOTE
  
  While this class is currently implemented using the Class::Struct
  module to build a struct-like class, you shouldn't rely upon this.
  
  =head1 AUTHOR
  
  Tom Christiansen
FILE_STAT

$fatpacked{"FileCache.pm"} = <<'FILECACHE';
  package FileCache;
  
  our $VERSION = '1.08';
  
  =head1 NAME
  
  FileCache - keep more files open than the system permits
  
  =head1 SYNOPSIS
  
      no strict 'refs';
  
      use FileCache;
      # or
      use FileCache maxopen => 16;
  
      cacheout $mode, $path;
      # or
      cacheout $path;
      print $path @data;
  
      $fh = cacheout $mode, $path;
      # or
      $fh = cacheout $path;
      print $fh @data;
  
  =head1 DESCRIPTION
  
  The C<cacheout> function will make sure that there's a filehandle open
  for reading or writing available as the pathname you give it. It
  automatically closes and re-opens files if you exceed your system's
  maximum number of file descriptors, or the suggested maximum I<maxopen>.
  
  =over
  
  =item cacheout EXPR
  
  The 1-argument form of cacheout will open a file for writing (C<< '>' >>)
  on it's first use, and appending (C<<< '>>' >>>) thereafter.
  
  Returns EXPR on success for convenience. You may neglect the
  return value and manipulate EXPR as the filehandle directly if you prefer.
  
  =item cacheout MODE, EXPR
  
  The 2-argument form of cacheout will use the supplied mode for the initial
  and subsequent openings. Most valid modes for 3-argument C<open> are supported
  namely; C<< '>' >>, C<< '+>' >>, C<< '<' >>, C<< '<+' >>, C<<< '>>' >>>,
  C< '|-' > and C< '-|' >
  
  To pass supplemental arguments to a program opened with C< '|-' > or C< '-|' >
  append them to the command string as you would system EXPR.
  
  Returns EXPR on success for convenience. You may neglect the
  return value and manipulate EXPR as the filehandle directly if you prefer.
  
  =back
  
  =head1 CAVEATS
  
  While it is permissible to C<close> a FileCache managed file,
  do not do so if you are calling C<FileCache::cacheout> from a package other
  than which it was imported, or with another module which overrides C<close>.
  If you must, use C<FileCache::cacheout_close>.
  
  Although FileCache can be used with piped opens ('-|' or '|-') doing so is
  strongly discouraged.  If FileCache finds it necessary to close and then reopen
  a pipe, the command at the far end of the pipe will be reexecuted - the results
  of performing IO on FileCache'd pipes is unlikely to be what you expect.  The
  ability to use FileCache on pipes may be removed in a future release.
  
  FileCache does not store the current file offset if it finds it necessary to
  close a file.  When the file is reopened, the offset will be as specified by the
  original C<open> file mode.  This could be construed to be a bug.
  
  The module functionality relies on symbolic references, so things will break
  under 'use strict' unless 'no strict "refs"' is also specified.
  
  =head1 BUGS
  
  F<sys/param.h> lies with its C<NOFILE> define on some systems,
  so you may have to set I<maxopen> yourself.
  
  =cut
  
  require 5.006;
  use Carp;
  use strict;
  no strict 'refs';
  
  # These are not C<my> for legacy reasons.
  # Previous versions requested the user set $cacheout_maxopen by hand.
  # Some authors fiddled with %saw to overcome the clobber on initial open.
  use vars qw(%saw $cacheout_maxopen);
  $cacheout_maxopen = 16;
  
  use base 'Exporter';
  our @EXPORT = qw[cacheout cacheout_close];
  
  
  my %isopen;
  my $cacheout_seq = 0;
  
  sub import {
      my ($pkg,%args) = @_;
  
      # Use Exporter. %args are for us, not Exporter.
      # Make sure to up export_to_level, or we will import into ourselves,
      # rather than our calling package;
  
      __PACKAGE__->export_to_level(1);
      Exporter::import( $pkg );
  
      # Truth is okay here because setting maxopen to 0 would be bad
      return $cacheout_maxopen = $args{maxopen} if $args{maxopen};
  
      # XXX This code is crazy.  Why is it a one element foreach loop?
      # Why is it using $param both as a filename and filehandle?
      foreach my $param ( '/usr/include/sys/param.h' ){
        if (open($param, '<', $param)) {
  	local ($_, $.);
  	while (<$param>) {
  	  if( /^\s*#\s*define\s+NOFILE\s+(\d+)/ ){
  	    $cacheout_maxopen = $1 - 4;
  	    close($param);
  	    last;
  	  }
  	}
  	close $param;
        }
      }
      $cacheout_maxopen ||= 16;
  }
  
  # Open in their package.
  sub cacheout_open {
    return open(*{caller(1) . '::' . $_[1]}, $_[0], $_[1]) && $_[1];
  }
  
  # Close in their package.
  sub cacheout_close {
    # Short-circuit in case the filehandle disappeared
    my $pkg = caller($_[1]||0);
    defined fileno(*{$pkg . '::' . $_[0]}) &&
      CORE::close(*{$pkg . '::' . $_[0]});
    delete $isopen{$_[0]};
  }
  
  # But only this sub name is visible to them.
  sub cacheout {
      my($mode, $file, $class, $ret, $ref, $narg);
      croak "Not enough arguments for cacheout"  unless $narg = scalar @_;
      croak "Too many arguments for cacheout"    if $narg > 2;
  
      ($mode, $file) = @_;
      ($file, $mode) = ($mode, $file) if $narg == 1;
      croak "Invalid mode for cacheout" if $mode &&
        ( $mode !~ /^\s*(?:>>|\+?>|\+?<|\|\-|)|\-\|\s*$/ );
  
      # Mode changed?
      if( $isopen{$file} && ($mode||'>') ne $isopen{$file}->[1] ){
        &cacheout_close($file, 1);
      }
  
      if( $isopen{$file}) {
        $ret = $file;
        $isopen{$file}->[0]++;
      }
      else{
        if( scalar keys(%isopen) > $cacheout_maxopen -1 ) {
  	my @lru = sort{ $isopen{$a}->[0] <=> $isopen{$b}->[0] } keys(%isopen);
  	$cacheout_seq = 0;
  	$isopen{$_}->[0] = $cacheout_seq++ for
  	  splice(@lru, int($cacheout_maxopen / 3)||$cacheout_maxopen);
  	&cacheout_close($_, 1) for @lru;
        }
  
        unless( $ref ){
  	$mode ||= $saw{$file} ? '>>' : ($saw{$file}=1, '>');
        }
        #XXX should we just return the value from cacheout_open, no croak?
        $ret = cacheout_open($mode, $file) or croak("Can't create $file: $!");
  
        $isopen{$file} = [++$cacheout_seq, $mode];
      }
      return $ret;
  }
  1;
FILECACHE

$fatpacked{"FileHandle.pm"} = <<'FILEHANDLE';
  package FileHandle;
  
  use 5.006;
  use strict;
  our($VERSION, @ISA, @EXPORT, @EXPORT_OK);
  
  $VERSION = "2.02";
  
  require IO::File;
  @ISA = qw(IO::File);
  
  @EXPORT = qw(_IOFBF _IOLBF _IONBF);
  
  @EXPORT_OK = qw(
      pipe
  
      autoflush
      output_field_separator
      output_record_separator
      input_record_separator
      input_line_number
      format_page_number
      format_lines_per_page
      format_lines_left
      format_name
      format_top_name
      format_line_break_characters
      format_formfeed
  
      print
      printf
      getline
      getlines
  );
  
  #
  # Everything we're willing to export, we must first import.
  #
  import IO::Handle grep { !defined(&$_) } @EXPORT, @EXPORT_OK;
  
  #
  # Some people call "FileHandle::function", so all the functions
  # that were in the old FileHandle class must be imported, too.
  #
  {
      no strict 'refs';
  
      my %import = (
  	'IO::Handle' =>
  	    [qw(DESTROY new_from_fd fdopen close fileno getc ungetc gets
  		eof flush error clearerr setbuf setvbuf _open_mode_string)],
  	'IO::Seekable' =>
  	    [qw(seek tell getpos setpos)],
  	'IO::File' =>
  	    [qw(new new_tmpfile open)]
      );
      for my $pkg (keys %import) {
  	for my $func (@{$import{$pkg}}) {
  	    my $c = *{"${pkg}::$func"}{CODE}
  		or die "${pkg}::$func missing";
  	    *$func = $c;
  	}
      }
  }
  
  #
  # Specialized importer for Fcntl magic.
  #
  sub import {
      my $pkg = shift;
      my $callpkg = caller;
      require Exporter;
      Exporter::export($pkg, $callpkg, @_);
  
      #
      # If the Fcntl extension is available,
      #  export its constants.
      #
      eval {
  	require Fcntl;
  	Exporter::export('Fcntl', $callpkg);
      };
  }
  
  ################################################
  # This is the only exported function we define;
  # the rest come from other classes.
  #
  
  sub pipe {
      my $r = new IO::Handle;
      my $w = new IO::Handle;
      CORE::pipe($r, $w) or return undef;
      ($r, $w);
  }
  
  # Rebless standard file handles
  bless *STDIN{IO},  "FileHandle" if ref *STDIN{IO}  eq "IO::Handle";
  bless *STDOUT{IO}, "FileHandle" if ref *STDOUT{IO} eq "IO::Handle";
  bless *STDERR{IO}, "FileHandle" if ref *STDERR{IO} eq "IO::Handle";
  
  1;
  
  __END__
  
  =head1 NAME
  
  FileHandle - supply object methods for filehandles
  
  =head1 SYNOPSIS
  
      use FileHandle;
  
      $fh = FileHandle->new;
      if ($fh->open("< file")) {
          print <$fh>;
          $fh->close;
      }
  
      $fh = FileHandle->new("> FOO");
      if (defined $fh) {
          print $fh "bar\n";
          $fh->close;
      }
  
      $fh = FileHandle->new("file", "r");
      if (defined $fh) {
          print <$fh>;
          undef $fh;       # automatically closes the file
      }
  
      $fh = FileHandle->new("file", O_WRONLY|O_APPEND);
      if (defined $fh) {
          print $fh "corge\n";
          undef $fh;       # automatically closes the file
      }
  
      $pos = $fh->getpos;
      $fh->setpos($pos);
  
      $fh->setvbuf($buffer_var, _IOLBF, 1024);
  
      ($readfh, $writefh) = FileHandle::pipe;
  
      autoflush STDOUT 1;
  
  =head1 DESCRIPTION
  
  NOTE: This class is now a front-end to the IO::* classes.
  
  C<FileHandle::new> creates a C<FileHandle>, which is a reference to a
  newly created symbol (see the C<Symbol> package).  If it receives any
  parameters, they are passed to C<FileHandle::open>; if the open fails,
  the C<FileHandle> object is destroyed.  Otherwise, it is returned to
  the caller.
  
  C<FileHandle::new_from_fd> creates a C<FileHandle> like C<new> does.
  It requires two parameters, which are passed to C<FileHandle::fdopen>;
  if the fdopen fails, the C<FileHandle> object is destroyed.
  Otherwise, it is returned to the caller.
  
  C<FileHandle::open> accepts one parameter or two.  With one parameter,
  it is just a front end for the built-in C<open> function.  With two
  parameters, the first parameter is a filename that may include
  whitespace or other special characters, and the second parameter is
  the open mode, optionally followed by a file permission value.
  
  If C<FileHandle::open> receives a Perl mode string (">", "+<", etc.)
  or a POSIX fopen() mode string ("w", "r+", etc.), it uses the basic
  Perl C<open> operator.
  
  If C<FileHandle::open> is given a numeric mode, it passes that mode
  and the optional permissions value to the Perl C<sysopen> operator.
  For convenience, C<FileHandle::import> tries to import the O_XXX
  constants from the Fcntl module.  If dynamic loading is not available,
  this may fail, but the rest of FileHandle will still work.
  
  C<FileHandle::fdopen> is like C<open> except that its first parameter
  is not a filename but rather a file handle name, a FileHandle object,
  or a file descriptor number.
  
  If the C functions fgetpos() and fsetpos() are available, then
  C<FileHandle::getpos> returns an opaque value that represents the
  current position of the FileHandle, and C<FileHandle::setpos> uses
  that value to return to a previously visited position.
  
  If the C function setvbuf() is available, then C<FileHandle::setvbuf>
  sets the buffering policy for the FileHandle.  The calling sequence
  for the Perl function is the same as its C counterpart, including the
  macros C<_IOFBF>, C<_IOLBF>, and C<_IONBF>, except that the buffer
  parameter specifies a scalar variable to use as a buffer.  WARNING: A
  variable used as a buffer by C<FileHandle::setvbuf> must not be
  modified in any way until the FileHandle is closed or until
  C<FileHandle::setvbuf> is called again, or memory corruption may
  result!
  
  See L<perlfunc> for complete descriptions of each of the following
  supported C<FileHandle> methods, which are just front ends for the
  corresponding built-in functions:
  
      close
      fileno
      getc
      gets
      eof
      clearerr
      seek
      tell
  
  See L<perlvar> for complete descriptions of each of the following
  supported C<FileHandle> methods:
  
      autoflush
      output_field_separator
      output_record_separator
      input_record_separator
      input_line_number
      format_page_number
      format_lines_per_page
      format_lines_left
      format_name
      format_top_name
      format_line_break_characters
      format_formfeed
  
  Furthermore, for doing normal I/O you might need these:
  
  =over 4
  
  =item $fh->print
  
  See L<perlfunc/print>.
  
  =item $fh->printf
  
  See L<perlfunc/printf>.
  
  =item $fh->getline
  
  This works like <$fh> described in L<perlop/"I/O Operators">
  except that it's more readable and can be safely called in a
  list context but still returns just one line.
  
  =item $fh->getlines
  
  This works like <$fh> when called in a list context to
  read all the remaining lines in a file, except that it's more readable.
  It will also croak() if accidentally called in a scalar context.
  
  =back
  
  There are many other functions available since FileHandle is descended
  from IO::File, IO::Seekable, and IO::Handle.  Please see those
  respective pages for documentation on more functions.
  
  =head1 SEE ALSO
  
  The B<IO> extension,
  L<perlfunc>, 
  L<perlop/"I/O Operators">.
  
  =cut
FILEHANDLE

$fatpacked{"Filter/Simple.pm"} = <<'FILTER_SIMPLE';
  package Filter::Simple;
  
  use Text::Balanced ':ALL';
  
  use vars qw{ $VERSION @EXPORT };
  
  $VERSION = '0.89';
  
  use Filter::Util::Call;
  use Carp;
  
  @EXPORT = qw( FILTER FILTER_ONLY );
  
  
  sub import {
      if (@_>1) { shift; goto &FILTER }
      else      { *{caller()."::$_"} = \&$_ foreach @EXPORT }
  }
  
  sub fail {
      croak "FILTER_ONLY: ", @_;
  }
  
  my $exql = sub {
      my @bits = extract_quotelike $_[0], qr//;
      return unless $bits[0];
      return \@bits;
  };
  
  my $ncws = qr/\s+/;
  my $comment = qr/(?<![\$\@%])#.*/;
  my $ws = qr/(?:$ncws|$comment)+/;
  my $id = qr/\b(?!([ysm]|q[rqxw]?|tr)\b)\w+/;
  my $EOP = qr/\n\n|\Z/;
  my $CUT = qr/\n=cut.*$EOP/;
  my $pod_or_DATA = qr/
                ^=(?:head[1-4]|item) .*? $CUT
              | ^=pod .*? $CUT
              | ^=for .*? $CUT
              | ^=begin .*? $CUT
              | ^__(DATA|END)__\r?\n.*
              /smx;
  my $variable = qr{
          [\$*\@%]\s*
              \{\s*(?!::)(?:\d+|[][&`'#+*./|,";%=~:?!\@<>()-]|\^[A-Z]?)\}
        | (?:\$#?|[*\@\%]|\\&)\$*\s*
                 (?:  \{\s*(?:\^(?=[A-Z_]))?(?:\w|::|'\w)*\s*\}
                    |      (?:\^(?=[A-Z_]))?(?:\w|::|'\w)*
                    | (?=\{)  # ${ block }
                 )
          )
        | \$\s*(?!::)(?:\d+|[][&`'#+*./|,";%=~:?!\@<>()-]|\^[A-Z]?)
     }x;
  
  my %extractor_for = (
      quotelike  => [ $ws,  $variable, $id, { MATCH  => \&extract_quotelike } ],
      regex      => [ $ws,  $pod_or_DATA, $id, $exql           ],
      string     => [ $ws,  $pod_or_DATA, $id, $exql           ],
      code       => [ $ws, { DONT_MATCH => $pod_or_DATA }, $variable,
                      $id, { DONT_MATCH => \&extract_quotelike }   ],
      code_no_comments
                 => [ { DONT_MATCH => $comment },
                      $ncws, { DONT_MATCH => $pod_or_DATA }, $variable,
                      $id, { DONT_MATCH => \&extract_quotelike }   ],
      executable => [ $ws, { DONT_MATCH => $pod_or_DATA }      ],
      executable_no_comments
                 => [ { DONT_MATCH => $comment },
                      $ncws, { DONT_MATCH => $pod_or_DATA }      ],
      all        => [        { MATCH  => qr/(?s:.*)/         } ],
  );
  
  my %selector_for = (
      all   => sub { my ($t)=@_; sub{ $_=$$_; $t->(@_); $_} },
      executable=> sub { my ($t)=@_; sub{ref() ? $_=$$_ : $t->(@_); $_} }, 
      quotelike => sub { my ($t)=@_; sub{ref() && do{$_=$$_; $t->(@_)}; $_} },
      regex     => sub { my ($t)=@_;
                 sub{ref() or return $_;
                     my ($ql,undef,$pre,$op,$ld,$pat) = @$_;
                     return $_->[0] unless $op =~ /^(qr|m|s)/
                           || !$op && ($ld eq '/' || $ld eq '?');
                     $_ = $pat;
                     $t->(@_);
                     $ql =~ s/^(\s*\Q$op\E\s*\Q$ld\E)\Q$pat\E/$1$_/;
                     return "$pre$ql";
                    };
              },
      string     => sub { my ($t)=@_;
                 sub{ref() or return $_;
                     local *args = \@_;
                     my ($pre,$op,$ld1,$str1,$rd1,$ld2,$str2,$rd2,$flg) = @{$_}[2..10];
                     return $_->[0] if $op =~ /^(qr|m)/
                           || !$op && ($ld1 eq '/' || $ld1 eq '?');
                     if (!$op || $op eq 'tr' || $op eq 'y') {
                         local *_ = \$str1;
                         $t->(@args);
                     }
                     if ($op =~ /^(tr|y|s)/) {
                         local *_ = \$str2;
                         $t->(@args);
                     }
                     my $result = "$pre$op$ld1$str1$rd1";
                     $result .= $ld2 if $ld1 =~ m/[[({<]/; #])}>
                     $result .= "$str2$rd2$flg";
                     return $result;
                    };
                },
  );
  
  
  sub gen_std_filter_for {
      my ($type, $transform) = @_;
      return sub {
          my $instr;
          local @components;
  		for (extract_multiple($_,$extractor_for{$type})) {
              if (ref())     { push @components, $_; $instr=0 }
              elsif ($instr) { $components[-1] .= $_ }
              else           { push @components, $_; $instr=1 }
          }
          if ($type =~ /^code/) {
              my $count = 0;
              local $placeholder = qr/\Q$;\E(\C{4})\Q$;\E/;
              my $extractor =      qr/\Q$;\E(\C{4})\Q$;\E/;
              $_ = join "",
                    map { ref $_ ? $;.pack('N',$count++).$; : $_ }
                        @components;
              @components = grep { ref $_ } @components;
              $transform->(@_);
              s/$extractor/${$components[unpack('N',$1)]}/g;
          }
          else {
              my $selector = $selector_for{$type}->($transform);
              $_ = join "", map $selector->(@_), @components;
          }
      }
  };
  
  sub FILTER (&;$) {
      my $caller = caller;
      my ($filter, $terminator) = @_;
      no warnings 'redefine';
      *{"${caller}::import"} = gen_filter_import($caller,$filter,$terminator);
      *{"${caller}::unimport"} = gen_filter_unimport($caller);
  }
  
  sub FILTER_ONLY {
      my $caller = caller;
      while (@_ > 1) {
          my ($what, $how) = splice(@_, 0, 2);
          fail "Unknown selector: $what"
              unless exists $extractor_for{$what};
          fail "Filter for $what is not a subroutine reference"
              unless ref $how eq 'CODE';
          push @transforms, gen_std_filter_for($what,$how);
      }
      my $terminator = shift;
  
      my $multitransform = sub {
          foreach my $transform ( @transforms ) {
              $transform->(@_);
          }
      };
      no warnings 'redefine';
      *{"${caller}::import"} =
          gen_filter_import($caller,$multitransform,$terminator);
      *{"${caller}::unimport"} = gen_filter_unimport($caller);
  }
  
  my $ows    = qr/(?:[ \t]+|#[^\n]*)*/;
  
  sub gen_filter_import {
      my ($class, $filter, $terminator) = @_;
      my %terminator;
      my $prev_import = *{$class."::import"}{CODE};
      return sub {
          my ($imported_class, @args) = @_;
          my $def_terminator =
              qr/^(?:\s*no\s+$imported_class\s*;$ows|__(?:END|DATA)__)\r?$/;
          if (!defined $terminator) {
              $terminator{terminator} = $def_terminator;
          }
          elsif (!ref $terminator || ref $terminator eq 'Regexp') {
              $terminator{terminator} = $terminator;
          }
          elsif (ref $terminator ne 'HASH') {
              croak "Terminator must be specified as scalar or hash ref"
          }
          elsif (!exists $terminator->{terminator}) {
              $terminator{terminator} = $def_terminator;
          }
          filter_add(
              sub {
                  my ($status, $lastline);
                  my $count = 0;
                  my $data = "";
                  while ($status = filter_read()) {
                      return $status if $status < 0;
                      if ($terminator{terminator} &&
                          m/$terminator{terminator}/) {
                          $lastline = $_;
                          last;
                      }
                      $data .= $_;
                      $count++;
                      $_ = "";
                  }
                  return $count if not $count;
                  $_ = $data;
                  $filter->($imported_class, @args) unless $status < 0;
                  if (defined $lastline) {
                      if (defined $terminator{becomes}) {
                          $_ .= $terminator{becomes};
                      }
                      elsif ($lastline =~ $def_terminator) {
                          $_ .= $lastline;
                      }
                  }
                  return $count;
              }
          );
          if ($prev_import) {
              goto &$prev_import;
          }
          elsif ($class->isa('Exporter')) {
              $class->export_to_level(1,@_);
          }
      }
  }
  
  sub gen_filter_unimport {
      my ($class) = @_;
      return sub {
          filter_del();
          goto &$prev_unimport if $prev_unimport;
      }
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  Filter::Simple - Simplified source filtering
  
  
  =head1 SYNOPSIS
  
   # in MyFilter.pm:
  
       package MyFilter;
  
       use Filter::Simple;
  
       FILTER { ... };
  
       # or just:
       #
       # use Filter::Simple sub { ... };
  
   # in user's code:
  
       use MyFilter;
  
       # this code is filtered
  
       no MyFilter;
  
       # this code is not
  
  
  =head1 DESCRIPTION
  
  =head2 The Problem
  
  Source filtering is an immensely powerful feature of recent versions of Perl.
  It allows one to extend the language itself (e.g. the Switch module), to 
  simplify the language (e.g. Language::Pythonesque), or to completely recast the
  language (e.g. Lingua::Romana::Perligata). Effectively, it allows one to use
  the full power of Perl as its own, recursively applied, macro language.
  
  The excellent Filter::Util::Call module (by Paul Marquess) provides a
  usable Perl interface to source filtering, but it is often too powerful
  and not nearly as simple as it could be.
  
  To use the module it is necessary to do the following:
  
  =over 4
  
  =item 1.
  
  Download, build, and install the Filter::Util::Call module.
  (If you have Perl 5.7.1 or later, this is already done for you.)
  
  =item 2.
  
  Set up a module that does a C<use Filter::Util::Call>.
  
  =item 3.
  
  Within that module, create an C<import> subroutine.
  
  =item 4.
  
  Within the C<import> subroutine do a call to C<filter_add>, passing
  it either a subroutine reference.
  
  =item 5.
  
  Within the subroutine reference, call C<filter_read> or C<filter_read_exact>
  to "prime" $_ with source code data from the source file that will
  C<use> your module. Check the status value returned to see if any
  source code was actually read in.
  
  =item 6.
  
  Process the contents of $_ to change the source code in the desired manner.
  
  =item 7.
  
  Return the status value.
  
  =item 8.
  
  If the act of unimporting your module (via a C<no>) should cause source
  code filtering to cease, create an C<unimport> subroutine, and have it call
  C<filter_del>. Make sure that the call to C<filter_read> or
  C<filter_read_exact> in step 5 will not accidentally read past the
  C<no>. Effectively this limits source code filters to line-by-line
  operation, unless the C<import> subroutine does some fancy
  pre-pre-parsing of the source code it's filtering.
  
  =back
  
  For example, here is a minimal source code filter in a module named
  BANG.pm. It simply converts every occurrence of the sequence C<BANG\s+BANG>
  to the sequence C<die 'BANG' if $BANG> in any piece of code following a
  C<use BANG;> statement (until the next C<no BANG;> statement, if any):
  
      package BANG;
  
      use Filter::Util::Call ;
  
      sub import {
          filter_add( sub {
          my $caller = caller;
          my ($status, $no_seen, $data);
          while ($status = filter_read()) {
              if (/^\s*no\s+$caller\s*;\s*?$/) {
                  $no_seen=1;
                  last;
              }
              $data .= $_;
              $_ = "";
          }
          $_ = $data;
          s/BANG\s+BANG/die 'BANG' if \$BANG/g
              unless $status < 0;
          $_ .= "no $class;\n" if $no_seen;
          return 1;
          })
      }
  
      sub unimport {
          filter_del();
      }
  
      1 ;
  
  This level of sophistication puts filtering out of the reach of
  many programmers.
  
  
  =head2 A Solution
  
  The Filter::Simple module provides a simplified interface to
  Filter::Util::Call; one that is sufficient for most common cases.
  
  Instead of the above process, with Filter::Simple the task of setting up
  a source code filter is reduced to:
  
  =over 4
  
  =item 1.
  
  Download and install the Filter::Simple module.
  (If you have Perl 5.7.1 or later, this is already done for you.)
  
  =item 2.
  
  Set up a module that does a C<use Filter::Simple> and then
  calls C<FILTER { ... }>.
  
  =item 3.
  
  Within the anonymous subroutine or block that is passed to
  C<FILTER>, process the contents of $_ to change the source code in
  the desired manner.
  
  =back
  
  In other words, the previous example, would become:
  
      package BANG;
      use Filter::Simple;
  
      FILTER {
          s/BANG\s+BANG/die 'BANG' if \$BANG/g;
      };
  
      1 ;
  
  Note that the source code is passed as a single string, so any regex that
  uses C<^> or C<$> to detect line boundaries will need the C</m> flag.
  
  =head2 Disabling or changing <no> behaviour
  
  By default, the installed filter only filters up to a line consisting of one of
  the three standard source "terminators":
  
      no ModuleName;  # optional comment
  
  or:
  
      __END__
  
  or:
  
      __DATA__
  
  but this can be altered by passing a second argument to C<use Filter::Simple>
  or C<FILTER> (just remember: there's I<no> comma after the initial block when
  you use C<FILTER>).
  
  That second argument may be either a C<qr>'d regular expression (which is then
  used to match the terminator line), or a defined false value (which indicates
  that no terminator line should be looked for), or a reference to a hash
  (in which case the terminator is the value associated with the key
  C<'terminator'>.
  
  For example, to cause the previous filter to filter only up to a line of the
  form:
  
      GNAB esu;
  
  you would write:
  
      package BANG;
      use Filter::Simple;
  
      FILTER {
          s/BANG\s+BANG/die 'BANG' if \$BANG/g;
      }
      qr/^\s*GNAB\s+esu\s*;\s*?$/;
  
  or:
  
      FILTER {
          s/BANG\s+BANG/die 'BANG' if \$BANG/g;
      }
      { terminator => qr/^\s*GNAB\s+esu\s*;\s*?$/ };
  
  and to prevent the filter's being turned off in any way:
  
      package BANG;
      use Filter::Simple;
  
      FILTER {
          s/BANG\s+BANG/die 'BANG' if \$BANG/g;
      }
      "";    # or: 0
  
  or:
  
      FILTER {
          s/BANG\s+BANG/die 'BANG' if \$BANG/g;
      }
      { terminator => "" };
  
  B<Note that, no matter what you set the terminator pattern to,
  the actual terminator itself I<must> be contained on a single source line.>
  
  
  =head2 All-in-one interface
  
  Separating the loading of Filter::Simple:
  
      use Filter::Simple;
  
  from the setting up of the filtering:
  
      FILTER { ... };
  
  is useful because it allows other code (typically parser support code
  or caching variables) to be defined before the filter is invoked.
  However, there is often no need for such a separation.
  
  In those cases, it is easier to just append the filtering subroutine and
  any terminator specification directly to the C<use> statement that loads
  Filter::Simple, like so:
  
      use Filter::Simple sub {
          s/BANG\s+BANG/die 'BANG' if \$BANG/g;
      };
  
  This is exactly the same as:
  
      use Filter::Simple;
      BEGIN {
          Filter::Simple::FILTER {
              s/BANG\s+BANG/die 'BANG' if \$BANG/g;
          };
      }
  
  except that the C<FILTER> subroutine is not exported by Filter::Simple.
  
  
  =head2 Filtering only specific components of source code
  
  One of the problems with a filter like:
  
      use Filter::Simple;
  
      FILTER { s/BANG\s+BANG/die 'BANG' if \$BANG/g };
  
  is that it indiscriminately applies the specified transformation to
  the entire text of your source program. So something like:
  
      warn 'BANG BANG, YOU'RE DEAD';
      BANG BANG;
  
  will become:
  
      warn 'die 'BANG' if $BANG, YOU'RE DEAD';
      die 'BANG' if $BANG;
  
  It is very common when filtering source to only want to apply the filter
  to the non-character-string parts of the code, or alternatively to I<only>
  the character strings.
  
  Filter::Simple supports this type of filtering by automatically
  exporting the C<FILTER_ONLY> subroutine.
  
  C<FILTER_ONLY> takes a sequence of specifiers that install separate
  (and possibly multiple) filters that act on only parts of the source code.
  For example:
  
      use Filter::Simple;
  
      FILTER_ONLY
          code      => sub { s/BANG\s+BANG/die 'BANG' if \$BANG/g },
          quotelike => sub { s/BANG\s+BANG/CHITTY CHITTY/g };
  
  The C<"code"> subroutine will only be used to filter parts of the source
  code that are not quotelikes, POD, or C<__DATA__>. The C<quotelike>
  subroutine only filters Perl quotelikes (including here documents).
  
  The full list of alternatives is:
  
  =over
  
  =item C<"code">
  
  Filters only those sections of the source code that are not quotelikes, POD, or
  C<__DATA__>.
  
  =item C<"code_no_comments">
  
  Filters only those sections of the source code that are not quotelikes, POD,
  comments, or C<__DATA__>.
  
  =item C<"executable">
  
  Filters only those sections of the source code that are not POD or C<__DATA__>.
  
  =item C<"executable_no_comments">
  
  Filters only those sections of the source code that are not POD, comments, or C<__DATA__>.
  
  =item C<"quotelike">
  
  Filters only Perl quotelikes (as interpreted by
  C<&Text::Balanced::extract_quotelike>).
  
  =item C<"string">
  
  Filters only the string literal parts of a Perl quotelike (i.e. the 
  contents of a string literal, either half of a C<tr///>, the second
  half of an C<s///>).
  
  =item C<"regex">
  
  Filters only the pattern literal parts of a Perl quotelike (i.e. the 
  contents of a C<qr//> or an C<m//>, the first half of an C<s///>).
  
  =item C<"all">
  
  Filters everything. Identical in effect to C<FILTER>.
  
  =back
  
  Except for C<< FILTER_ONLY code => sub {...} >>, each of
  the component filters is called repeatedly, once for each component
  found in the source code.
  
  Note that you can also apply two or more of the same type of filter in
  a single C<FILTER_ONLY>. For example, here's a simple 
  macro-preprocessor that is only applied within regexes,
  with a final debugging pass that prints the resulting source code:
  
      use Regexp::Common;
      FILTER_ONLY
          regex => sub { s/!\[/[^/g },
          regex => sub { s/%d/$RE{num}{int}/g },
          regex => sub { s/%f/$RE{num}{real}/g },
          all   => sub { print if $::DEBUG };
  
  
  
  =head2 Filtering only the code parts of source code
  
  Most source code ceases to be grammatically correct when it is broken up
  into the pieces between string literals and regexes. So the C<'code'>
  and C<'code_no_comments'> component filter behave slightly differently
  from the other partial filters described in the previous section.
  
  Rather than calling the specified processor on each individual piece of
  code (i.e. on the bits between quotelikes), the C<'code...'> partial
  filters operate on the entire source code, but with the quotelike bits
  (and, in the case of C<'code_no_comments'>, the comments) "blanked out".
  
  That is, a C<'code...'> filter I<replaces> each quoted string, quotelike,
  regex, POD, and __DATA__ section with a placeholder. The
  delimiters of this placeholder are the contents of the C<$;> variable
  at the time the filter is applied (normally C<"\034">). The remaining
  four bytes are a unique identifier for the component being replaced.
  
  This approach makes it comparatively easy to write code preprocessors
  without worrying about the form or contents of strings, regexes, etc.
  
  For convenience, during a C<'code...'> filtering operation, Filter::Simple
  provides a package variable (C<$Filter::Simple::placeholder>) that
  contains a pre-compiled regex that matches any placeholder...and
  captures the identifier within the placeholder. Placeholders can be
  moved and re-ordered within the source code as needed.
  
  In addition, a second package variable (C<@Filter::Simple::components>)
  contains a list of the various pieces of C<$_>, as they were originally split
  up to allow placeholders to be inserted.
  
  Once the filtering has been applied, the original strings, regexes, POD,
  etc. are re-inserted into the code, by replacing each placeholder with
  the corresponding original component (from C<@components>). Note that
  this means that the C<@components> variable must be treated with extreme
  care within the filter. The C<@components> array stores the "back-
  translations" of each placeholder inserted into C<$_>, as well as the
  interstitial source code between placeholders. If the placeholder
  backtranslations are altered in C<@components>, they will be similarly
  changed when the placeholders are removed from C<$_> after the filter
  is complete.
  
  For example, the following filter detects concatenated pairs of
  strings/quotelikes and reverses the order in which they are
  concatenated:
  
      package DemoRevCat;
      use Filter::Simple;
  
      FILTER_ONLY code => sub {
          my $ph = $Filter::Simple::placeholder;
          s{ ($ph) \s* [.] \s* ($ph) }{ $2.$1 }gx
      };
  
  Thus, the following code:
  
      use DemoRevCat;
  
      my $str = "abc" . q(def);
  
      print "$str\n";
  
  would become:
  
      my $str = q(def)."abc";
  
      print "$str\n";
  
  and hence print:
  
      defabc
  
  
  =head2 Using Filter::Simple with an explicit C<import> subroutine
  
  Filter::Simple generates a special C<import> subroutine for
  your module (see L<"How it works">) which would normally replace any
  C<import> subroutine you might have explicitly declared.
  
  However, Filter::Simple is smart enough to notice your existing
  C<import> and Do The Right Thing with it.
  That is, if you explicitly define an C<import> subroutine in a package
  that's using Filter::Simple, that C<import> subroutine will still
  be invoked immediately after any filter you install.
  
  The only thing you have to remember is that the C<import> subroutine
  I<must> be declared I<before> the filter is installed. If you use C<FILTER>
  to install the filter:
  
      package Filter::TurnItUpTo11;
  
      use Filter::Simple;
  
      FILTER { s/(\w+)/\U$1/ };
  
  that will almost never be a problem, but if you install a filtering
  subroutine by passing it directly to the C<use Filter::Simple>
  statement:
  
      package Filter::TurnItUpTo11;
  
      use Filter::Simple sub{ s/(\w+)/\U$1/ };
  
  then you must make sure that your C<import> subroutine appears before
  that C<use> statement.
  
  
  =head2 Using Filter::Simple and Exporter together
  
  Likewise, Filter::Simple is also smart enough
  to Do The Right Thing if you use Exporter:
  
      package Switch;
      use base Exporter;
      use Filter::Simple;
  
      @EXPORT    = qw(switch case);
      @EXPORT_OK = qw(given  when);
  
      FILTER { $_ = magic_Perl_filter($_) }
  
  Immediately after the filter has been applied to the source,
  Filter::Simple will pass control to Exporter, so it can do its magic too.
  
  Of course, here too, Filter::Simple has to know you're using Exporter
  before it applies the filter. That's almost never a problem, but if you're
  nervous about it, you can guarantee that things will work correctly by
  ensuring that your C<use base Exporter> always precedes your
  C<use Filter::Simple>.
  
  
  =head2 How it works
  
  The Filter::Simple module exports into the package that calls C<FILTER>
  (or C<use>s it directly) -- such as package "BANG" in the above example --
  two automagically constructed
  subroutines -- C<import> and C<unimport> -- which take care of all the
  nasty details.
  
  In addition, the generated C<import> subroutine passes its own argument
  list to the filtering subroutine, so the BANG.pm filter could easily 
  be made parametric:
  
      package BANG;
  
      use Filter::Simple;
  
      FILTER {
          my ($die_msg, $var_name) = @_;
          s/BANG\s+BANG/die '$die_msg' if \${$var_name}/g;
      };
  
      # and in some user code:
  
      use BANG "BOOM", "BAM";  # "BANG BANG" becomes: die 'BOOM' if $BAM
  
  
  The specified filtering subroutine is called every time a C<use BANG> is
  encountered, and passed all the source code following that call, up to
  either the next C<no BANG;> (or whatever terminator you've set) or the
  end of the source file, whichever occurs first. By default, any C<no
  BANG;> call must appear by itself on a separate line, or it is ignored.
  
  
  =head1 AUTHOR
  
  Damian Conway
  
  =head1 CONTACT
  
  Filter::Simple is now maintained by the Perl5-Porters.
  Please submit bug via the C<perlbug> tool that comes with your perl.
  For usage instructions, read C<perldoc perlbug> or possibly C<man perlbug>.
  For mostly anything else, please contact E<lt>perl5-porters@perl.orgE<gt>.
  
  Maintainer of the CPAN release is Steffen Mueller E<lt>smueller@cpan.orgE<gt>.
  Contact him with technical difficulties with respect to the packaging of the
  CPAN module.
  
  Praise of the module, flowers, and presents still go to the author,
  Damian Conway E<lt>damian@conway.orgE<gt>.
  
  =head1 COPYRIGHT AND LICENSE
  
      Copyright (c) 2000-2008, Damian Conway. All Rights Reserved.
      This module is free software. It may be used, redistributed
      and/or modified under the same terms as Perl itself.
FILTER_SIMPLE

$fatpacked{"Filter/Util/Call.pm"} = <<'FILTER_UTIL_CALL';
  
  # Call.pm
  #
  # Copyright (c) 1995-2011 Paul Marquess. All rights reserved.
  #
  # This program is free software; you can redistribute it and/or
  # modify it under the same terms as Perl itself.
   
  package Filter::Util::Call ;
  
  require 5.005 ;
  require DynaLoader;
  require Exporter;
  use Carp ;
  use strict;
  use warnings;
  use vars qw($VERSION @ISA @EXPORT) ;
  
  @ISA = qw(Exporter DynaLoader);
  @EXPORT = qw( filter_add filter_del filter_read filter_read_exact) ;
  $VERSION = "1.45" ;
  
  sub filter_read_exact($)
  {
      my ($size)   = @_ ;
      my ($left)   = $size ;
      my ($status) ;
  
      croak ("filter_read_exact: size parameter must be > 0")
  	unless $size > 0 ;
  
      # try to read a block which is exactly $size bytes long
      while ($left and ($status = filter_read($left)) > 0) {
          $left = $size - length $_ ;
      }
  
      # EOF with pending data is a special case
      return 1 if $status == 0 and length $_ ;
  
      return $status ;
  }
  
  sub filter_add($)
  {
      my($obj) = @_ ;
  
      # Did we get a code reference?
      my $coderef = (ref $obj eq 'CODE') ;
  
      # If the parameter isn't already a reference, make it one.
      $obj = \$obj unless ref $obj ;
  
      $obj = bless ($obj, (caller)[0]) unless $coderef ;
  
      # finish off the installation of the filter in C.
      Filter::Util::Call::real_import($obj, (caller)[0], $coderef) ;
  }
  
  bootstrap Filter::Util::Call ;
  
  1;
  __END__
  
  =head1 NAME
  
  Filter::Util::Call - Perl Source Filter Utility Module
  
  =head1 SYNOPSIS
  
      use Filter::Util::Call ;
  
  =head1 DESCRIPTION
  
  This module provides you with the framework to write I<Source Filters>
  in Perl. 
  
  An alternate interface to Filter::Util::Call is now available. See
  L<Filter::Simple> for more details.
  
  A I<Perl Source Filter> is implemented as a Perl module. The structure
  of the module can take one of two broadly similar formats. To
  distinguish between them, the first will be referred to as I<method
  filter> and the second as I<closure filter>.
  
  Here is a skeleton for the I<method filter>:
  
      package MyFilter ;
  
      use Filter::Util::Call ;
  
      sub import
      {
          my($type, @arguments) = @_ ;
          filter_add([]) ;
      }
  
      sub filter
      {
          my($self) = @_ ;
          my($status) ;
  
          $status = filter_read() ;
          $status ;
      }
  
      1 ;
  
  and this is the equivalent skeleton for the I<closure filter>:
  
      package MyFilter ;
  
      use Filter::Util::Call ;
  
      sub import
      {
          my($type, @arguments) = @_ ;
  
          filter_add(
              sub 
              {
                  my($status) ;
                  $status = filter_read() ;
                  $status ;
              } )
      }
  
      1 ;
  
  To make use of either of the two filter modules above, place the line
  below in a Perl source file.
  
      use MyFilter; 
  
  In fact, the skeleton modules shown above are fully functional I<Source
  Filters>, albeit fairly useless ones. All they does is filter the
  source stream without modifying it at all.
  
  As you can see both modules have a broadly similar structure. They both
  make use of the C<Filter::Util::Call> module and both have an C<import>
  method. The difference between them is that the I<method filter>
  requires a I<filter> method, whereas the I<closure filter> gets the
  equivalent of a I<filter> method with the anonymous sub passed to
  I<filter_add>.
  
  To make proper use of the I<closure filter> shown above you need to
  have a good understanding of the concept of a I<closure>. See
  L<perlref> for more details on the mechanics of I<closures>.
  
  =head2 B<use Filter::Util::Call>
  
  The following functions are exported by C<Filter::Util::Call>:
  
      filter_add()
      filter_read()
      filter_read_exact()
      filter_del()
  
  =head2 B<import()>
  
  The C<import> method is used to create an instance of the filter. It is
  called indirectly by Perl when it encounters the C<use MyFilter> line
  in a source file (See L<perlfunc/import> for more details on
  C<import>).
  
  It will always have at least one parameter automatically passed by Perl
  - this corresponds to the name of the package. In the example above it
  will be C<"MyFilter">.
  
  Apart from the first parameter, import can accept an optional list of
  parameters. These can be used to pass parameters to the filter. For
  example:
  
      use MyFilter qw(a b c) ;
  
  will result in the C<@_> array having the following values:
  
      @_ [0] => "MyFilter"
      @_ [1] => "a"
      @_ [2] => "b"
      @_ [3] => "c"
  
  Before terminating, the C<import> function must explicitly install the
  filter by calling C<filter_add>.
  
  B<filter_add()>
  
  The function, C<filter_add>, actually installs the filter. It takes one
  parameter which should be a reference. The kind of reference used will
  dictate which of the two filter types will be used.
  
  If a CODE reference is used then a I<closure filter> will be assumed.
  
  If a CODE reference is not used, a I<method filter> will be assumed.
  In a I<method filter>, the reference can be used to store context
  information. The reference will be I<blessed> into the package by
  C<filter_add>.
  
  See the filters at the end of this documents for examples of using
  context information using both I<method filters> and I<closure
  filters>.
  
  =head2 B<filter() and anonymous sub>
  
  Both the C<filter> method used with a I<method filter> and the
  anonymous sub used with a I<closure filter> is where the main
  processing for the filter is done.
  
  The big difference between the two types of filter is that the I<method
  filter> uses the object passed to the method to store any context data,
  whereas the I<closure filter> uses the lexical variables that are
  maintained by the closure.
  
  Note that the single parameter passed to the I<method filter>,
  C<$self>, is the same reference that was passed to C<filter_add>
  blessed into the filter's package. See the example filters later on for
  details of using C<$self>.
  
  Here is a list of the common features of the anonymous sub and the
  C<filter()> method.
  
  =over 5
  
  =item B<$_>
  
  Although C<$_> doesn't actually appear explicitly in the sample filters
  above, it is implicitly used in a number of places.
  
  Firstly, when either C<filter> or the anonymous sub are called, a local
  copy of C<$_> will automatically be created. It will always contain the
  empty string at this point.
  
  Next, both C<filter_read> and C<filter_read_exact> will append any
  source data that is read to the end of C<$_>.
  
  Finally, when C<filter> or the anonymous sub are finished processing,
  they are expected to return the filtered source using C<$_>.
  
  This implicit use of C<$_> greatly simplifies the filter.
  
  =item B<$status>
  
  The status value that is returned by the user's C<filter> method or
  anonymous sub and the C<filter_read> and C<read_exact> functions take
  the same set of values, namely:
  
      < 0  Error
      = 0  EOF
      > 0  OK
  
  =item B<filter_read> and B<filter_read_exact>
  
  These functions are used by the filter to obtain either a line or block
  from the next filter in the chain or the actual source file if there
  aren't any other filters.
  
  The function C<filter_read> takes two forms:
  
      $status = filter_read() ;
      $status = filter_read($size) ;
  
  The first form is used to request a I<line>, the second requests a
  I<block>.
  
  In line mode, C<filter_read> will append the next source line to the
  end of the C<$_> scalar.
  
  In block mode, C<filter_read> will append a block of data which is <=
  C<$size> to the end of the C<$_> scalar. It is important to emphasise
  the that C<filter_read> will not necessarily read a block which is
  I<precisely> C<$size> bytes.
  
  If you need to be able to read a block which has an exact size, you can
  use the function C<filter_read_exact>. It works identically to
  C<filter_read> in block mode, except it will try to read a block which
  is exactly C<$size> bytes in length. The only circumstances when it
  will not return a block which is C<$size> bytes long is on EOF or
  error.
  
  It is I<very> important to check the value of C<$status> after I<every>
  call to C<filter_read> or C<filter_read_exact>.
  
  =item B<filter_del>
  
  The function, C<filter_del>, is used to disable the current filter. It
  does not affect the running of the filter. All it does is tell Perl not
  to call filter any more.
  
  See L<Example 4: Using filter_del> for details.
  
  =back
  
  =head1 EXAMPLES
  
  Here are a few examples which illustrate the key concepts - as such
  most of them are of little practical use.
  
  The C<examples> sub-directory has copies of all these filters
  implemented both as I<method filters> and as I<closure filters>.
  
  =head2 Example 1: A simple filter.
  
  Below is a I<method filter> which is hard-wired to replace all
  occurrences of the string C<"Joe"> to C<"Jim">. Not particularly
  Useful, but it is the first example and I wanted to keep it simple.
  
      package Joe2Jim ;
  
      use Filter::Util::Call ;
  
      sub import
      {
          my($type) = @_ ;
  
          filter_add(bless []) ;
      }
  
      sub filter
      {
          my($self) = @_ ;
          my($status) ;
  
          s/Joe/Jim/g
              if ($status = filter_read()) > 0 ;
          $status ;
      }
  
      1 ;
  
  Here is an example of using the filter:
  
      use Joe2Jim ;
      print "Where is Joe?\n" ;
  
  And this is what the script above will print:
  
      Where is Jim?
  
  =head2 Example 2: Using the context
  
  The previous example was not particularly useful. To make it more
  general purpose we will make use of the context data and allow any
  arbitrary I<from> and I<to> strings to be used. This time we will use a
  I<closure filter>. To reflect its enhanced role, the filter is called
  C<Subst>.
  
      package Subst ;
  
      use Filter::Util::Call ;
      use Carp ;
  
      sub import
      {
          croak("usage: use Subst qw(from to)")
              unless @_ == 3 ;
          my ($self, $from, $to) = @_ ;
          filter_add(
              sub 
              {
                  my ($status) ;
                  s/$from/$to/
                      if ($status = filter_read()) > 0 ;
                  $status ;
              })
      }
      1 ;
  
  and is used like this:
  
      use Subst qw(Joe Jim) ;
      print "Where is Joe?\n" ;
  
  
  =head2 Example 3: Using the context within the filter
  
  Here is a filter which a variation of the C<Joe2Jim> filter. As well as
  substituting all occurrences of C<"Joe"> to C<"Jim"> it keeps a count
  of the number of substitutions made in the context object.
  
  Once EOF is detected (C<$status> is zero) the filter will insert an
  extra line into the source stream. When this extra line is executed it
  will print a count of the number of substitutions actually made.
  Note that C<$status> is set to C<1> in this case.
  
      package Count ;
  
      use Filter::Util::Call ;
  
      sub filter
      {
          my ($self) = @_ ;
          my ($status) ;
  
          if (($status = filter_read()) > 0 ) {
              s/Joe/Jim/g ;
  	    ++ $$self ;
          }
  	elsif ($$self >= 0) { # EOF
              $_ = "print q[Made ${$self} substitutions\n]" ;
              $status = 1 ;
  	    $$self = -1 ;
          }
  
          $status ;
      }
  
      sub import
      {
          my ($self) = @_ ;
          my ($count) = 0 ;
          filter_add(\$count) ;
      }
  
      1 ;
  
  Here is a script which uses it:
  
      use Count ;
      print "Hello Joe\n" ;
      print "Where is Joe\n" ;
  
  Outputs:
  
      Hello Jim
      Where is Jim
      Made 2 substitutions
  
  =head2 Example 4: Using filter_del
  
  Another variation on a theme. This time we will modify the C<Subst>
  filter to allow a starting and stopping pattern to be specified as well
  as the I<from> and I<to> patterns. If you know the I<vi> editor, it is
  the equivalent of this command:
  
      :/start/,/stop/s/from/to/
  
  When used as a filter we want to invoke it like this:
  
      use NewSubst qw(start stop from to) ;
  
  Here is the module.
  
      package NewSubst ;
  
      use Filter::Util::Call ;
      use Carp ;
  
      sub import
      {
          my ($self, $start, $stop, $from, $to) = @_ ;
          my ($found) = 0 ;
          croak("usage: use Subst qw(start stop from to)")
              unless @_ == 5 ;
  
          filter_add( 
              sub 
              {
                  my ($status) ;
  
                  if (($status = filter_read()) > 0) {
  
                      $found = 1
                          if $found == 0 and /$start/ ;
  
                      if ($found) {
                          s/$from/$to/ ;
                          filter_del() if /$stop/ ;
                      }
  
                  }
                  $status ;
              } )
  
      }
  
      1 ;
  
  =head1 Filter::Simple
  
  If you intend using the Filter::Call functionality, I would strongly
  recommend that you check out Damian Conway's excellent Filter::Simple
  module. Damian's module provides a much cleaner interface than
  Filter::Util::Call. Although it doesn't allow the fine control that
  Filter::Util::Call does, it should be adequate for the majority of
  applications. It's available at
  
     http://search.cpan.org/dist/Filter-Simple/
  
  =head1 AUTHOR
  
  Paul Marquess 
  
  =head1 DATE
  
  26th January 1996
  
  =cut
  
FILTER_UTIL_CALL

$fatpacked{"FindBin.pm"} = <<'FINDBIN';
  # FindBin.pm
  #
  # Copyright (c) 1995 Graham Barr & Nick Ing-Simmons. All rights reserved.
  # This program is free software; you can redistribute it and/or modify it
  # under the same terms as Perl itself.
  
  =head1 NAME
  
  FindBin - Locate directory of original perl script
  
  =head1 SYNOPSIS
  
   use FindBin;
   use lib "$FindBin::Bin/../lib";
  
   or
  
   use FindBin qw($Bin);
   use lib "$Bin/../lib";
  
  =head1 DESCRIPTION
  
  Locates the full path to the script bin directory to allow the use
  of paths relative to the bin directory.
  
  This allows a user to setup a directory tree for some software with
  directories C<< <root>/bin >> and C<< <root>/lib >>, and then the above
  example will allow the use of modules in the lib directory without knowing
  where the software tree is installed.
  
  If perl is invoked using the B<-e> option or the perl script is read from
  C<STDIN> then FindBin sets both C<$Bin> and C<$RealBin> to the current
  directory.
  
  =head1 EXPORTABLE VARIABLES
  
   $Bin         - path to bin directory from where script was invoked
   $Script      - basename of script from which perl was invoked
   $RealBin     - $Bin with all links resolved
   $RealScript  - $Script with all links resolved
  
  =head1 KNOWN ISSUES
  
  If there are two modules using C<FindBin> from different directories
  under the same interpreter, this won't work. Since C<FindBin> uses a
  C<BEGIN> block, it'll be executed only once, and only the first caller
  will get it right. This is a problem under mod_perl and other persistent
  Perl environments, where you shouldn't use this module. Which also means
  that you should avoid using C<FindBin> in modules that you plan to put
  on CPAN. To make sure that C<FindBin> will work is to call the C<again>
  function:
  
    use FindBin;
    FindBin::again(); # or FindBin->again;
  
  In former versions of FindBin there was no C<again> function. The
  workaround was to force the C<BEGIN> block to be executed again:
  
    delete $INC{'FindBin.pm'};
    require FindBin;
  
  =head1 AUTHORS
  
  FindBin is supported as part of the core perl distribution. Please send bug
  reports to E<lt>F<perlbug@perl.org>E<gt> using the perlbug program
  included with perl.
  
  Graham Barr E<lt>F<gbarr@pobox.com>E<gt>
  Nick Ing-Simmons E<lt>F<nik@tiuk.ti.com>E<gt>
  
  =head1 COPYRIGHT
  
  Copyright (c) 1995 Graham Barr & Nick Ing-Simmons. All rights reserved.
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  =cut
  
  package FindBin;
  use Carp;
  require 5.000;
  require Exporter;
  use Cwd qw(getcwd cwd abs_path);
  use File::Basename;
  use File::Spec;
  
  @EXPORT_OK = qw($Bin $Script $RealBin $RealScript $Dir $RealDir);
  %EXPORT_TAGS = (ALL => [qw($Bin $Script $RealBin $RealScript $Dir $RealDir)]);
  @ISA = qw(Exporter);
  
  $VERSION = "1.51";
  
  
  # needed for VMS-specific filename translation
  if( $^O eq 'VMS' ) {
      require VMS::Filespec;
      VMS::Filespec->import;
  }
  
  sub cwd2 {
     my $cwd = getcwd();
     # getcwd might fail if it hasn't access to the current directory.
     # try harder.
     defined $cwd or $cwd = cwd();
     $cwd;
  }
  
  sub init
  {
   *Dir = \$Bin;
   *RealDir = \$RealBin;
  
   if($0 eq '-e' || $0 eq '-')
    {
     # perl invoked with -e or script is on C<STDIN>
     $Script = $RealScript = $0;
     $Bin    = $RealBin    = cwd2();
     $Bin = VMS::Filespec::unixify($Bin) if $^O eq 'VMS';
    }
   else
    {
     my $script = $0;
  
     if ($^O eq 'VMS')
      {
       ($Bin,$Script) = VMS::Filespec::rmsexpand($0) =~ /(.*[\]>\/]+)(.*)/s;
       # C<use disk:[dev]/lib> isn't going to work, so unixify first
       ($Bin = VMS::Filespec::unixify($Bin)) =~ s/\/\z//;
       ($RealBin,$RealScript) = ($Bin,$Script);
      }
     else
      {
       croak("Cannot find current script '$0'") unless(-f $script);
  
       # Ensure $script contains the complete path in case we C<chdir>
  
       $script = File::Spec->catfile(cwd2(), $script)
         unless File::Spec->file_name_is_absolute($script);
  
       ($Script,$Bin) = fileparse($script);
  
       # Resolve $script if it is a link
       while(1)
        {
         my $linktext = readlink($script);
  
         ($RealScript,$RealBin) = fileparse($script);
         last unless defined $linktext;
  
         $script = (File::Spec->file_name_is_absolute($linktext))
                    ? $linktext
                    : File::Spec->catfile($RealBin, $linktext);
        }
  
       # Get absolute paths to directories
       if ($Bin) {
        my $BinOld = $Bin;
        $Bin = abs_path($Bin);
        defined $Bin or $Bin = File::Spec->canonpath($BinOld);
       }
       $RealBin = abs_path($RealBin) if($RealBin);
      }
    }
  }
  
  BEGIN { init }
  
  *again = \&init;
  
  1; # Keep require happy
FINDBIN

$fatpacked{"Path/Tiny.pm"} = <<'PATH_TINY';
  use 5.008001;
  use strict;
  use warnings;
  
  package Path::Tiny;
  # ABSTRACT: File path utility
  our $VERSION = '0.026'; # VERSION
  
  # Dependencies
  use autodie::exception 2.14; # autodie::skip support
  use Exporter 5.57   (qw/import/);
  use File::Spec 3.40 ();
  use Carp ();
  
  our @EXPORT    = qw/path/;
  our @EXPORT_OK = qw/cwd rootdir tempfile tempdir/;
  
  use constant {
      PATH  => 0,
      CANON => 1,
      VOL   => 2,
      DIR   => 3,
      FILE  => 4,
      TEMP  => 5,
  };
  
  use overload (
      q{""}    => sub    { $_[0]->[PATH] },
      bool     => sub () { 1 },
      fallback => 1,
  );
  
  my $TID = 0; # for thread safe atomic writes
  
  # if cloning, threads should already be loaded, but Win32 pseudoforks
  # don't do that so we have to be sure it's loaded anyway
  sub CLONE { require threads; threads->tid }
  
  sub DOES { return $_[1] eq 'autodie::skip' } # report errors like croak
  
  my $HAS_UU;                                  # has Unicode::UTF8; lazily populated
  
  sub _check_UU {
      eval { require Unicode::UTF8; Unicode::UTF8->VERSION(0.58); 1 };
  }
  
  # we do our own autodie::exceptions to avoid wrapping built-in functions
  sub _throw {
      my ( $function, $args ) = @_;
      die autodie::exception->new(
          function => "CORE::$function",
          args     => $args,
          errno    => $!,
          context  => 'scalar',
          return   => undef,
      );
  }
  
  # cheapo option validation
  sub _get_args {
      my ( $raw, @valid ) = @_;
      Carp::croak("Options for @{[_called_as()]} must be a hash reference")
        if defined($raw) && ref($raw) ne 'HASH';
      my $cooked = {};
      for my $k (@valid) {
          $cooked->{$k} = delete $raw->{$k} if exists $raw->{$k};
      }
      Carp::croak( "Invalid option(s) for @{[_called_as()]}: " . join( ", ", keys %$raw ) )
        if keys %$raw;
      return $cooked;
  }
  
  sub _called_as {
      my ( undef, undef, undef, $method ) = caller(2);
      $method =~ s{^.*::}{};
      return $method;
  }
  
  #--------------------------------------------------------------------------#
  # Constructors
  #--------------------------------------------------------------------------#
  
  
  sub path {
      my $path = shift;
      Carp::croak("path() requires a defined, positive-length argument")
        unless defined $path && length $path;
      # join stringifies any objects, too, which is handy :-)
      $path = join( "/", ( $path eq '/' ? "" : $path ), @_ ) if @_;
      my $cpath = $path = File::Spec->canonpath($path); # ugh, but probably worth it
      $path =~ tr[\\][/];                               # unix convention enforced
      if ( $path =~ m{^(~[^/]*).*} ) {                  # expand a tilde
          my ($homedir) = glob($1); # glob without list context == heisenbug!
          $path =~ s{^(~[^/]*)}{$homedir};
      }
      $path =~ s{/$}{} if $path ne "/"; # hack to make splitpath give us a basename
      bless [ $path, $cpath ], __PACKAGE__;
  }
  
  
  sub new { shift; path(@_) }
  
  
  sub cwd {
      require Cwd;
      return path( Cwd::getcwd() );
  }
  
  
  sub rootdir { path( File::Spec->rootdir ) }
  
  
  sub tempfile {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
      # File::Temp->new demands TEMPLATE
      $args->{TEMPLATE} = $maybe_template->[0] if @$maybe_template;
  
      require File::Temp;
      my $temp = File::Temp->new( TMPDIR => 1, %$args );
      close $temp;
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  sub tempdir {
      shift if $_[0] eq 'Path::Tiny'; # called as method
      my ( $maybe_template, $args ) = _parse_file_temp_args(@_);
  
      # File::Temp->newdir demands leading template
      require File::Temp;
      my $temp = File::Temp->newdir( @$maybe_template, TMPDIR => 1, %$args );
      my $self = path($temp)->absolute;
      $self->[TEMP] = $temp;          # keep object alive while we are
      return $self;
  }
  
  # normalize the various ways File::Temp does templates
  sub _parse_file_temp_args {
      my $leading_template = ( scalar(@_) % 2 == 1 ? shift(@_) : '' );
      my %args = @_;
      %args = map { uc($_), $args{$_} } keys %args;
      my @template = (
            exists $args{TEMPLATE} ? delete $args{TEMPLATE}
          : $leading_template      ? $leading_template
          :                          ()
      );
      return ( \@template, \%args );
  }
  
  #--------------------------------------------------------------------------#
  # Private methods
  #--------------------------------------------------------------------------#
  
  sub _splitpath {
      my ($self) = @_;
      @{$self}[ VOL, DIR, FILE ] = File::Spec->splitpath( $self->[PATH] );
  }
  
  #--------------------------------------------------------------------------#
  # Public methods
  #--------------------------------------------------------------------------#
  
  
  sub absolute {
      my ( $self, $base ) = @_;
      return $self if $self->is_absolute;
  
      require Cwd;
      return path( join "/", ( defined($base) ? $base : Cwd::getcwd() ), $_[0]->[PATH] );
  }
  
  
  sub append {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $fh = $self->filehandle( ">>", $binmode );
  
      require Fcntl;
      flock( $fh, Fcntl::LOCK_EX() ) or _throw( 'flock', [ $fh, Fcntl::LOCK_EX() ] );
  
      # Ensure we're at the end after the lock
      seek( $fh, 0, Fcntl::SEEK_END() ) or _throw( 'seek', [ $fh, 0, Fcntl::SEEK_END() ] );
  
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
  
      # For immediate flush
      close $fh or _throw( 'close', [$fh] );
  }
  
  sub append_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &append }
  
  sub append_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          append( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &append;
      }
  }
  
  
  sub basename {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[FILE];
      return $self->[FILE];
  }
  
  
  sub canonpath { $_[0]->[CANON] }
  
  
  sub child {
      my ( $self, @parts ) = @_;
      my $path = $self->[PATH];
      return path( join( "/", ( $path eq '/' ? "" : $path ), @parts ) );
  }
  
  
  # XXX take a match parameter?  qr or coderef?
  sub children {
      my ($self) = @_;
      my $dh;
      opendir $dh, $self->[PATH] or _throw( 'opendir', [ $dh, $self->[PATH] ] );
  
      return
        map { path( $self->[PATH] . "/$_" ) } grep { $_ ne '.' && $_ ne '..' } readdir $dh;
  }
  
  
  # XXX do recursively for directories?
  sub copy {
      my ( $self, $dest ) = @_;
      require File::Copy;
      File::Copy::copy( $self->[PATH], $dest )
        or Carp::croak("copy failed for $self to $dest: $!");
  }
  
  
  sub dirname {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[DIR];
      return length $self->[DIR] ? $self->[DIR] : ".";
  }
  
  
  sub exists { -e $_[0]->[PATH] }
  
  sub is_file { -f $_[0]->[PATH] }
  
  sub is_dir { -d $_[0]->[PATH] }
  
  
  # Note: must put binmode on open line, not subsequent binmode() call, so things
  # like ":unix" actually stop perlio/crlf from being added
  
  sub filehandle {
      my ( $self, $opentype, $binmode ) = @_;
      $opentype = "<" unless defined $opentype;
      $binmode  = ""  unless defined $binmode;
  
      my $mode = $opentype . $binmode;
      my $fh;
      open $fh, $mode, $self->[PATH] or _throw( 'open', [ $fh, $mode, $self->[PATH] ] );
  
      return $fh;
  }
  
  
  sub is_absolute { substr( $_[0]->dirname, 0, 1 ) eq '/' }
  
  sub is_relative { substr( $_[0]->dirname, 0, 1 ) ne '/' }
  
  
  sub iterator {
      my $self = shift;
      my $args = _get_args( shift, qw/recurse follow_symlinks/ );
      my @dirs = $self;
      my $current;
      return sub {
          my $next;
          while (@dirs) {
              if ( ref $dirs[0] eq 'Path::Tiny' ) {
                  $current = $dirs[0];
                  my $dh;
                  opendir( $dh, $current->[PATH] )
                    or _throw( 'opendir', [ $dh, $current->[PATH] ] );
                  $dirs[0] = $dh;
                  if ( -l $current->[PATH] && !$args->{follow_symlinks} ) {
                      # Symlink attack! It was a real dir, but is now a symlink!
                      # N.B. we check *after* opendir so the attacker has to win
                      # two races: replace dir with symlink before opendir and
                      # replace symlink with dir before -l check above
                      shift @dirs and next;
                  }
              }
              while ( defined( $next = readdir $dirs[0] ) ) {
                  next if $next eq '.' || $next eq '..';
                  my $path = $current->child($next);
                  push @dirs, $path
                    if $args->{recurse} && -d $path && !( !$args->{follow_symlinks} && -l $path );
                  return $path;
              }
              shift @dirs;
          }
          return;
      };
  }
  
  
  sub lines {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode chomp count/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( "<", $binmode );
      require Fcntl;
      flock( $fh, Fcntl::LOCK_SH() ) or _throw( 'flock', [ $fh, Fcntl::LOCK_SH() ] );
      my $chomp = $args->{chomp};
      # XXX more efficient to read @lines then chomp(@lines) vs map?
      if ( $args->{count} ) {
          my (@result, $counter);
          while ( my $line = <$fh> ) {
              chomp $line if $chomp;
              push @result, $line;
              last if ++$counter == $args->{count};
          }
          return @result;
      }
      elsif ($chomp) {
          return map { chomp; $_ } <$fh>;
      }
      else {
          return wantarray ? <$fh> : ( my $count =()= <$fh> );
      }
  }
  
  sub lines_raw {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if ( $args->{chomp} && !$args->{count} ) {
          return split /\n/, slurp_raw($self); ## no critic
      }
      else {
          $args->{binmode} = ":raw";
          return lines( $self, $args );
      }
  }
  
  sub lines_utf8 {
      my $self = shift;
      my $args = _get_args( shift, qw/binmode chomp count/ );
      if (   ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() )
          && $args->{chomp}
          && !$args->{count} )
      {
          return split /\n/, slurp_utf8($self); ## no critic
      }
      else {
          $args->{binmode} = ":raw:encoding(UTF-8)";
          return lines( $self, $args );
      }
  }
  
  
  sub mkpath {
      my ( $self, $args ) = @_;
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err} = \$err unless defined $args->{err};
      require File::Path;
      my @dirs = File::Path::make_path( $self->[PATH], $args );
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("mkpath failed for $file: $message");
      }
      return @dirs;
  }
  
  
  sub move {
      my ( $self, $dst ) = @_;
  
      return rename( $self->[PATH], $dst ) || _throw( 'rename', [ $self->[PATH], $dst ] );
  }
  
  
  my %opens = (
      opena  => ">>",
      openr  => "<",
      openw  => ">",
      openrw => "+<"
  );
  
  while ( my ( $k, $v ) = each %opens ) {
      no strict 'refs';
      # must check for lexical IO mode hint
      *{$k} = sub {
          my ( $self, $binmode ) = @_;
          $binmode = ( ( caller(0) )[10] || {} )->{ 'open' . substr( $v, -1, 1 ) }
            unless defined $binmode;
          $self->filehandle( $v, $binmode );
      };
      *{ $k . "_raw" }  = sub { $_[0]->filehandle( $v, ":raw" ) };
      *{ $k . "_utf8" } = sub { $_[0]->filehandle( $v, ":raw:encoding(UTF-8)" ) };
  }
  
  
  # XXX this is ugly and coverage is incomplete.  I think it's there for windows
  # so need to check coverage there and compare
  sub parent {
      my ( $self, $level ) = @_;
      $level = 1 unless defined $level && $level > 0;
      $self->_splitpath unless defined $self->[FILE];
      my $parent;
      if ( length $self->[FILE] ) {
          if ( $self->[FILE] eq '.' || $self->[FILE] =~ /\.\./ ) {
              $parent = path( $self->[PATH] . "/.." );
          }
          else {
              $parent = path( _non_empty( $self->[VOL] . $self->[DIR] ) );
          }
      }
      elsif ( length $self->[DIR] ) {
          if ( $self->[DIR] =~ /\.\./ ) {
              $parent = path( $self->[VOL] . $self->[DIR] . "/.." );
          }
          else {
              $parent = path("/") if $self->[DIR] eq "/";
              ( my $dir = $self->[DIR] ) =~ s{/[^\/]+/$}{/};
              $parent = path( $self->[VOL] . $dir );
          }
      }
      else {
          $parent = path( _non_empty( $self->[VOL] ) );
      }
      return $level == 1 ? $parent : $parent->parent( $level - 1 );
  }
  
  sub _non_empty {
      my ($string) = shift;
      return ( ( defined($string) && length($string) ) ? $string : "." );
  }
  
  
  sub realpath {
      require Cwd;
      return path( Cwd::realpath( $_[0]->[PATH] ) );
  }
  
  
  # Easy to get wrong, so wash it through File::Spec (sigh)
  sub relative { path( File::Spec->abs2rel( $_[0]->[PATH], $_[1] ) ) }
  
  
  sub remove {
      my $self = shift;
  
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
  
      return unlink $self->[PATH] || _throw( 'unlink', [ $self->[PATH] ] );
  }
  
  
  sub remove_tree {
      my ( $self, $args ) = @_;
      return 0 if !-e $self->[PATH] && !-l $self->[PATH];
      $args = {} unless ref $args eq 'HASH';
      my $err;
      $args->{err}  = \$err unless defined $args->{err};
      $args->{safe} = 1     unless defined $args->{safe};
      require File::Path;
      my $count = File::Path::remove_tree( $self->[PATH], $args );
  
      if ( $err && @$err ) {
          my ( $file, $message ) = %{ $err->[0] };
          Carp::croak("remove_tree failed for $file: $message");
      }
      return $count;
  }
  
  
  sub slurp {
      my $self    = shift;
      my $args    = _get_args( shift, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open<'} unless defined $binmode;
      my $fh = $self->filehandle( "<", $binmode );
      require Fcntl;
      flock( $fh, Fcntl::LOCK_SH() ) or _throw( 'flock', [ $fh, Fcntl::LOCK_SH() ] );
      if ( ( defined($binmode) ? $binmode : "" ) eq ":unix"
          and my $size = -s $fh )
      {
          my $buf;
          read $fh, $buf, $size; # File::Slurp in a nutshell
          return $buf;
      }
      else {
          local $/;
          return scalar <$fh>;
      }
  }
  
  sub slurp_raw { $_[1] = { binmode => ":unix" }; goto &slurp }
  
  sub slurp_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          return Unicode::UTF8::decode_utf8( slurp( $_[0], { binmode => ":unix" } ) );
      }
      else {
          $_[1] = { binmode => ":raw:encoding(UTF-8)" };
          goto &slurp;
      }
  }
  
  
  # XXX add "unsafe" option to disable flocking and atomic?  Check benchmarks on append() first.
  sub spew {
      my ( $self, @data ) = @_;
      my $args = ( @data && ref $data[0] eq 'HASH' ) ? shift @data : {};
      $args = _get_args( $args, qw/binmode/ );
      my $binmode = $args->{binmode};
      $binmode = ( ( caller(0) )[10] || {} )->{'open>'} unless defined $binmode;
      my $temp = path( $self->[PATH] . $TID . $$ );
      my $fh = $temp->filehandle( ">", $binmode );
      require Fcntl;
      flock( $fh, Fcntl::LOCK_EX() ) or _throw( 'flock', [ $fh, Fcntl::LOCK_EX() ] );
      seek( $fh, 0, Fcntl::SEEK_SET() ) or _throw( 'seek', [ $fh, 0, Fcntl::SEEK_SET() ] );
      truncate( $fh, 0 ) or _throw( 'truncate', [ $fh, 0 ] );
      print {$fh} map { ref eq 'ARRAY' ? @$_ : $_ } @data;
      flock( $fh, Fcntl::LOCK_UN() ) or _throw( 'flock', [ $fh, Fcntl::LOCK_UN() ] );
      close $fh or _throw( 'close', [$fh] );
  
      # spewing need to follow the link
      # and replace the destination instead
      my $resolved_path = $self->[PATH];
      $resolved_path = readlink $resolved_path while -l $resolved_path;
      return $temp->move($resolved_path);
  }
  
  sub spew_raw { splice @_, 1, 0, { binmode => ":unix" }; goto &spew }
  
  sub spew_utf8 {
      if ( defined($HAS_UU) ? $HAS_UU : $HAS_UU = _check_UU() ) {
          my $self = shift;
          spew( $self, { binmode => ":unix" }, map { Unicode::UTF8::encode_utf8($_) } @_ );
      }
      else {
          splice @_, 1, 0, { binmode => ":unix:encoding(UTF-8)" };
          goto &spew;
      }
  }
  
  
  # XXX break out individual stat() components as subs?
  sub stat {
      my $self = shift;
      require File::stat;
      return File::stat::stat( $self->[PATH] ) || _throw( 'stat', [ $self->[PATH] ] );
  }
  
  sub lstat {
      my $self = shift;
      require File::stat;
      return File::stat::lstat( $self->[PATH] ) || _throw( 'lstat', [ $self->[PATH] ] );
  }
  
  
  sub stringify { $_[0]->[PATH] }
  
  
  sub touch {
      my ( $self, $epoch ) = @_;
      if ( !-e $self->[PATH] ) {
          my $fh = $self->openw;
          close $fh or _throw( 'close', [$fh] );
      }
      $epoch = defined($epoch) ? $epoch : time();
      utime $epoch, $epoch, $self->[PATH]
        or _throw( 'utime', [ $epoch, $epoch, $self->[PATH] ] );
      return $self;
  }
  
  
  sub touchpath {
      my ($self) = @_;
      my $parent = $self->parent;
      $parent->mkpath unless $parent->exists;
      $self->touch;
  }
  
  
  sub volume {
      my ($self) = @_;
      $self->_splitpath unless defined $self->[VOL];
      return $self->[VOL];
  }
  
  1;
  
  
  # vim: ts=4 sts=4 sw=4 et:
  
  __END__
  
  =pod
  
  =encoding utf-8
  
  =head1 NAME
  
  Path::Tiny - File path utility
  
  =head1 VERSION
  
  version 0.026
  
  =head1 SYNOPSIS
  
    use Path::Tiny;
  
    # creating Path::Tiny objects
  
    $dir = path("/tmp");
    $foo = path("foo.txt");
  
    $subdir = $dir->child("foo");
    $bar = $subdir->child("bar.txt");
  
    # stringifies as cleaned up path
  
    $file = path("./foo.txt");
    print $file; # "foo.txt"
  
    # reading files
  
    $guts = $file->slurp;
    $guts = $file->slurp_utf8;
  
    @lines = $file->lines;
    @lines = $file->lines_utf8;
  
    $head = $file->lines( {count => 1} );
  
    # writing files
  
    $bar->spew( @data );
    $bar->spew_utf8( @data );
  
    # reading directories
  
    for ( $dir->children ) { ... }
  
    $iter = $dir->iterator;
    while ( my $next = $iter->() ) { ... }
  
  =head1 DESCRIPTION
  
  This module attempts to provide a small, fast utility for working with
  file paths.  It is friendlier to use than L<File::Spec> and provides
  easy access to functions from several other core file handling modules.
  
  It doesn't attempt to be as full-featured as L<IO::All> or L<Path::Class>,
  nor does it try to work for anything except Unix-like and Win32 platforms.
  Even then, it might break if you try something particularly obscure or
  tortuous.  (Quick!  What does this mean: C<< ///../../..//./././a//b/.././c/././ >>?
  And how does it differ on Win32?)
  
  All paths are forced to have Unix-style forward slashes.  Stringifying
  the object gives you back the path (after some clean up).
  
  File input/output methods C<flock> handles before reading or writing,
  as appropriate.
  
  The C<*_utf8> methods (C<slurp_utf8>, C<lines_utf8>, etc.) operate in raw
  mode without CRLF translation.  Installing L<Unicode::UTF8> 0.58 or later
  will speed up several of them and is highly recommended.
  
  It uses L<autodie> internally, so most failures will be thrown as exceptions.
  
  =head1 CONSTRUCTORS
  
  =head2 path
  
      $path = path("foo/bar");
      $path = path("/tmp", "file.txt"); # list
      $path = path(".");                # cwd
      $path = path("~user/file.txt");   # tilde processing
  
  Constructs a C<Path::Tiny> object.  It doesn't matter if you give a file or
  directory path.  It's still up to you to call directory-like methods only on
  directories and file-like methods only on files.  This function is exported
  automatically by default.
  
  The first argument must be defined and have non-zero length or an exception
  will be thrown.  This prevents subtle, dangerous errors with code like
  C<< path( maybe_undef() )->remove_tree >>.
  
  If the first component of the path is a tilde ('~') then the component will be
  replaced with the output of C<glob('~')>.  If the first component of the path
  is a tilde followed by a user name then the component will be replaced with
  output of C<glob('~username')>.  Behaviour for non-existent users depends on
  the output of C<glob> on the system.
  
  =head2 new
  
      $path = Path::Tiny->new("foo/bar");
  
  This is just like C<path>, but with method call overhead.  (Why would you
  do that?)
  
  =head2 cwd
  
      $path = Path::Tiny->cwd; # path( Cwd::getcwd )
      $path = cwd; # optional export
  
  Gives you the absolute path to the current directory as a C<Path::Tiny> object.
  This is slightly faster than C<< path(".")->absolute >>.
  
  C<cwd> may be exported on request and used as a function instead of as a
  method.
  
  =head2 rootdir
  
      $path = Path::Tiny->rootdir; # /
      $path = rootdir;             # optional export 
  
  Gives you C<< File::Spec->rootdir >> as a C<Path::Tiny> object if you're too
  picky for C<path("/")>.
  
  C<rootdir> may be exported on request and used as a function instead of as a
  method.
  
  =head2 tempfile, tempdir
  
      $temp = Path::Tiny->tempfile( @options );
      $temp = Path::Tiny->tempdir( @options );
      $temp = tempfile( @options ); # optional export
      $temp = tempdir( @options );  # optional export
  
  C<tempfile> passes the options to C<< File::Temp->new >> and returns a C<Path::Tiny>
  object with the file name.  The C<TMPDIR> option is enabled by default.
  
  The resulting C<File::Temp> object is cached. When the C<Path::Tiny> object is
  destroyed, the C<File::Temp> object will be as well.
  
  C<File::Temp> annoyingly requires you to specify a custom template in slightly
  different ways depending on which function or method you call, but
  C<Path::Tiny> lets you ignore that and can take either a leading template or a
  C<TEMPLATE> option and does the right thing.
  
      $temp = Path::Tiny->tempfile( "customXXXXXXXX" );             # ok
      $temp = Path::Tiny->tempfile( TEMPLATE => "customXXXXXXXX" ); # ok
  
  The tempfile path object will normalized to have an absolute path, even if
  created in a relative directory using C<DIR>.
  
  C<tempdir> is just like C<tempfile>, except it calls
  C<< File::Temp->newdir >> instead.
  
  Both C<tempfile> and C<tempdir> may be exported on request and used as
  functions instead of as methods.
  
  =head1 METHODS
  
  =head2 absolute
  
      $abs = path("foo/bar")->absolute;
      $abs = path("foo/bar")->absolute("/tmp");
  
  Returns a new C<Path::Tiny> object with an absolute path.  Unless
  an argument is given, the current directory is used as the absolute base path.
  The argument must be absolute or you won't get an absolute result.
  
  This will not resolve upward directories ("foo/../bar") unless C<canonpath>
  in L<File::Spec> would normally do so on your platform.  If you need them
  resolved, you must call the more expensive C<realpath> method instead.
  
  =head2 append, append_raw, append_utf8
  
      path("foo.txt")->append(@data);
      path("foo.txt")->append(\@data);
      path("foo.txt")->append({binmode => ":raw"}, @data);
      path("foo.txt")->append_raw(@data);
      path("foo.txt")->append_utf8(@data);
  
  Appends data to a file.  The file is locked with C<flock> prior to writing.  An
  optional hash reference may be used to pass options.  The only option is
  C<binmode>, which is passed to C<binmode()> on the handle used for writing.
  
  C<append_raw> is like C<append> with a C<binmode> of C<:unix> for fast,
  unbuffered, raw write.
  
  C<append_utf8> is like C<append> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  append will be done instead on the data encoded with C<Unicode::UTF8>.
  
  =head2 basename
  
      $name = path("foo/bar.txt")->basename; # bar.txt
  
  Returns the file portion or last directory portion of a path.
  
  =head2 canonpath
  
      $canonical = path("foo/bar")->canonpath; # foo\bar on Windows
  
  Returns a string with the canonical format of the path name for
  the platform.  In particular, this means directory separators
  will be C<\> on Windows.
  
  =head2 child
  
      $file = path("/tmp")->child("foo.txt"); # "/tmp/foo.txt"
      $file = path("/tmp")->child(@parts);
  
  Returns a new C<Path::Tiny> object relative to the original.  Works
  like C<catfile> or C<catdir> from File::Spec, but without caring about
  file or directories.
  
  =head2 children
  
      @paths = path("/tmp")->children;
  
  Returns a list of C<Path::Tiny> objects for all file and directories
  within a directory.  Excludes "." and ".." automatically.
  
  =head2 copy
  
      path("/tmp/foo.txt")->copy("/tmp/bar.txt");
  
  Copies a file using L<File::Copy>'s C<copy> function.
  
  =head2 dirname
  
      $name = path("/tmp/foo.txt")->dirname; # "/tmp/"
  
  Returns the directory name portion of the path.  This is roughly
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually has the trailing slash. If that's not desired, stringify directories
  or call C<parent> on files.
  
  =head2 exists, is_file, is_dir
  
      if ( path("/tmp")->exists ) { ... }
      if ( path("/tmp")->is_file ) { ... }
      if ( path("/tmp")->is_dir ) { ... }
  
  Just like C<-e>, C<-f> or C<-d>.  This means the file or directory actually has to
  exist on the filesystem.  Until then, it's just a path.
  
  =head2 filehandle
  
      $fh = path("/tmp/foo.txt")->filehandle($mode, $binmode);
  
  Returns an open file handle.  The C<$mode> argument must be a Perl-style
  read/write mode string ("<" ,">", "<<", etc.).  If a C<$binmode>
  is given, it is set during the C<open> call.
  
  See C<openr>, C<openw>, C<openrw>, and C<opena> for sugar.
  
  =head2 is_absolute, is_relative
  
      if ( path("/tmp")->is_absolute ) { ... }
      if ( path("/tmp")->is_relative ) { ... }
  
  Booleans for whether the path appears absolute or relative.
  
  =head2 iterator
  
      $iter = path("/tmp")->iterator( \%options );
  
  Returns a code reference that walks a directory lazily.  Each invocation
  returns a C<Path::Tiny> object or undef when the iterator is exhausted.
  
      $iter = path("/tmp")->iterator;
      while ( $path = $iter->() ) {
          ...
      }
  
  The current and parent directory entries ("." and "..") will not
  be included.
  
  If the C<recurse> option is true, the iterator will walk the directory
  recursively, breadth-first.  If the C<follow_symlinks> option is also true,
  directory links will be followed recursively.  There is no protection against
  loops when following links.
  
  For a more powerful, recursive iterator with built-in loop avoidance, see
  L<Path::Iterator::Rule>.
  
  =head2 lines, lines_raw, lines_utf8
  
      @contents = path("/tmp/foo.txt")->lines;
      @contents = path("/tmp/foo.txt")->lines(\%options);
      @contents = path("/tmp/foo.txt")->lines_raw;
      @contents = path("/tmp/foo.txt")->lines_utf8;
  
  Returns a list of lines from a file.  Optionally takes a hash-reference of
  options.  Valid options are C<binmode>, C<count> and C<chomp>.  If C<binmode>
  is provided, it will be set on the handle prior to reading.  If C<count> is
  provided, up to that many lines will be returned. If C<chomp> is set, lines
  will be chomped before being returned.
  
  Because the return is a list, C<lines> in scalar context will return the number
  of lines (and throw away the data).
  
      $number_of_lines = path("/tmp/foo.txt")->lines;
  
  C<lines_raw> is like C<lines> with a C<binmode> of C<:raw>.  We use C<:raw>
  instead of C<:unix> so PerlIO buffering can manage reading by line.
  
  C<lines_utf8> is like C<lines> with a C<binmode> of
  C<:raw:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  UTF-8 slurp will be done and then the lines will be split.  This is
  actually faster than relying on C<:encoding(UTF-8)>, though a bit memory
  intensive.  If memory use is a concern, consider C<openr_utf8> and
  iterating directly on the handle.
  
  =head2 mkpath
  
      path("foo/bar/baz")->mkpath;
      path("foo/bar/baz")->mkpath( \%options );
  
  Like calling C<make_path> from L<File::Path>.  An optional hash reference
  is passed through to C<make_path>.  Errors will be trapped and an exception
  thrown.  Returns the list of directories created or an empty list if
  the directories already exist, just like C<make_path>.
  
  =head2 move
  
      path("foo.txt")->move("bar.txt");
  
  Just like C<rename>.
  
  =head2 openr, openw, openrw, opena
  
      $fh = path("foo.txt")->openr($binmode);  # read
      $fh = path("foo.txt")->openr_raw;
      $fh = path("foo.txt")->openr_utf8;
  
      $fh = path("foo.txt")->openw($binmode);  # write
      $fh = path("foo.txt")->openw_raw;
      $fh = path("foo.txt")->openw_utf8;
  
      $fh = path("foo.txt")->opena($binmode);  # append
      $fh = path("foo.txt")->opena_raw;
      $fh = path("foo.txt")->opena_utf8;
  
      $fh = path("foo.txt")->openrw($binmode); # read/write
      $fh = path("foo.txt")->openrw_raw;
      $fh = path("foo.txt")->openrw_utf8;
  
  Returns a file handle opened in the specified mode.  The C<openr> style methods
  take a single C<binmode> argument.  All of the C<open*> methods have
  C<open*_raw> and C<open*_utf8> equivalents that use C<:raw> and
  C<:raw:encoding(UTF-8)>, respectively.
  
  =head2 parent
  
      $parent = path("foo/bar/baz")->parent; # foo/bar
      $parent = path("foo/wibble.txt")->parent; # foo
  
      $parent = path("foo/bar/baz")->parent(2); # foo
  
  Returns a C<Path::Tiny> object corresponding to the parent directory of the
  original directory or file. An optional positive integer argument is the number
  of parent directories upwards to return.  C<parent> by itself is equivalent to
  C<parent(1)>.
  
  =head2 realpath
  
      $real = path("/baz/foo/../bar")->realpath;
      $real = path("foo/../bar")->realpath;
  
  Returns a new C<Path::Tiny> object with all symbolic links and upward directory
  parts resolved using L<Cwd>'s C<realpath>.  Compared to C<absolute>, this is
  more expensive as it must actually consult the filesystem.
  
  =head2 relative
  
      $rel = path("/tmp/foo/bar")->relative("/tmp"); # foo/bar
  
  Returns a C<Path::Tiny> object with a relative path name.
  Given the trickiness of this, it's a thin wrapper around
  C<< File::Spec->abs2rel() >>.
  
  =head2 remove
  
      path("foo.txt")->remove;
  
  B<Note: as of 0.012, remove only works on files>.
  
  This is just like C<unlink>, except if the path does not exist, it returns
  false rather than throwing an exception.
  
  =head2 remove_tree
  
      # directory
      path("foo/bar/baz")->remove_tree;
      path("foo/bar/baz")->remove_tree( \%options );
      path("foo/bar/baz")->remove_tree( { safe => 0 } ); # force remove
  
  Like calling C<remove_tree> from L<File::Path>, but defaults to C<safe> mode.
  An optional hash reference is passed through to C<remove_tree>.  Errors will be
  trapped and an exception thrown.  Returns the number of directories deleted,
  just like C<remove_tree>.
  
  If you want to remove a directory only if it is empty, use the built-in
  C<rmdir> function instead.
  
      rmdir path("foo/bar/baz/");
  
  =head2 slurp, slurp_raw, slurp_utf8
  
      $data = path("foo.txt")->slurp;
      $data = path("foo.txt")->slurp( {binmode => ":raw"} );
      $data = path("foo.txt")->slurp_raw;
      $data = path("foo.txt")->slurp_utf8;
  
  Reads file contents into a scalar.  Takes an optional hash reference may be
  used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for reading.
  
  C<slurp_raw> is like C<slurp> with a C<binmode> of C<:unix> for
  a fast, unbuffered, raw read.
  
  C<slurp_utf8> is like C<slurp> with a C<binmode> of
  C<:unix:encoding(UTF-8)>.  If L<Unicode::UTF8> 0.58+ is installed, a raw
  slurp will be done instead and the result decoded with C<Unicode::UTF8>.
  This is just as strict and is roughly an order of magnitude faster than
  using C<:encoding(UTF-8)>.
  
  =head2 spew, spew_raw, spew_utf8
  
      path("foo.txt")->spew(@data);
      path("foo.txt")->spew(\@data);
      path("foo.txt")->spew({binmode => ":raw"}, @data);
      path("foo.txt")->spew_raw(@data);
      path("foo.txt")->spew_utf8(@data);
  
  Writes data to a file atomically.  The file is written to a temporary file in
  the same directory, then renamed over the original.  An optional hash reference
  may be used to pass options.  The only option is C<binmode>, which is passed to
  C<binmode()> on the handle used for writing.
  
  C<spew_raw> is like C<spew> with a C<binmode> of C<:unix> for a fast,
  unbuffered, raw write.
  
  C<spew_utf8> is like C<spew> with a C<binmode> of C<:unix:encoding(UTF-8)>.
  If L<Unicode::UTF8> 0.58+ is installed, a raw spew will be done instead on
  the data encoded with C<Unicode::UTF8>.
  
  =head2 stat, lstat
  
      $stat = path("foo.txt")->stat;
      $stat = path("/some/symlink")->lstat;
  
  Like calling C<stat> or C<lstat> from L<File::stat>.
  
  =head2 stringify
  
      $path = path("foo.txt");
      say $path->stringify; # same as "$path"
  
  Returns a string representation of the path.  Unlike C<canonpath>, this method
  returns the path standardized with Unix-style C</> directory separators.
  
  =head2 touch
  
      path("foo.txt")->touch;
      path("foo.txt")->touch($epoch_secs);
  
  Like the Unix C<touch> utility.  Creates the file if it doesn't exist, or else
  changes the modification and access times to the current time.  If the first
  argument is the epoch seconds then it will be used.
  
  Returns the path object so it can be easily chained with spew:
  
      path("foo.txt")->touch->spew( $content );
  
  =head2 touchpath
  
      path("bar/baz/foo.txt")->touchpath;
  
  Combines C<mkpath> and C<touch>.  Creates the parent directory if it doesn't exist,
  before touching the file.  Returns the path object like C<touch> does.
  
  =head2 volume
  
      $vol = path("/tmp/foo.txt")->volume;
  
  Returns the volume portion of the path.  This is equivalent
  equivalent to what L<File::Spec> would give from C<splitpath> and thus
  usually is the empty string on Unix-like operating systems.
  
  =for Pod::Coverage openr_utf8 opena_utf8 openw_utf8 openrw_utf8
  openr_raw opena_raw openw_raw openrw_raw
  DOES
  
  =head1 CAVEATS
  
  =head2 utf8 vs UTF-8
  
  All the C<*_utf8> methods use C<:encoding(UTF-8)> -- either as
  C<:unix:encoding(UTF-8)> (unbuffered) or C<:raw:encoding(UTF-8)> (buffered) --
  which is strict against the Unicode spec and disallows illegal Unicode
  codepoints or UTF-8 sequences.
  
  Unfortunately, C<:encoding(UTF-8)> is very, very slow.  If you install
  L<Unicode::UTF8> 0.58 or later, that module will be used by some C<*_utf8>
  methods to encode or decode data after a raw, binary input/output operation,
  which is much faster.
  
  If you need the performance and can accept the security risk,
  C<< slurp({binmode => ":unix:utf8"}) >> will be faster than C<:unix:encoding(UTF-8)>
  (but not as fast as C<Unicode::UTF8>).
  
  Note that the C<*_utf8> methods read in B<raw> mode.  There is no CRLF
  translation on Windows.  If you must have CRLF translation, use the regular
  input/output methods with an appropriate binmode:
  
    $path->spew_utf8($data);                            # raw
    $path->spew({binmode => ":encoding(UTF-8)"}, $data; # LF -> CRLF
  
  Consider L<PerlIO::utf8_strict> for a faster L<PerlIO> layer alternative to
  C<:encoding(UTF-8)>, though it does not appear to be as fast as the
  C<Unicode::UTF8> approach.
  
  =head2 Default IO layers and the open pragma
  
  If you have Perl 5.10 or later, file input/output methods (C<slurp>, C<spew>,
  etc.) and high-level handle opening methods ( C<openr>, C<openw>, etc. but not
  C<filehandle>) respect default encodings set by the C<-C> switch or lexical
  L<open> settings of the caller.  For UTF-8, this is almost certainly slower
  than using the dedicated C<_utf8> methods if you have L<Unicode::UTF8>.
  
  =head1 TYPE CONSTRAINTS AND COERCION
  
  A standard L<MooseX::Types> library is available at
  L<MooseX::Types::Path::Tiny>.
  
  =head1 SEE ALSO
  
  These are other file/path utilities, which may offer a different feature
  set than C<Path::Tiny>.
  
  * L<File::Fu>
  * L<IO::All>
  * L<Path::Class>
  
  These iterators may be slightly faster than the recursive iterator in
  C<Path::Tiny>:
  
  * L<Path::Iterator::Rule>
  * L<File::Next>
  
  There are probably comparable, non-Tiny tools.  Let me know if you want me to
  add a module to the list.
  
  =for :stopwords cpan testmatrix url annocpan anno bugtracker rt cpants kwalitee diff irc mailto metadata placeholders metacpan
  
  =head1 SUPPORT
  
  =head2 Bugs / Feature Requests
  
  Please report any bugs or feature requests through the issue tracker
  at L<https://github.com/dagolden/path-tiny/issues>.
  You will be notified automatically of any progress on your issue.
  
  =head2 Source Code
  
  This is open source software.  The code repository is available for
  public review and contribution under the terms of the license.
  
  L<https://github.com/dagolden/path-tiny>
  
    git clone git://github.com/dagolden/path-tiny.git
  
  =head1 AUTHOR
  
  David Golden <dagolden@cpan.org>
  
  =head1 CONTRIBUTORS
  
  =over 4
  
  =item *
  
  Chris Williams <bingos@cpan.org>
  
  =item *
  
  David Steinbrunner <dsteinbrunner@pobox.com>
  
  =item *
  
  George Hartzell <hartzell@cpan.org>
  
  =item *
  
  Goro Fuji <gfuji@cpan.org>
  
  =item *
  
  Karen Etheridge <ether@cpan.org>
  
  =item *
  
  Keedi Kim <keedi@cpan.org>
  
  =item *
  
  Michael G. Schwern <mschwern@cpan.org>
  
  =back
  
  =head1 COPYRIGHT AND LICENSE
  
  This software is Copyright (c) 2013 by David Golden.
  
  This is free software, licensed under:
  
    The Apache License, Version 2.0, January 2004
  
  =cut
PATH_TINY

$fatpacked{"Test/YAML.pm"} = <<'TEST_YAML';
  package Test::YAML;
  
  use Test::Base 0.47 -Base;
  use lib 'lib';
  
  our $VERSION = '0.84';
  
  our $YAML    = 'YAML';
  our @EXPORT  = qw(
      no_diff
      run_yaml_tests
      run_roundtrip_nyn roundtrip_nyn
      run_load_passes load_passes
      dumper Load Dump LoadFile DumpFile
      XXX
  );
  
  delimiters('===', '+++');
  
  sub Dump     () { YAML(Dump => @_)     }
  sub Load     () { YAML(Load => @_)     }
  sub DumpFile () { YAML(DumpFile => @_) }
  sub LoadFile () { YAML(LoadFile => @_) }
  
  sub YAML () {
      load_yaml_pm();
      my $meth = shift;
      my $code = $YAML->can($meth) or die "$YAML cannot do $meth";
      goto &$code;
  }
  
  sub load_yaml_pm {
      my $file = "$YAML.pm";
      $file =~ s{::}{/}g;
      require $file;
  }
  
  sub run_yaml_tests() {
      run {
          my $block = shift;
          &{_get_function($block)}($block) unless 
            _skip_tests_for_now($block) or
            _skip_yaml_tests($block);
      };
  }
  
  sub run_roundtrip_nyn() {
      my @options = @_;
      run {
          my $block = shift;
          roundtrip_nyn($block, @options);
      };
  }
  
  sub roundtrip_nyn() {
      my $block = shift;
      my $option = shift || '';
      die "'perl' data section required"
          unless exists $block->{perl};
      my @values = eval $block->perl;
      die "roundtrip_nyn eval perl error: $@" if $@;
      my $config = $block->config || '';
      my $result = eval "$config; Dump(\@values)";
      die "roundtrip_nyn YAML::Dump error: $@" if $@;
      if (exists $block->{yaml}) {
          is $result, $block->yaml,
              $block->description . ' (n->y)';
      }
      else {
          pass $block->description . ' (n->y)';
      }
          
      return if exists $block->{no_round_trip} or
          not exists $block->{yaml};
  
      if ($option eq 'dumper') {
          is dumper(Load($block->yaml)), dumper(@values),
              $block->description . ' (y->n)';
      }
      else {
          is_deeply [Load($block->yaml)], [@values],
              $block->description . ' (y->n)';
      }
  }
  
  sub count_roundtrip_nyn() {
      my $block = shift or die "Bad call to count_roundtrip_nyn";
      return 1 if exists $block->{skip_this_for_now};
      my $count = 0;
      $count++ if exists $block->{perl};
      $count++ unless exists $block->{no_round_trip} or
          not exists $block->{yaml};
      die "Invalid test definition" unless $count;
      return $count;
  }
  
  sub run_load_passes() {
      run {
          my $block = shift;
          my $yaml = $block->yaml;
          eval { YAML(Load => $yaml) };
          is("$@", "");
      };
  }
  
  sub load_passes() {
      my $block = shift;
      my $yaml = $block->yaml;
      eval { YAML(Load => $yaml) };
      is "$@", "", $block->description;
  }
  
  sub count_load_passes() {1}
  
  sub dumper() {
      require Data::Dumper;
      $Data::Dumper::Sortkeys = 1;
      $Data::Dumper::Terse = 1;
      $Data::Dumper::Indent = 1;
      return Data::Dumper::Dumper(@_);
  }
  
  sub _count_tests() {
      my $block = shift or die "Bad call to _count_tests";
      no strict 'refs';
      &{'count_' . _get_function_name($block)}($block);
  }
  
  sub _get_function_name() {
      my $block = shift;
      return $block->function || 'roundtrip_nyn';
  }
  
  sub _get_function() {
      my $block = shift;
      no strict 'refs';
      \ &{_get_function_name($block)};
  }
  
  sub _skip_tests_for_now() {
      my $block = shift;
      if (exists $block->{skip_this_for_now}) {
          _skip_test(
              $block->description,
              _count_tests($block),
          );
          return 1;
      }
      return 0;
  }
  
  sub _skip_yaml_tests() {
      my $block = shift;
      if ($block->skip_unless_modules) {
          my @modules = split /[\s\,]+/, $block->skip_unless_modules;
          for my $module (@modules) {
              eval "require $module";
              if ($@) {
                  _skip_test(
                      "This test requires the '$module' module",
                      _count_tests($block),
                  );
                  return 1;
              }
          }
      }
      return 0;
  }
  
  sub _skip_test() {
      my ($message, $count) = @_;
      SKIP: {
          skip($message, $count);
      }
  }
  
  #-------------------------------------------------------------------------------
  package Test::YAML::Filter;
  
  use Test::Base::Filter ();
  
  our @ISA = 'Test::Base::Filter';
  
  sub yaml_dump {
      Test::YAML::Dump(@_);
  }
  
  sub yaml_load {
      Test::YAML::Load(@_);
  }
  
  sub Dump { goto &Test::YAML::Dump }
  sub Load { goto &Test::YAML::Load }
  sub DumpFile { goto &Test::YAML::DumpFile }
  sub LoadFile { goto &Test::YAML::LoadFile }
  
  sub yaml_load_or_fail {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $result;
  }
  
  sub yaml_load_error_or_warning {
      my ($result, $error, $warning) =
        $self->_yaml_load_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub perl_eval_error_or_warning {
      my ($result, $error, $warning) =
        $self->_perl_eval_result_error_warning(@_);
      return $error || $warning || '';
  }
  
  sub _yaml_load_result_error_warning {
      $self->assert_scalar(@_);
      my $yaml = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval {
          $self->yaml_load($yaml);
      };
      return ($result, $@, $warning);
  }
  
  sub _perl_eval_result_error_warning {
      $self->assert_scalar(@_);
      my $perl = shift;
      my $warning = '';
      local $SIG{__WARN__} = sub { $warning = join '', @_ };
      my $result = eval $perl;
      return ($result, $@, $warning);
  }
  
  1;
  
  =head1 NAME
  
  Test::YAML - Testing Module for YAML Implementations
  
  =head1 SYNOPSIS
  
      use Test::YAML tests => 1;
  
      pass;
  
  =head1 DESCRIPTION
  
  Test::YAML is a subclass of Test::Base with YAML specific support.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
TEST_YAML

$fatpacked{"YAML.pm"} = <<'YAML';
  use 5.008001;
  package YAML;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use Exporter;
  push @YAML::ISA, 'Exporter';
  our @EXPORT = qw{ Dump Load };
  our @EXPORT_OK = qw{ freeze thaw DumpFile LoadFile Bless Blessed };
  
  use YAML::Node; # XXX This is a temp fix for Module::Build
  
  # XXX This VALUE nonsense needs to go.
  use constant VALUE => "\x07YAML\x07VALUE\x07";
  
  # YAML Object Properties
  has dumper_class => default => sub {'YAML::Dumper'};
  has loader_class => default => sub {'YAML::Loader'};
  has dumper_object => default => sub {$_[0]->init_action_object("dumper")};
  has loader_object => default => sub {$_[0]->init_action_object("loader")};
  
  sub Dump {
      my $yaml = YAML->new;
      $yaml->dumper_class($YAML::DumperClass)
          if $YAML::DumperClass;
      return $yaml->dumper_object->dump(@_);
  }
  
  sub Load {
      my $yaml = YAML->new;
      $yaml->loader_class($YAML::LoaderClass)
          if $YAML::LoaderClass;
      return $yaml->loader_object->load(@_);
  }
  
  {
      no warnings 'once';
      # freeze/thaw is the API for Storable string serialization. Some
      # modules make use of serializing packages on if they use freeze/thaw.
      *freeze = \ &Dump;
      *thaw   = \ &Load;
  }
  
  sub DumpFile {
      my $OUT;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $OUT = $filename;
      }
      else {
          my $mode = '>';
          if ($filename =~ /^\s*(>{1,2})\s*(.*)$/) {
              ($mode, $filename) = ($1, $2);
          }
          open $OUT, $mode, $filename
            or YAML::Mo::Object->die('YAML_DUMP_ERR_FILE_OUTPUT', $filename, $!);
      }
      binmode $OUT, ':utf8';  # if $Config{useperlio} eq 'define';
      local $/ = "\n"; # reset special to "sane"
      print $OUT Dump(@_);
  }
  
  sub LoadFile {
      my $IN;
      my $filename = shift;
      if (ref $filename eq 'GLOB') {
          $IN = $filename;
      }
      else {
          open $IN, '<', $filename
            or YAML::Mo::Object->die('YAML_LOAD_ERR_FILE_INPUT', $filename, $!);
      }
      binmode $IN, ':utf8';  # if $Config{useperlio} eq 'define';
      return Load(do { local $/; <$IN> });
  }
  
  sub init_action_object {
      my $self = shift;
      my $object_class = (shift) . '_class';
      my $module_name = $self->$object_class;
      eval "require $module_name";
      $self->die("Error in require $module_name - $@")
          if $@ and "$@" !~ /Can't locate/;
      my $object = $self->$object_class->new;
      $object->set_global_options;
      return $object;
  }
  
  my $global = {};
  sub Bless {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::bless($global, @_)
  }
  sub Blessed {
      require YAML::Dumper::Base;
      YAML::Dumper::Base::blessed($global, @_)
  }
  sub global_object { $global }
  
  1;
  
  __END__
  
  =encoding utf8
  
  =head1 NAME
  
  YAML - YAML Ain't Markup Language (tm)
  
  =head1 NOTE
  
  This module has been released to CPAN as YAML::Old, and soon YAML.pm
  will be changed to just be a frontend interface module for all the
  various Perl YAML implementation modules, including YAML::Old.
  
  If you want robust and fast YAML processing using the normal Dump/Load
  API, please consider switching to YAML::XS. It is by far the best Perl
  module for YAML at this time. It requires that you have a C compiler,
  since it is written in C.
  
  If you really need to use this version of YAML.pm it will always be
  available as YAML::Old.
  
  If you don't care which YAML module use, as long as it's the best one
  installed on your system, use YAML::Any.
  
  The rest of this documentation is left unchanged, until YAML.pm is
  switched over to the new UI-only version.
  
  =head1 SYNOPSIS
  
      use YAML;
      
      # Load a YAML stream of 3 YAML documents into Perl data structures.
      my ($hashref, $arrayref, $string) = Load(<<'...');
      ---
      name: ingy
      age: old
      weight: heavy
      # I should comment that I also like pink, but don't tell anybody.
      favorite colors:
          - red
          - green
          - blue
      ---
      - Clark Evans
      - Oren Ben-Kiki
      - Ingy dt Net
      --- >
      You probably think YAML stands for "Yet Another Markup Language". It
      ain't! YAML is really a data serialization language. But if you want
      to think of it as a markup, that's OK with me. A lot of people try
      to use XML as a serialization format.
      
      "YAML" is catchy and fun to say. Try it. "YAML, YAML, YAML!!!"
      ...
      
      # Dump the Perl data structures back into YAML.
      print Dump($string, $arrayref, $hashref);
      
      # YAML::Dump is used the same way you'd use Data::Dumper::Dumper
      use Data::Dumper;
      print Dumper($string, $arrayref, $hashref);
  
  =head1 DESCRIPTION
  
  The YAML.pm module implements a YAML Loader and Dumper based on the YAML
  1.0 specification. L<http://www.yaml.org/spec/>
  
  YAML is a generic data serialization language that is optimized for
  human readability. It can be used to express the data structures of most
  modern programming languages. (Including Perl!!!)
  
  For information on the YAML syntax, please refer to the YAML
  specification.
  
  =head1 WHY YAML IS COOL
  
  =over 4
  
  =item YAML is readable for people.
  
  It makes clear sense out of complex data structures. You should find
  that YAML is an exceptional data dumping tool. Structure is shown
  through indentation, YAML supports recursive data, and hash keys are
  sorted by default. In addition, YAML supports several styles of scalar
  formatting for different types of data.
  
  =item YAML is editable.
  
  YAML was designed from the ground up to be an excellent syntax for
  configuration files. Almost all programs need configuration files, so
  why invent a new syntax for each one? And why subject users to the
  complexities of XML or native Perl code?
  
  =item YAML is multilingual.
  
  Yes, YAML supports Unicode. But I'm actually referring to programming
  languages. YAML was designed to meet the serialization needs of Perl,
  Python, Ruby, Tcl, PHP, Javascript and Java. It was also designed to be
  interoperable between those languages. That means YAML serializations
  produced by Perl can be processed by Python.
  
  =item YAML is taint safe.
  
  Using modules like Data::Dumper for serialization is fine as long as you
  can be sure that nobody can tamper with your data files or
  transmissions. That's because you need to use Perl's C<eval()> built-in
  to deserialize the data. Somebody could add a snippet of Perl to erase
  your files.
  
  YAML's parser does not need to eval anything.
  
  =item YAML is full featured.
  
  YAML can accurately serialize all of the common Perl data structures and
  deserialize them again without losing data relationships. Although it is
  not 100% perfect (no serializer is or can be perfect), it fares as well
  as the popular current modules: Data::Dumper, Storable, XML::Dumper and
  Data::Denter.
  
  YAML.pm also has the ability to handle code (subroutine) references and
  typeglobs. (Still experimental) These features are not found in Perl's
  other serialization modules.
  
  =item YAML is extensible.
  
  The YAML language has been designed to be flexible enough to solve it's
  own problems. The markup itself has 3 basic construct which resemble
  Perl's hash, array and scalar. By default, these map to their Perl
  equivalents. But each YAML node also supports a tagging mechanism (type
  system) which can cause that node to be interpreted in a completely
  different manner. That's how YAML can support object serialization and
  oddball structures like Perl's typeglob.
  
  =back
  
  =head1 YAML IMPLEMENTATIONS IN PERL
  
  This module, YAML.pm, is really just the interface module for YAML
  modules written in Perl. The basic interface for YAML consists of two
  functions: C<Dump> and C<Load>. The real work is done by the modules
  YAML::Dumper and YAML::Loader.
  
  Different YAML module distributions can be created by subclassing
  YAML.pm and YAML::Loader and YAML::Dumper. For example, YAML-Simple
  consists of YAML::Simple YAML::Dumper::Simple and YAML::Loader::Simple.
  
  Why would there be more than one implementation of YAML? Well, despite
  YAML's offering of being a simple data format, YAML is actually very
  deep and complex. Implementing the entirety of the YAML specification is
  a daunting task.
  
  For this reason I am currently working on 3 different YAML implementations.
  
  =over
  
  =item YAML
  
  The main YAML distribution will keeping evolving to support the entire
  YAML specification in pure Perl. This may not be the fastest or most
  stable module though. Currently, YAML.pm has lots of known bugs. It is
  mostly a great tool for dumping Perl data structures to a readable form.
  
  =item YAML::Tiny
  
  The point of YAML::Tiny is to strip YAML down to the 90% that people
  use most and offer that in a small, fast, stable, pure Perl form.
  YAML::Tiny will simply die when it is asked to do something it can't.
  
  =item YAML::Syck
  
  C<libsyck> is the C based YAML processing library used by the Ruby
  programming language (and also Python, PHP and Pugs). YAML::Syck is the
  Perl binding to C<libsyck>. It should be very fast, but may have
  problems of its own. It will also require C compilation.
  
  NOTE: Audrey Tang has actually completed this module and it works great
        and is 10 times faster than YAML.pm.
  
  =back
  
  In the future, there will likely be even more YAML modules. Remember,
  people other than Ingy are allowed to write YAML modules!
  
  =head1 FUNCTIONAL USAGE
  
  YAML is completely OO under the hood. Still it exports a few useful top
  level functions so that it is dead simple to use. These functions just
  do the OO stuff for you. If you want direct access to the OO API see the
  documentation for YAML::Dumper and YAML::Loader.
  
  =head2 Exported Functions
  
  The following functions are exported by YAML.pm by default. The reason
  they are exported is so that YAML works much like Data::Dumper. If you
  don't want functions to be imported, just use YAML with an empty
  import list:
  
      use YAML ();
  
  =over 4
  
  =item Dump(list-of-Perl-data-structures)
  
  Turn Perl data into YAML. This function works very much like
  Data::Dumper::Dumper(). It takes a list of Perl data strucures and
  dumps them into a serialized form. It returns a string containing the
  YAML stream. The structures can be references or plain scalars.
  
  =item Load(string-containing-a-YAML-stream)
  
  Turn YAML into Perl data. This is the opposite of Dump. Just like
  Storable's thaw() function or the eval() function in relation to
  Data::Dumper. It parses a string containing a valid YAML stream into a
  list of Perl data structures.
  
  =back
  
  =head2 Exportable Functions
  
  These functions are not exported by default but you can request them in
  an import list like this:
  
      use YAML qw'freeze thaw Bless';
  
  =over 4
  
  =item freeze() and thaw()
  
  Aliases to Dump() and Load() for Storable fans. This will also allow
  YAML.pm to be plugged directly into modules like POE.pm, that use the
  freeze/thaw API for internal serialization.
  
  =item DumpFile(filepath, list)
  
  Writes the YAML stream to a file instead of just returning a string.
  
  =item LoadFile(filepath)
  
  Reads the YAML stream from a file instead of a string.
  
  =item Bless(perl-node, [yaml-node | class-name])
  
  Associate a normal Perl node, with a yaml node. A yaml node is an object
  tied to the YAML::Node class. The second argument is either a yaml node
  that you've already created or a class (package) name that supports a
  yaml_dump() function. A yaml_dump() function should take a perl node and
  return a yaml node. If no second argument is provided, Bless will create
  a yaml node. This node is not returned, but can be retrieved with the
  Blessed() function.
  
  Here's an example of how to use Bless. Say you have a hash containing
  three keys, but you only want to dump two of them. Furthermore the keys
  must be dumped in a certain order. Here's how you do that:
  
      use YAML qw(Dump Bless);
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash)->keys(['banana', 'apple']);
      print Dump $hash;
  
  produces:
  
      ---
      apple: good
      banana: bad
      cauliflower: ugly
      ---
      banana: bad
      apple: good
  
  Bless returns the tied part of a yaml-node, so that you can call the
  YAML::Node methods. This is the same thing that YAML::Node::ynode()
  returns. So another way to do the above example is:
  
      use YAML qw(Dump Bless);
      use YAML::Node;
      $hash = {apple => 'good', banana => 'bad', cauliflower => 'ugly'};
      print Dump $hash;
      Bless($hash);
      $ynode = ynode(Blessed($hash));
      $ynode->keys(['banana', 'apple']);
      print Dump $hash;
  
  Note that Blessing a Perl data structure does not change it anyway. The
  extra information is stored separately and looked up by the Blessed
  node's memory address.
  
  =item Blessed(perl-node)
  
  Returns the yaml node that a particular perl node is associated with
  (see above). Returns undef if the node is not (YAML) Blessed.
  
  =back
  
  =head1 GLOBAL OPTIONS
  
  YAML options are set using a group of global variables in the YAML
  namespace. This is similar to how Data::Dumper works.
  
  For example, to change the indentation width, do something like:
  
      local $YAML::Indent = 3;
  
  The current options are:
  
  =over 4
  
  =item DumperClass
  
  You can override which module/class YAML uses for Dumping data.
  
  =item LoaderClass
  
  You can override which module/class YAML uses for Loading data.
  
  =item Indent
  
  This is the number of space characters to use for each indentation level
  when doing a Dump(). The default is 2.
  
  By the way, YAML can use any number of characters for indentation at any
  level. So if you are editing YAML by hand feel free to do it anyway that
  looks pleasing to you; just be consistent for a given level.
  
  =item SortKeys
  
  Default is 1. (true)
  
  Tells YAML.pm whether or not to sort hash keys when storing a document.
  
  YAML::Node objects can have their own sort order, which is usually what
  you want. To override the YAML::Node order and sort the keys anyway, set
  SortKeys to 2.
  
  =item Stringify
  
  Default is 0. (false)
  
  Objects with string overloading should honor the overloading and dump the
  stringification of themselves, rather than the actual object's guts.
  
  =item UseHeader
  
  Default is 1. (true)
  
  This tells YAML.pm whether to use a separator string for a Dump
  operation. This only applies to the first document in a stream.
  Subsequent documents must have a YAML header by definition.
  
  =item UseVersion
  
  Default is 0. (false)
  
  Tells YAML.pm whether to include the YAML version on the
  separator/header.
  
      --- %YAML:1.0
  
  =item AnchorPrefix
  
  Default is ''.
  
  Anchor names are normally numeric. YAML.pm simply starts with '1' and
  increases by one for each new anchor. This option allows you to specify a
  string to be prepended to each anchor number.
  
  =item UseCode
  
  Setting the UseCode option is a shortcut to set both the DumpCode and
  LoadCode options at once. Setting UseCode to '1' tells YAML.pm to dump
  Perl code references as Perl (using B::Deparse) and to load them back
  into memory using eval(). The reason this has to be an option is that
  using eval() to parse untrusted code is, well, untrustworthy.
  
  =item DumpCode
  
  Determines if and how YAML.pm should serialize Perl code references. By
  default YAML.pm will dump code references as dummy placeholders (much
  like Data::Dumper). If DumpCode is set to '1' or 'deparse', code
  references will be dumped as actual Perl code.
  
  DumpCode can also be set to a subroutine reference so that you can
  write your own serializing routine. YAML.pm passes you the code ref. You
  pass back the serialization (as a string) and a format indicator. The
  format indicator is a simple string like: 'deparse' or 'bytecode'.
  
  =item LoadCode
  
  LoadCode is the opposite of DumpCode. It tells YAML if and how to
  deserialize code references. When set to '1' or 'deparse' it will use
  C<eval()>. Since this is potentially risky, only use this option if you
  know where your YAML has been.
  
  LoadCode can also be set to a subroutine reference so that you can write
  your own deserializing routine. YAML.pm passes the serialization (as a
  string) and a format indicator. You pass back the code reference.
  
  =item UseBlock
  
  YAML.pm uses heuristics to guess which scalar style is best for a given
  node. Sometimes you'll want all multiline scalars to use the 'block'
  style. If so, set this option to 1.
  
  NOTE: YAML's block style is akin to Perl's here-document.
  
  =item UseFold
  
  If you want to force YAML to use the 'folded' style for all multiline
  scalars, then set $UseFold to 1.
  
  NOTE: YAML's folded style is akin to the way HTML folds text,
        except smarter.
  
  =item UseAliases
  
  YAML has an alias mechanism such that any given structure in memory gets
  serialized once. Any other references to that structure are serialized
  only as alias markers. This is how YAML can serialize duplicate and
  recursive structures.
  
  Sometimes, when you KNOW that your data is nonrecursive in nature, you
  may want to serialize such that every node is expressed in full. (ie as
  a copy of the original). Setting $YAML::UseAliases to 0 will allow you
  to do this. This also may result in faster processing because the lookup
  overhead is by bypassed.
  
  THIS OPTION CAN BE DANGEROUS. *If* your data is recursive, this option
  *will* cause Dump() to run in an endless loop, chewing up your computers
  memory. You have been warned.
  
  =item CompressSeries
  
  Default is 1.
  
  Compresses the formatting of arrays of hashes:
  
      -
        foo: bar
      - 
        bar: foo
  
  becomes:
  
      - foo: bar
      - bar: foo
  
  Since this output is usually more desirable, this option is turned on by
  default.
  
  =back
  
  =head1 YAML TERMINOLOGY
  
  YAML is a full featured data serialization language, and thus has its
  own terminology.
  
  It is important to remember that although YAML is heavily influenced by
  Perl and Python, it is a language in its own right, not merely just a
  representation of Perl structures.
  
  YAML has three constructs that are conspicuously similar to Perl's hash,
  array, and scalar. They are called mapping, sequence, and string
  respectively. By default, they do what you would expect. But each
  instance may have an explicit or implicit tag (type) that makes it
  behave differently. In this manner, YAML can be extended to represent
  Perl's Glob or Python's tuple, or Ruby's Bigint.
  
  =over 4
  
  =item stream
  
  A YAML stream is the full sequence of unicode characters that a YAML
  parser would read or a YAML emitter would write. A stream may contain
  one or more YAML documents separated by YAML headers.
  
      ---
      a: mapping
      foo: bar
      ---
      - a
      - sequence
  
  =item document
  
  A YAML document is an independent data structure representation within a
  stream. It is a top level node. Each document in a YAML stream must
  begin with a YAML header line. Actually the header is optional on the
  first document.
  
      ---
      This: top level mapping
      is:
          - a
          - YAML
          - document
  
  =item header
  
  A YAML header is a line that begins a YAML document. It consists of
  three dashes, possibly followed by more info. Another purpose of the
  header line is that it serves as a place to put top level tag and anchor
  information.
  
      --- !recursive-sequence &001
      - * 001
      - * 001
  
  =item node
  
  A YAML node is the representation of a particular data stucture. Nodes
  may contain other nodes. (In Perl terms, nodes are like scalars.
  Strings, arrayrefs and hashrefs. But this refers to the serialized
  format, not the in-memory structure.)
  
  =item tag
  
  This is similar to a type. It indicates how a particular YAML node
  serialization should be transferred into or out of memory. For instance
  a Foo::Bar object would use the tag 'perl/Foo::Bar':
  
      - !perl/Foo::Bar
          foo: 42
          bar: stool
  
  =item collection
  
  A collection is the generic term for a YAML data grouping. YAML has two
  types of collections: mappings and sequences. (Similar to hashes and arrays)
  
  =item mapping
  
  A mapping is a YAML collection defined by unordered key/value pairs with
  unique keys. By default YAML mappings are loaded into Perl hashes.
  
      a mapping:
          foo: bar
          two: times two is 4
  
  =item sequence
  
  A sequence is a YAML collection defined by an ordered list of elements. By
  default YAML sequences are loaded into Perl arrays.
  
      a sequence:
          - one bourbon
          - one scotch
          - one beer
  
  =item scalar
  
  A scalar is a YAML node that is a single value. By default YAML scalars
  are loaded into Perl scalars.
  
      a scalar key: a scalar value
  
  YAML has many styles for representing scalars. This is important because
  varying data will have varying formatting requirements to retain the
  optimum human readability.
  
  =item plain scalar
  
  A plain scalar is unquoted. All plain scalars are automatic candidates
  for "implicit tagging". This means that their tag may be determined
  automatically by examination. The typical uses for this are plain alpha
  strings, integers, real numbers, dates, times and currency.
  
      - a plain string
      - -42
      - 3.1415
      - 12:34
      - 123 this is an error
  
  =item single quoted scalar
  
  This is similar to Perl's use of single quotes. It means no escaping
  except for single quotes which are escaped by using two adjacent
  single quotes.
  
      - 'When I say ''\n'' I mean "backslash en"'
  
  =item double quoted scalar
  
  This is similar to Perl's use of double quotes. Character escaping can
  be used.
  
      - "This scalar\nhas two lines, and a bell -->\a"
  
  =item folded scalar
  
  This is a multiline scalar which begins on the next line. It is
  indicated by a single right angle bracket. It is unescaped like the
  single quoted scalar. Line folding is also performed.
  
      - > 
       This is a multiline scalar which begins on
       the next line. It is indicated by a single
       carat. It is unescaped like the single
       quoted scalar. Line folding is also
       performed.
  
  =item block scalar
  
  This final multiline form is akin to Perl's here-document except that
  (as in all YAML data) scope is indicated by indentation. Therefore, no
  ending marker is required. The data is verbatim. No line folding.
  
      - |
          QTY  DESC          PRICE  TOTAL
          ---  ----          -----  -----
            1  Foo Fighters  $19.95 $19.95
            2  Bar Belles    $29.95 $59.90
  
  =item parser
  
  A YAML processor has four stages: parse, load, dump, emit.
  
  A parser parses a YAML stream. YAML.pm's Load() function contains a
  parser.
  
  =item loader
  
  The other half of the Load() function is a loader. This takes the
  information from the parser and loads it into a Perl data structure.
  
  =item dumper
  
  The Dump() function consists of a dumper and an emitter. The dumper
  walks through each Perl data structure and gives info to the emitter.
  
  =item emitter
  
  The emitter takes info from the dumper and turns it into a YAML stream.
  
  NOTE:
  In YAML.pm the parser/loader and the dumper/emitter code are currently
  very closely tied together. In the future they may be broken into
  separate stages.
  
  =back
  
  For more information please refer to the immensely helpful YAML
  specification available at L<http://www.yaml.org/spec/>.
  
  =head1 ysh - The YAML Shell
  
  The YAML distribution ships with a script called 'ysh', the YAML shell.
  ysh provides a simple, interactive way to play with YAML. If you type in
  Perl code, it displays the result in YAML. If you type in YAML it turns
  it into Perl code.
  
  To run ysh, (assuming you installed it along with YAML.pm) simply type:
  
      ysh [options]
  
  Please read the C<ysh> documentation for the full details. There are
  lots of options.
  
  =head1 BUGS & DEFICIENCIES
  
  If you find a bug in YAML, please try to recreate it in the YAML Shell
  with logging turned on ('ysh -L'). When you have successfully reproduced
  the bug, please mail the LOG file to the author (ingy@cpan.org).
  
  WARNING: This is still *ALPHA* code. Well, most of this code has been
  around for years...
  
  BIGGER WARNING: YAML.pm has been slow in the making, but I am committed
  to having top notch YAML tools in the Perl world. The YAML team is close
  to finalizing the YAML 1.1 spec. This version of YAML.pm is based off of
  a very old pre 1.0 spec. In actuality there isn't a ton of difference,
  and this YAML.pm is still fairly useful. Things will get much better in
  the future.
  
  =head1 RESOURCES
  
  L<http://lists.sourceforge.net/lists/listinfo/yaml-core> is the mailing
  list. This is where the language is discussed and designed.
  
  L<http://www.yaml.org> is the official YAML website.
  
  L<http://www.yaml.org/spec/> is the YAML 1.0 specification.
  
  L<http://yaml.kwiki.org> is the official YAML wiki.
  
  =head1 SEE ALSO
  
  See YAML::XS. Fast!
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  is resonsible for YAML.pm.
  
  The YAML serialization language is the result of years of collaboration
  between Oren Ben-Kiki, Clark Evans and Ingy dt Net. Several others
  have added help along the way.
  
  =head1 COPYRIGHT
  
  Copyright (c) 2005, 2006, 2008, 2011-2012. Ingy dt Net.
  
  Copyright (c) 2001, 2002, 2005. Brian Ingerson.
  
  Some parts copyright (c) 2009 - 2010 Adam Kennedy
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML

$fatpacked{"YAML/Any.pm"} = <<'YAML_ANY';
  package YAML::Any;
  
  our $VERSION = '0.84';
  
  use strict;
  use Exporter ();
  
  @YAML::Any::ISA       = 'Exporter';
  @YAML::Any::EXPORT    = qw(Dump Load);
  @YAML::Any::EXPORT_OK = qw(DumpFile LoadFile);
  
  my @dump_options = qw(
      UseCode
      DumpCode
      SpecVersion
      Indent
      UseHeader
      UseVersion
      SortKeys
      AnchorPrefix
      UseBlock
      UseFold
      CompressSeries
      InlineSeries
      UseAliases
      Purity
      Stringify
  );
  
  my @load_options = qw(
      UseCode
      LoadCode
  );
  
  my @implementations = qw(
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  );
  
  sub import {
      __PACKAGE__->implementation;
      goto &Exporter::import;
  }
  
  sub Dump {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Dump"}(@_);
  }
  
  sub DumpFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@dump_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::DumpFile"}(@_);
  }
  
  sub Load {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::Load"}(@_);
  }
  
  sub LoadFile {
      no strict 'refs';
      my $implementation = __PACKAGE__->implementation;
      for my $option (@load_options) {
          my $var = "$implementation\::$option";
          my $value = $$var;
          local $$var;
          $$var = defined $value ? $value : ${"YAML::$option"};
      }
      return &{"$implementation\::LoadFile"}(@_);
  }
  
  sub order {
      return @YAML::Any::_TEST_ORDER
          if @YAML::Any::_TEST_ORDER;
      return @implementations;
  }
  
  sub implementation {
      my @order = __PACKAGE__->order;
      for my $module (@order) {
          my $path = $module;
          $path =~ s/::/\//g;
          $path .= '.pm';
          return $module if exists $INC{$path};
          eval "require $module; 1" and return $module;
      }
      croak("YAML::Any couldn't find any of these YAML implementations: @order");
  }
  
  sub croak {
      require Carp;
      Carp::Croak(@_);
  }
  
  1;
  
  =head1 NAME
  
  YAML::Any - Pick a YAML implementation and use it.
  
  =head1 SYNOPSIS
  
      use YAML::Any;
      $YAML::Indent = 3;
      my $yaml = Dump(@objects);
  
  =head1 DESCRIPTION
  
  There are several YAML implementations that support the Dump/Load API.
  This module selects the best one available and uses it.
  
  =head1 ORDER
  
  Currently, YAML::Any will choose the first one of these YAML
  implementations that is installed on your system:
  
      YAML::XS
      YAML::Syck
      YAML::Old
      YAML
      YAML::Tiny
  
  =head1 OPTIONS
  
  If you specify an option like:
  
      $YAML::Indent = 4;
  
  And YAML::Any is using YAML::XS, it will use the proper variable:
  $YAML::XS::Indent.
  
  =head1 SUBROUTINES
  
  Like all the YAML modules that YAML::Any uses, the following subroutines
  are exported by default:
  
      Dump
      Load
  
  and the following subroutines are exportable by request:
  
      DumpFile
      LoadFile
  
  =head1 METHODS
  
  YAML::Any provides the following class methods.
  
  =over
  
  =item YAML::Any->order;
  
  This method returns a list of the current possible implementations that
  YAML::Any will search for.
  
  =item YAML::Any->implementation;
  
  This method returns the implementation the YAML::Any will use. This
  result is obtained by finding the first member of YAML::Any->order that
  is either already loaded in C<%INC> or that can be loaded using
  C<require>. If no implementation is found, an error will be thrown.
  
  =back
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2008. Ingy dt Net.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ANY

$fatpacked{"YAML/Dumper.pm"} = <<'YAML_DUMPER';
  package YAML::Dumper;
  use YAML::Mo;
  extends 'YAML::Dumper::Base';
  
  our $VERSION = '0.84';
  
  use YAML::Dumper::Base;
  use YAML::Node;
  use YAML::Types;
  
  # Context constants
  use constant KEY       => 3;
  use constant BLESSED   => 4;
  use constant FROMARRAY => 5;
  use constant VALUE     => "\x07YAML\x07VALUE\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $LIT_CHAR    = '|';    
  
  #==============================================================================
  # OO version of Dump. YAML->new->dump($foo); 
  sub dump {
      my $self = shift;
      $self->stream('');
      $self->document(0);
      for my $document (@_) {
          $self->{document}++;
          $self->transferred({});
          $self->id_refcnt({});
          $self->id_anchor({});
          $self->anchor(1);
          $self->level(0);
          $self->offset->[0] = 0 - $self->indent_width;
          $self->_prewalk($document);
          $self->_emit_header($document);
          $self->_emit_node($document);
      }
      return $self->stream;
  }
  
  # Every YAML document in the stream must begin with a YAML header, unless
  # there is only a single document and the user requests "no header".
  sub _emit_header {
      my $self = shift;
      my ($node) = @_;
      if (not $self->use_header and 
          $self->document == 1
         ) {
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            unless ref($node) =~ /^(HASH|ARRAY)$/;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'HASH' and keys(%$node) == 0;
          $self->die('YAML_DUMP_ERR_NO_HEADER')
            if ref($node) eq 'ARRAY' and @$node == 0;
          # XXX Also croak if aliased, blessed, or ynode
          $self->headless(1);
          return;
      }
      $self->{stream} .= '---';
  # XXX Consider switching to 1.1 style
      if ($self->use_version) {
  #         $self->{stream} .= " #YAML:1.0";
      }
  }
  
  # Walk the tree to be dumped and keep track of its reference counts.
  # This function is where the Dumper does all its work. All type
  # transfers happen here.
  sub _prewalk {
      my $self = shift;
      my $stringify = $self->stringify;
      my ($class, $type, $node_id) = $self->node_info(\$_[0], $stringify);
  
      # Handle typeglobs
      if ($type eq 'GLOB') {
          $self->transferred->{$node_id} =
            YAML::Type::glob->yaml_dump($_[0]);
          $self->_prewalk($self->transferred->{$node_id});
          return;
      }
  
      # Handle regexps
      if (ref($_[0]) eq 'Regexp') {  
          return;
      }
  
      # Handle Purity for scalars.
      # XXX can't find a use case yet. Might be YAGNI.
      if (not ref $_[0]) {
          $self->{id_refcnt}{$node_id}++ if $self->purity;
          return;
      }
  
      # Make a copy of original
      my $value = $_[0];
      ($class, $type, $node_id) = $self->node_info($value, $stringify);
  
      # Must be a stringified object.
      return if (ref($value) and not $type);
  
      # Look for things already transferred.
      if ($self->transferred->{$node_id}) {
          (undef, undef, $node_id) = (ref $self->transferred->{$node_id})
            ? $self->node_info($self->transferred->{$node_id}, $stringify)
            : $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle code refs
      if ($type eq 'CODE') {
          $self->transferred->{$node_id} = 'placeholder';
          YAML::Type::code->yaml_dump(
              $self->dump_code,
              $_[0], 
              $self->transferred->{$node_id}
          );
          ($class, $type, $node_id) = 
            $self->node_info(\ $self->transferred->{$node_id}, $stringify);
          $self->{id_refcnt}{$node_id}++;
          return;
      }
  
      # Handle blessed things
      if (defined $class) {
          if ($value->can('yaml_dump')) {
              $value = $value->yaml_dump;
          }
          elsif ($type eq 'SCALAR') {
              $self->transferred->{$node_id} = 'placeholder';
              YAML::Type::blessed->yaml_dump
                ($_[0], $self->transferred->{$node_id});
              ($class, $type, $node_id) =
                $self->node_info(\ $self->transferred->{$node_id}, $stringify);
              $self->{id_refcnt}{$node_id}++;
              return;
          }
          else {
              $value = YAML::Type::blessed->yaml_dump($value);
          }
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle YAML Blessed things
      if (defined YAML->global_object()->{blessed_map}{$node_id}) {
          $value = YAML->global_object()->{blessed_map}{$node_id};
          $self->transferred->{$node_id} = $value;
          ($class, $type, $node_id) = $self->node_info($value, $stringify);
          $self->_prewalk($value);
          return;
      }
  
      # Handle hard refs
      if ($type eq 'REF' or $type eq 'SCALAR') {
          $value = YAML::Type::ref->yaml_dump($value);
          $self->transferred->{$node_id} = $value;
          (undef, $type, $node_id) = $self->node_info($value, $stringify);
      }
  
      # Handle ref-to-glob's
      elsif ($type eq 'GLOB') {
          my $ref_ynode = $self->transferred->{$node_id} =
            YAML::Type::ref->yaml_dump($value);
  
          my $glob_ynode = $ref_ynode->{&VALUE} = 
            YAML::Type::glob->yaml_dump($$value);
  
          (undef, undef, $node_id) = $self->node_info($glob_ynode, $stringify);
          $self->transferred->{$node_id} = $glob_ynode;
          $self->_prewalk($glob_ynode);
          return;
      }
  
      # Increment ref count for node
      return if ++($self->{id_refcnt}{$node_id}) > 1;
  
      # Keep on walking
      if ($type eq 'HASH') {
          $self->_prewalk($value->{$_})
              for keys %{$value};
          return;
      }
      elsif ($type eq 'ARRAY') {
          $self->_prewalk($_)
              for @{$value};
          return;
      }
  
      # Unknown type. Need to know about it.
      $self->warn(<<"...");
  YAML::Dumper can't handle dumping this type of data.
  Please report this to the author.
  
  id:    $node_id
  type:  $type
  class: $class
  value: $value
  
  ...
  
      return;
  }
  
  # Every data element and sub data element is a node.
  # Everything emitted goes through this function.
  sub _emit_node {
      my $self = shift;
      my ($type, $node_id);
      my $ref = ref($_[0]);
      if ($ref) {
          if ($ref eq 'Regexp') {
              $self->_emit(' !!perl/regexp');
              $self->_emit_str("$_[0]");
              return;
          }
          (undef, $type, $node_id) = $self->node_info($_[0], $self->stringify);
      }
      else {
          $type = $ref || 'SCALAR';
          (undef, undef, $node_id) = $self->node_info(\$_[0], $self->stringify);
      }
  
      my ($ynode, $tag) = ('') x 2;
      my ($value, $context) = (@_, 0);
  
      if (defined $self->transferred->{$node_id}) {
          $value = $self->transferred->{$node_id};
          $ynode = ynode($value);
          if (ref $value) {
              $tag = defined $ynode ? $ynode->tag->short : '';
              (undef, $type, $node_id) =
                $self->node_info($value, $self->stringify);
          }
          else {
              $ynode = ynode($self->transferred->{$node_id});
              $tag = defined $ynode ? $ynode->tag->short : '';
              $type = 'SCALAR';
              (undef, undef, $node_id) = 
                $self->node_info(
                    \ $self->transferred->{$node_id},
                    $self->stringify
                );
          }
      }
      elsif ($ynode = ynode($value)) {
          $tag = $ynode->tag->short;
      }
  
      if ($self->use_aliases) {
          $self->{id_refcnt}{$node_id} ||= 0;
          if ($self->{id_refcnt}{$node_id} > 1) {
              if (defined $self->{id_anchor}{$node_id}) {
                  $self->{stream} .= ' *' . $self->{id_anchor}{$node_id} . "\n";
                  return;
              }
              my $anchor = $self->anchor_prefix . $self->{anchor}++;
              $self->{stream} .= ' &' . $anchor;
              $self->{id_anchor}{$node_id} = $anchor;
          }
      }
  
      return $self->_emit_str("$value")   # Stringified object
        if ref($value) and not $type;
      return $self->_emit_scalar($value, $tag)
        if $type eq 'SCALAR' and $tag;
      return $self->_emit_str($value)
        if $type eq 'SCALAR';
      return $self->_emit_mapping($value, $tag, $node_id, $context)
        if $type eq 'HASH';
      return $self->_emit_sequence($value, $tag)
        if $type eq 'ARRAY';
      $self->warn('YAML_DUMP_WARN_BAD_NODE_TYPE', $type);
      return $self->_emit_str("$value");
  }
  
  # A YAML mapping is akin to a Perl hash. 
  sub _emit_mapping {
      my $self = shift;
      my ($value, $tag, $node_id, $context) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      # Sometimes 'keys' fails. Like on a bad tie implementation.
      my $empty_hash = not(eval {keys %$value});
      $self->warn('YAML_EMIT_WARN_KEYS', $@) if $@;
      return ($self->{stream} .= " {}\n") if $empty_hash;
  
      # If CompressSeries is on (default) and legal is this context, then
      # use it and make the indent level be 2 for this node.
      if ($context == FROMARRAY and
          $self->compress_series and
          not (defined $self->{id_anchor}{$node_id} or $tag or $empty_hash)
         ) {
          $self->{stream} .= ' ';
          $self->offset->[$self->level+1] = $self->offset->[$self->level] + 2;
      }
      else {
          $context = 0;
          $self->{stream} .= "\n"
            unless $self->headless && not($self->headless(0));
          $self->offset->[$self->level+1] =
            $self->offset->[$self->level] + $self->indent_width;
      }
  
      $self->{level}++;
      my @keys;
      if ($self->sort_keys == 1) {
          if (ynode($value)) {
              @keys = keys %$value;
          }
          else {
              @keys = sort keys %$value;
          }
      }
      elsif ($self->sort_keys == 2) {
          @keys = sort keys %$value;
      }
      # XXX This is hackish but sometimes handy. Not sure whether to leave it in.
      elsif (ref($self->sort_keys) eq 'ARRAY') {
          my $i = 1;
          my %order = map { ($_, $i++) } @{$self->sort_keys};
          @keys = sort {
              (defined $order{$a} and defined $order{$b})
                ? ($order{$a} <=> $order{$b})
                : ($a cmp $b);
          } keys %$value;
      }
      else {
          @keys = keys %$value;
      }
      # Force the YAML::VALUE ('=') key to sort last.
      if (exists $value->{&VALUE}) {
          for (my $i = 0; $i < @keys; $i++) {
              if ($keys[$i] eq &VALUE) {
                  splice(@keys, $i, 1);
                  push @keys, &VALUE;
                  last;
              }
          }
      }
  
      for my $key (@keys) {
          $self->_emit_key($key, $context);
          $context = 0;
          $self->{stream} .= ':';
          $self->_emit_node($value->{$key});
      }
      $self->{level}--;
  }
  
  # A YAML series is akin to a Perl array.
  sub _emit_sequence {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag" if $tag;
  
      return ($self->{stream} .= " []\n") if @$value == 0;
          
      $self->{stream} .= "\n"
        unless $self->headless && not($self->headless(0));
  
      # XXX Really crufty feature. Better implemented by ynodes.
      if ($self->inline_series and
          @$value <= $self->inline_series and
          not (scalar grep {ref or /\n/} @$value)
         ) {
          $self->{stream} =~ s/\n\Z/ /;
          $self->{stream} .= '[';
          for (my $i = 0; $i < @$value; $i++) {
              $self->_emit_str($value->[$i], KEY);
              last if $i == $#{$value};
              $self->{stream} .= ', ';
          }
          $self->{stream} .= "]\n";
          return;
      }
  
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
      for my $val (@$value) {
          $self->{stream} .= ' ' x $self->offset->[$self->level];
          $self->{stream} .= '-';
          $self->_emit_node($val, FROMARRAY);
      }
      $self->{level}--;
  }
  
  # Emit a mapping key
  sub _emit_key {
      my $self = shift;
      my ($value, $context) = @_;
      $self->{stream} .= ' ' x $self->offset->[$self->level]
        unless $context == FROMARRAY;
      $self->_emit_str($value, KEY);
  }
  
  # Emit a blessed SCALAR
  sub _emit_scalar {
      my $self = shift;
      my ($value, $tag) = @_;
      $self->{stream} .= " !$tag";
      $self->_emit_str($value, BLESSED);
  }
  
  sub _emit {
      my $self = shift;
      $self->{stream} .= join '', @_;
  }
  
  # Emit a string value. YAML has many scalar styles. This routine attempts to
  # guess the best style for the text.
  sub _emit_str {
      my $self = shift;
      my $type = $_[1] || 0;
  
      # Use heuristics to find the best scalar emission style.
      $self->offset->[$self->level + 1] =
        $self->offset->[$self->level] + $self->indent_width;
      $self->{level}++;
  
      my $sf = $type == KEY ? '' : ' ';
      my $sb = $type == KEY ? '? ' : ' ';
      my $ef = $type == KEY ? '' : "\n";
      my $eb = "\n";
  
      while (1) {
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last 
            if not defined $_[0];
          $self->_emit($sf, '=', $ef), last
            if $_[0] eq VALUE;
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /$ESCAPE_CHAR/;
          if ($_[0] =~ /\n/) {
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last
                if $self->use_block;
                Carp::cluck "[YAML] \$UseFold is no longer supported"
                if $self->use_fold;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if length $_[0] <= 30;
              $self->_emit($sf),
              $self->_emit_double($_[0]),
              $self->_emit($ef), last
                if $_[0] !~ /\n\s*\S/;
              $self->_emit($sb),
              $self->_emit_block($LIT_CHAR, $_[0]),
              $self->_emit($eb), last;
          }
          $self->_emit($sf),
          $self->_emit_plain($_[0]),
          $self->_emit($ef), last
            if $self->is_valid_plain($_[0]);
          $self->_emit($sf),
          $self->_emit_double($_[0]),
          $self->_emit($ef), last
            if $_[0] =~ /'/;
          $self->_emit($sf),
          $self->_emit_single($_[0]),
          $self->_emit($ef);
          last;
      }
  
      $self->{level}--;
  
      return;
  }
  
  # Check whether or not a scalar should be emitted as an plain scalar.
  sub is_valid_plain {
      my $self = shift;
      return 0 unless length $_[0];
      # refer to YAML::Loader::parse_inline_simple()
      return 0 if $_[0] =~ /^[\s\{\[\~\`\'\"\!\@\#\>\|\%\&\?\*\^]/;
      return 0 if $_[0] =~ /[\{\[\]\},]/;
      return 0 if $_[0] =~ /[:\-\?]\s/;
      return 0 if $_[0] =~ /\s#/;
      return 0 if $_[0] =~ /\:(\s|$)/;
      return 0 if $_[0] =~ /[\s\|\>]$/;
      return 1;
  }
  
  sub _emit_block {
      my $self = shift;
      my ($indicator, $value) = @_;
      $self->{stream} .= $indicator;
      $value =~ /(\n*)\Z/;
      my $chomp = length $1 ? (length $1 > 1) ? '+' : '' : '-';
      $value = '~' if not defined $value;
      $self->{stream} .= $chomp;
      $self->{stream} .= $self->indent_width if $value =~ /^\s/;
      $self->{stream} .= $self->indent($value);
  }
  
  # Plain means that the scalar is unquoted.
  sub _emit_plain {
      my $self = shift;
      $self->{stream} .= defined $_[0] ? $_[0] : '~';
  }
  
  # Double quoting is for single lined escaped strings.
  sub _emit_double {
      my $self = shift;
      (my $escaped = $self->escape($_[0])) =~ s/"/\\"/g;
      $self->{stream} .= qq{"$escaped"};
  }
  
  # Single quoting is for single lined unescaped strings.
  sub _emit_single {
      my $self = shift;
      my $item = shift;
      $item =~ s{'}{''}g;
      $self->{stream} .= "'$item'";
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Indent a scalar to the current indentation level.
  sub indent {
      my $self = shift;
      my ($text) = @_;
      return $text unless length $text;
      $text =~ s/\n\Z//;
      my $indent = ' ' x $self->offset->[$self->level];
      $text =~ s/^/$indent/gm;
      $text = "\n$text";
      return $text;
  }
  
  # Escapes for unprintable characters
  my @escapes = qw(\0   \x01 \x02 \x03 \x04 \x05 \x06 \a
                   \x08 \t   \n   \v   \f   \r   \x0e \x0f
                   \x10 \x11 \x12 \x13 \x14 \x15 \x16 \x17
                   \x18 \x19 \x1a \e   \x1c \x1d \x1e \x1f
                  );
  
  # Escape the unprintable characters
  sub escape {
      my $self = shift;
      my ($text) = @_;
      $text =~ s/\\/\\\\/g;
      $text =~ s/([\x00-\x1f])/$escapes[ord($1)]/ge;
      return $text;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Dumper - YAML class for dumping Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Dumper;
      my $dumper = YAML::Dumper->new;
      $dumper->indent_width(4);
      print $dumper->dump({foo => 'bar'});
  
  =head1 DESCRIPTION
  
  YAML::Dumper is the module that YAML.pm used to serialize Perl objects to
  YAML. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER

$fatpacked{"YAML/Dumper/Base.pm"} = <<'YAML_DUMPER_BASE';
  package YAML::Dumper::Base;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use YAML::Node;
  
  # YAML Dumping options
  has spec_version    => default => sub {'1.0'};
  has indent_width    => default => sub {2};
  has use_header      => default => sub {1};
  has use_version     => default => sub {0};
  has sort_keys       => default => sub {1};
  has anchor_prefix   => default => sub {''};
  has dump_code       => default => sub {0};
  has use_block       => default => sub {0};
  has use_fold        => default => sub {0};
  has compress_series => default => sub {1};
  has inline_series   => default => sub {0};
  has use_aliases     => default => sub {1};
  has purity          => default => sub {0};
  has stringify       => default => sub {0};
  
  # Properties
  has stream      => default => sub {''};
  has document    => default => sub {0};
  has transferred => default => sub {{}};
  has id_refcnt   => default => sub {{}};
  has id_anchor   => default => sub {{}};
  has anchor      => default => sub {1};
  has level       => default => sub {0};
  has offset      => default => sub {[]};
  has headless    => default => sub {0};
  has blessed_map => default => sub {{}};
  
  # Global Options are an idea taken from Data::Dumper. Really they are just
  # sugar on top of real OO properties. They make the simple Dump/Load API
  # easy to configure.
  sub set_global_options {
      my $self = shift;
      $self->spec_version($YAML::SpecVersion)
        if defined $YAML::SpecVersion;
      $self->indent_width($YAML::Indent)
        if defined $YAML::Indent;
      $self->use_header($YAML::UseHeader)
        if defined $YAML::UseHeader;
      $self->use_version($YAML::UseVersion)
        if defined $YAML::UseVersion;
      $self->sort_keys($YAML::SortKeys)
        if defined $YAML::SortKeys;
      $self->anchor_prefix($YAML::AnchorPrefix)
        if defined $YAML::AnchorPrefix;
      $self->dump_code($YAML::DumpCode || $YAML::UseCode)
        if defined $YAML::DumpCode or defined $YAML::UseCode;
      $self->use_block($YAML::UseBlock)
        if defined $YAML::UseBlock;
      $self->use_fold($YAML::UseFold)
        if defined $YAML::UseFold;
      $self->compress_series($YAML::CompressSeries)
        if defined $YAML::CompressSeries;
      $self->inline_series($YAML::InlineSeries)
        if defined $YAML::InlineSeries;
      $self->use_aliases($YAML::UseAliases)
        if defined $YAML::UseAliases;
      $self->purity($YAML::Purity)
        if defined $YAML::Purity;
      $self->stringify($YAML::Stringify)
        if defined $YAML::Stringify;
  }
  
  sub dump {
      my $self = shift;
      $self->die('dump() not implemented in this class.');
  }
  
  sub blessed {
      my $self = shift;
      my ($ref) = @_;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      $self->{blessed_map}->{$node_id};
  }
      
  sub bless {
      my $self = shift;
      my ($ref, $blessing) = @_;
      my $ynode;
      $ref = \$_[0] unless ref $ref;
      my (undef, undef, $node_id) = YAML::Mo::Object->node_info($ref);
      if (not defined $blessing) {
          $ynode = YAML::Node->new($ref);
      }
      elsif (ref $blessing) {
          $self->die() unless ynode($blessing);
          $ynode = $blessing;
      }
      else {
          no strict 'refs';
          my $transfer = $blessing . "::yaml_dump";
          $self->die() unless defined &{$transfer};
          $ynode = &{$transfer}($ref);
          $self->die() unless ynode($ynode);
      }
      $self->{blessed_map}->{$node_id} = $ynode;
      my $object = ynode($ynode) or $self->die();
      return $object;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Dumper::Base - Base class for YAML Dumper classes
  
  =head1 SYNOPSIS
  
      package YAML::Dumper::Something;
      use YAML::Dumper::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Dumper::Base is a base class for creating YAML dumper classes.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_DUMPER_BASE

$fatpacked{"YAML/Error.pm"} = <<'YAML_ERROR';
  package YAML::Error;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  has 'code';
  has 'type' => default => sub {'Error'};
  has 'line';
  has 'document';
  has 'arguments' => default => sub {[]};
  
  my ($error_messages, %line_adjust);
  
  sub format_message {
      my $self = shift;
      my $output = 'YAML ' . $self->type . ': ';
      my $code = $self->code;
      if ($error_messages->{$code}) {
          $code = sprintf($error_messages->{$code}, @{$self->arguments});
      }
      $output .= $code . "\n";
  
      $output .= '   Code: ' . $self->code . "\n"
          if defined $self->code;
      $output .= '   Line: ' . $self->line . "\n"
          if defined $self->line;
      $output .= '   Document: ' . $self->document . "\n"
          if defined $self->document;
      return $output;
  }
  
  sub error_messages {
      $error_messages;
  }
  
  %$error_messages = map {s/^\s+//;$_} split "\n", <<'...';
  YAML_PARSE_ERR_BAD_CHARS
    Invalid characters in stream. This parser only supports printable ASCII
  YAML_PARSE_ERR_NO_FINAL_NEWLINE
    Stream does not end with newline character
  YAML_PARSE_ERR_BAD_MAJOR_VERSION
    Can't parse a %s document with a 1.0 parser
  YAML_PARSE_WARN_BAD_MINOR_VERSION
    Parsing a %s document with a 1.0 parser
  YAML_PARSE_WARN_MULTIPLE_DIRECTIVES
    '%s directive used more than once'
  YAML_PARSE_ERR_TEXT_AFTER_INDICATOR
    No text allowed after indicator
  YAML_PARSE_ERR_NO_ANCHOR
    No anchor for alias '*%s'
  YAML_PARSE_ERR_NO_SEPARATOR
    Expected separator '---'
  YAML_PARSE_ERR_SINGLE_LINE
    Couldn't parse single line value
  YAML_PARSE_ERR_BAD_ANCHOR
    Invalid anchor
  YAML_DUMP_ERR_INVALID_INDENT
    Invalid Indent width specified: '%s'
  YAML_LOAD_USAGE
    usage: YAML::Load($yaml_stream_scalar)
  YAML_PARSE_ERR_BAD_NODE
    Can't parse node
  YAML_PARSE_ERR_BAD_EXPLICIT
    Unsupported explicit transfer: '%s'
  YAML_DUMP_USAGE_DUMPCODE
    Invalid value for DumpCode: '%s'
  YAML_LOAD_ERR_FILE_INPUT
    Couldn't open %s for input:\n%s
  YAML_DUMP_ERR_FILE_CONCATENATE
    Can't concatenate to YAML file %s
  YAML_DUMP_ERR_FILE_OUTPUT
    Couldn't open %s for output:\n%s
  YAML_DUMP_ERR_NO_HEADER
    With UseHeader=0, the node must be a plain hash or array
  YAML_DUMP_WARN_BAD_NODE_TYPE
    Can't perform serialization for node type: '%s'
  YAML_EMIT_WARN_KEYS
    Encountered a problem with 'keys':\n%s
  YAML_DUMP_WARN_DEPARSE_FAILED
    Deparse failed for CODE reference
  YAML_DUMP_WARN_CODE_DUMMY
    Emitting dummy subroutine for CODE reference
  YAML_PARSE_ERR_MANY_EXPLICIT
    More than one explicit transfer
  YAML_PARSE_ERR_MANY_IMPLICIT
    More than one implicit request
  YAML_PARSE_ERR_MANY_ANCHOR
    More than one anchor
  YAML_PARSE_ERR_ANCHOR_ALIAS
    Can't define both an anchor and an alias
  YAML_PARSE_ERR_BAD_ALIAS
    Invalid alias
  YAML_PARSE_ERR_MANY_ALIAS
    More than one alias
  YAML_LOAD_ERR_NO_CONVERT
    Can't convert implicit '%s' node to explicit '%s' node
  YAML_LOAD_ERR_NO_DEFAULT_VALUE
    No default value for '%s' explicit transfer
  YAML_LOAD_ERR_NON_EMPTY_STRING
    Only the empty string can be converted to a '%s'
  YAML_LOAD_ERR_BAD_MAP_TO_SEQ
    Can't transfer map as sequence. Non numeric key '%s' encountered.
  YAML_DUMP_ERR_BAD_GLOB
    '%s' is an invalid value for Perl glob
  YAML_DUMP_ERR_BAD_REGEXP
    '%s' is an invalid value for Perl Regexp
  YAML_LOAD_ERR_BAD_MAP_ELEMENT
    Invalid element in map
  YAML_LOAD_WARN_DUPLICATE_KEY
    Duplicate map key found. Ignoring.
  YAML_LOAD_ERR_BAD_SEQ_ELEMENT
    Invalid element in sequence
  YAML_PARSE_ERR_INLINE_MAP
    Can't parse inline map
  YAML_PARSE_ERR_INLINE_SEQUENCE
    Can't parse inline sequence
  YAML_PARSE_ERR_BAD_DOUBLE
    Can't parse double quoted string
  YAML_PARSE_ERR_BAD_SINGLE
    Can't parse single quoted string
  YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
    Can't parse inline implicit value '%s'
  YAML_PARSE_ERR_BAD_IMPLICIT
    Unrecognized implicit value '%s'
  YAML_PARSE_ERR_INDENTATION
    Error. Invalid indentation level
  YAML_PARSE_ERR_INCONSISTENT_INDENTATION
    Inconsistent indentation level
  YAML_LOAD_WARN_UNRESOLVED_ALIAS
    Can't resolve alias *%s
  YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
    No 'REGEXP' element for Perl regexp
  YAML_LOAD_WARN_BAD_REGEXP_ELEM
    Unknown element '%s' in Perl regexp
  YAML_LOAD_WARN_GLOB_NAME
    No 'NAME' element for Perl glob
  YAML_LOAD_WARN_PARSE_CODE
    Couldn't parse Perl code scalar: %s
  YAML_LOAD_WARN_CODE_DEPARSE
    Won't parse Perl code unless $YAML::LoadCode is set
  YAML_EMIT_ERR_BAD_LEVEL
    Internal Error: Bad level detected
  YAML_PARSE_WARN_AMBIGUOUS_TAB
    Amibiguous tab converted to spaces
  YAML_LOAD_WARN_BAD_GLOB_ELEM
    Unknown element '%s' in Perl glob
  YAML_PARSE_ERR_ZERO_INDENT
    Can't use zero as an indentation width
  YAML_LOAD_WARN_GLOB_IO
    Can't load an IO filehandle. Yet!!!
  ...
  
  %line_adjust = map {($_, 1)} 
    qw(YAML_PARSE_ERR_BAD_MAJOR_VERSION
       YAML_PARSE_WARN_BAD_MINOR_VERSION 
       YAML_PARSE_ERR_TEXT_AFTER_INDICATOR 
       YAML_PARSE_ERR_NO_ANCHOR 
       YAML_PARSE_ERR_MANY_EXPLICIT
       YAML_PARSE_ERR_MANY_IMPLICIT
       YAML_PARSE_ERR_MANY_ANCHOR
       YAML_PARSE_ERR_ANCHOR_ALIAS
       YAML_PARSE_ERR_BAD_ALIAS
       YAML_PARSE_ERR_MANY_ALIAS
       YAML_LOAD_ERR_NO_CONVERT
       YAML_LOAD_ERR_NO_DEFAULT_VALUE
       YAML_LOAD_ERR_NON_EMPTY_STRING
       YAML_LOAD_ERR_BAD_MAP_TO_SEQ
       YAML_LOAD_ERR_BAD_STR_TO_INT
       YAML_LOAD_ERR_BAD_STR_TO_DATE
       YAML_LOAD_ERR_BAD_STR_TO_TIME
       YAML_LOAD_WARN_DUPLICATE_KEY
       YAML_PARSE_ERR_INLINE_MAP
       YAML_PARSE_ERR_INLINE_SEQUENCE
       YAML_PARSE_ERR_BAD_DOUBLE
       YAML_PARSE_ERR_BAD_SINGLE
       YAML_PARSE_ERR_BAD_INLINE_IMPLICIT
       YAML_PARSE_ERR_BAD_IMPLICIT
       YAML_LOAD_WARN_NO_REGEXP_IN_REGEXP
       YAML_LOAD_WARN_BAD_REGEXP_ELEM
       YAML_LOAD_WARN_REGEXP_CREATE
       YAML_LOAD_WARN_GLOB_NAME
       YAML_LOAD_WARN_PARSE_CODE
       YAML_LOAD_WARN_CODE_DEPARSE
       YAML_LOAD_WARN_BAD_GLOB_ELEM
       YAML_PARSE_ERR_ZERO_INDENT
      );
  
  package YAML::Warning;
  
  our @ISA = 'YAML::Error';
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Error - Error formatting class for YAML modules
  
  =head1 SYNOPSIS
  
      $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias);
      $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
  
  =head1 DESCRIPTION
  
  This module provides a C<die> and a C<warn> facility.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_ERROR

$fatpacked{"YAML/Loader.pm"} = <<'YAML_LOADER';
  package YAML::Loader;
  use YAML::Mo;
  extends 'YAML::Loader::Base';
  
  our $VERSION = '0.84';
  
  use YAML::Loader::Base;
  use YAML::Types;
  
  # Context constants
  use constant LEAF       => 1;
  use constant COLLECTION => 2;
  use constant VALUE      => "\x07YAML\x07VALUE\x07";
  use constant COMMENT    => "\x07YAML\x07COMMENT\x07";
  
  # Common YAML character sets
  my $ESCAPE_CHAR = '[\\x00-\\x08\\x0b-\\x0d\\x0e-\\x1f]';
  my $FOLD_CHAR   = '>';
  my $LIT_CHAR    = '|';    
  my $LIT_CHAR_RX = "\\$LIT_CHAR";    
  
  sub load {
      my $self = shift;
      $self->stream($_[0] || '');
      return $self->_parse();
  }
  
  # Top level function for parsing. Parse each document in order and
  # handle processing for YAML headers.
  sub _parse {
      my $self = shift;
      my (%directives, $preface);
      $self->{stream} =~ s|\015\012|\012|g;
      $self->{stream} =~ s|\015|\012|g;
      $self->line(0);
      $self->die('YAML_PARSE_ERR_BAD_CHARS') 
        if $self->stream =~ /$ESCAPE_CHAR/;
      $self->die('YAML_PARSE_ERR_NO_FINAL_NEWLINE') 
        if length($self->stream) and 
           $self->{stream} !~ s/(.)\n\Z/$1/s;
      $self->lines([split /\x0a/, $self->stream, -1]);
      $self->line(1);
      # Throw away any comments or blanks before the header (or start of
      # content for headerless streams)
      $self->_parse_throwaway_comments();
      $self->document(0);
      $self->documents([]);
      # Add an "assumed" header if there is no header and the stream is
      # not empty (after initial throwaways).
      if (not $self->eos) {
          if ($self->lines->[0] !~ /^---(\s|$)/) {
              unshift @{$self->lines}, '---';
              $self->{line}--;
          }
      }
  
      # Main Loop. Parse out all the top level nodes and return them.
      while (not $self->eos) {
          $self->anchor2node({});
          $self->{document}++;
          $self->done(0);
          $self->level(0);
          $self->offset->[0] = -1;
  
          if ($self->lines->[0] =~ /^---\s*(.*)$/) {
              my @words = split /\s+/, $1;
              %directives = ();
              while (@words && $words[0] =~ /^#(\w+):(\S.*)$/) {
                  my ($key, $value) = ($1, $2);
                  shift(@words);
                  if (defined $directives{$key}) {
                      $self->warn('YAML_PARSE_WARN_MULTIPLE_DIRECTIVES',
                        $key, $self->document);
                      next;
                  }
                  $directives{$key} = $value;
              }
              $self->preface(join ' ', @words);
          }
          else {
              $self->die('YAML_PARSE_ERR_NO_SEPARATOR');
          }
  
          if (not $self->done) {
              $self->_parse_next_line(COLLECTION);
          }
          if ($self->done) {
              $self->{indent} = -1;
              $self->content('');
          }
  
          $directives{YAML} ||= '1.0';
          $directives{TAB} ||= 'NONE';
          ($self->{major_version}, $self->{minor_version}) = 
            split /\./, $directives{YAML}, 2;
          $self->die('YAML_PARSE_ERR_BAD_MAJOR_VERSION', $directives{YAML})
            if $self->major_version ne '1';
          $self->warn('YAML_PARSE_WARN_BAD_MINOR_VERSION', $directives{YAML})
            if $self->minor_version ne '0';
          $self->die('Unrecognized TAB policy')
            unless $directives{TAB} =~ /^(NONE|\d+)(:HARD)?$/;
  
          push @{$self->documents}, $self->_parse_node();
      }
      return wantarray ? @{$self->documents} : $self->documents->[-1];
  }
  
  # This function is the dispatcher for parsing each node. Every node
  # recurses back through here. (Inlines are an exception as they have
  # their own sub-parser.)
  sub _parse_node {
      my $self = shift;
      my $preface = $self->preface;
      $self->preface('');
      my ($node, $type, $indicator, $escape, $chomp) = ('') x 5;
      my ($anchor, $alias, $explicit, $implicit, $class) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $preface) = 
        $self->_parse_qualifiers($preface);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $self->inline('');
      while (length $preface) {
          my $line = $self->line - 1;
          if ($preface =~ s/^($FOLD_CHAR|$LIT_CHAR_RX)(-|\+)?\d*\s*//) { 
              $indicator = $1;
              $chomp = $2 if defined($2);
          }
          else {
              $self->die('YAML_PARSE_ERR_TEXT_AFTER_INDICATOR') if $indicator;
              $self->inline($preface);
              $preface = '';
          }
      }
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line]; 
          }
      }
      elsif (length $self->inline) {
          $node = $self->_parse_inline(1, $implicit, $explicit);
          if (length $self->inline) {
              $self->die('YAML_PARSE_ERR_SINGLE_LINE'); 
          }
      }
      elsif ($indicator eq $LIT_CHAR) {
          $self->{level}++;
          $node = $self->_parse_block($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--; 
      }
      elsif ($indicator eq $FOLD_CHAR) {
          $self->{level}++;
          $node = $self->_parse_unfold($chomp);
          $node = $self->_parse_implicit($node) if $implicit;
          $self->{level}--;
      }
      else {
          $self->{level}++;
          $self->offset->[$self->level] ||= 0;
          if ($self->indent == $self->offset->[$self->level]) {
              if ($self->content =~ /^-( |$)/) {
                  $node = $self->_parse_seq($anchor);
              }
              elsif ($self->content =~ /(^\?|\:( |$))/) {
                  $node = $self->_parse_mapping($anchor);
              }
              elsif ($preface =~ /^\s*$/) {
                  $node = $self->_parse_implicit('');
              }
              else {
                  $self->die('YAML_PARSE_ERR_BAD_NODE');
              }
          }
          else {
              $node = undef;
          }
          $self->{level}--;
      }
      $#{$self->offset} = $self->level;
  
      if ($explicit) {
          if ($class) {
              if (not ref $node) {
                  my $copy = $node;
                  undef $node;
                  $node = \$copy;
              }
              CORE::bless $node, $class;
          }
          else {
              $node = $self->_parse_explicit($node, $explicit);
          }
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              # XXX Can't remember what this code actually does
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Preprocess the qualifiers that may be attached to any node.
  sub _parse_qualifiers {
      my $self = shift;
      my ($preface) = @_;
      my ($anchor, $alias, $explicit, $implicit, $token) = ('') x 5;
      $self->inline('');
      while ($preface =~ /^[&*!]/) {
          my $line = $self->line - 1;
          if ($preface =~ s/^\!(\S+)\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_EXPLICIT') if $explicit;
              $explicit = $1;
          }
          elsif ($preface =~ s/^\!\s*//) {
              $self->die('YAML_PARSE_ERR_MANY_IMPLICIT') if $implicit;
              $implicit = 1;
          }
          elsif ($preface =~ s/^\&([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ANCHOR') 
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ANCHOR') if $anchor;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $alias;
              $anchor = $token;
          }
          elsif ($preface =~ s/^\*([^ ,:]+)\s*//) {
              $token = $1;
              $self->die('YAML_PARSE_ERR_BAD_ALIAS')
                unless $token =~ /^[a-zA-Z0-9]+$/;
              $self->die('YAML_PARSE_ERR_MANY_ALIAS') if $alias;
              $self->die('YAML_PARSE_ERR_ANCHOR_ALIAS') if $anchor;
              $alias = $token;
          }
      }
      return ($anchor, $alias, $explicit, $implicit, $preface); 
  }
  
  # Morph a node to it's explicit type  
  sub _parse_explicit {
      my $self = shift;
      my ($node, $explicit) = @_;
      my ($type, $class);
      if ($explicit =~ /^\!?perl\/(hash|array|ref|scalar)(?:\:(\w(\w|\:\:)*)?)?$/) {
          ($type, $class) = (($1 || ''), ($2 || ''));
  
          # FIXME # die unless uc($type) eq ref($node) ?
  
          if ( $type eq "ref" ) {
              $self->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'XXX', $explicit)
              unless exists $node->{VALUE()} and scalar(keys %$node) == 1;
  
              my $value = $node->{VALUE()};
              $node = \$value;
          }
          
          if ( $type eq "scalar" and length($class) and !ref($node) ) {
              my $value = $node;
              $node = \$value;
          }
  
          if ( length($class) ) {
              CORE::bless($node, $class);
          }
  
          return $node;
      }
      if ($explicit =~ m{^!?perl/(glob|regexp|code)(?:\:(\w(\w|\:\:)*)?)?$}) {
          ($type, $class) = (($1 || ''), ($2 || ''));
          my $type_class = "YAML::Type::$type";
          no strict 'refs';
          if ($type_class->can('yaml_load')) {
              return $type_class->yaml_load($node, $class, $self);
          }
          else {
              $self->die('YAML_LOAD_ERR_NO_CONVERT', 'XXX', $explicit);
          }
      }
      # This !perl/@Foo and !perl/$Foo are deprecated but still parsed
      elsif ($YAML::TagClass->{$explicit} ||
             $explicit =~ m{^perl/(\@|\$)?([a-zA-Z](\w|::)+)$}
            ) {
          $class = $YAML::TagClass->{$explicit} || $2;
          if ($class->can('yaml_load')) {
              require YAML::Node;
              return $class->yaml_load(YAML::Node->new($node, $explicit));
          }
          else {
              if (ref $node) {
                  return CORE::bless $node, $class;
              }
              else {
                  return CORE::bless \$node, $class;
              }
          }
      }
      elsif (ref $node) {
          require YAML::Node;
          return YAML::Node->new($node, $explicit);
      }
      else {
          # XXX This is likely wrong. Failing test:
          # --- !unknown 'scalar value'
          return $node;
      }
  }
  
  # Parse a YAML mapping into a Perl hash
  sub _parse_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $mapping = {};
      $self->anchor2node->{$anchor} = $mapping;
      my $key;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          # If structured key:
          if ($self->{content} =~ s/^\?\s*//) {
              $self->preface($self->content);
              $self->_parse_next_line(COLLECTION);
              $key = $self->_parse_node();
              $key = "$key";
          }
          # If "default" key (equals sign) 
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = VALUE;
          }
          # If "comment" key (slash slash)
          elsif ($self->{content} =~ s/^\=\s*//) {
              $key = COMMENT;
          }
          # Regular scalar key:
          else {
              $self->inline($self->content);
              $key = $self->_parse_inline();
              $key = "$key";
              $self->content($self->inline);
              $self->inline('');
          }
              
          unless ($self->{content} =~ s/^:\s*//) {
              $self->die('YAML_LOAD_ERR_BAD_MAP_ELEMENT');
          }
          $self->preface($self->content);
          my $line = $self->line;
          $self->_parse_next_line(COLLECTION);
          my $value = $self->_parse_node();
          if (exists $mapping->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $mapping->{$key} = $value;
          }
      }
      return $mapping;
  }
  
  # Parse a YAML sequence into a Perl array
  sub _parse_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $seq = [];
      $self->anchor2node->{$anchor} = $seq;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          if ($self->content =~ /^-(?: (.*))?$/) {
              $self->preface(defined($1) ? $1 : '');
          }
          else {
              $self->die('YAML_LOAD_ERR_BAD_SEQ_ELEMENT');
          }
          if ($self->preface =~ /^(\s*)(\w.*\:(?: |$).*)$/) {
              $self->indent($self->offset->[$self->level] + 2 + length($1));
              $self->content($2);
              $self->level($self->level + 1);
              $self->offset->[$self->level] = $self->indent;
              $self->preface('');
              push @$seq, $self->_parse_mapping('');
              $self->{level}--;
              $#{$self->offset} = $self->level;
          }
          else {
              $self->_parse_next_line(COLLECTION);
              push @$seq, $self->_parse_node();
          }
      }
      return $seq;
  }
  
  # Parse an inline value. Since YAML supports inline collections, this is
  # the top level of a sub parsing.
  sub _parse_inline {
      my $self = shift;
      my ($top, $top_implicit, $top_explicit) = (@_, '', '', '');
      $self->{inline} =~ s/^\s*(.*)\s*$/$1/; # OUCH - mugwump
      my ($node, $anchor, $alias, $explicit, $implicit) = ('') x 5;
      ($anchor, $alias, $explicit, $implicit, $self->{inline}) = 
        $self->_parse_qualifiers($self->inline);
      if ($anchor) {
          $self->anchor2node->{$anchor} = CORE::bless [], 'YAML-anchor2node';
      }
      $implicit ||= $top_implicit;
      $explicit ||= $top_explicit;
      ($top_implicit, $top_explicit) = ('', '');
      if ($alias) {
          $self->die('YAML_PARSE_ERR_NO_ANCHOR', $alias)
            unless defined $self->anchor2node->{$alias};
          if (ref($self->anchor2node->{$alias}) ne 'YAML-anchor2node') {
              $node = $self->anchor2node->{$alias};
          }
          else {
              $node = do {my $sv = "*$alias"};
              push @{$self->anchor2node->{$alias}}, [\$node, $self->line]; 
          }
      }
      elsif ($self->inline =~ /^\{/) {
          $node = $self->_parse_inline_mapping($anchor);
      }
      elsif ($self->inline =~ /^\[/) {
          $node = $self->_parse_inline_seq($anchor);
      }
      elsif ($self->inline =~ /^"/) {
          $node = $self->_parse_inline_double_quoted();
          $node = $self->_unescape($node);
          $node = $self->_parse_implicit($node) if $implicit;
      }
      elsif ($self->inline =~ /^'/) {
          $node = $self->_parse_inline_single_quoted();
          $node = $self->_parse_implicit($node) if $implicit;
      }
      else {
          if ($top) {
              $node = $self->inline;
              $self->inline('');
          }
          else {
              $node = $self->_parse_inline_simple();
          }
          $node = $self->_parse_implicit($node) unless $explicit;
      }
      if ($explicit) {
          $node = $self->_parse_explicit($node, $explicit);
      }
      if ($anchor) {
          if (ref($self->anchor2node->{$anchor}) eq 'YAML-anchor2node') {
              for my $ref (@{$self->anchor2node->{$anchor}}) {
                  ${$ref->[0]} = $node;
                  $self->warn('YAML_LOAD_WARN_UNRESOLVED_ALIAS',
                      $anchor, $ref->[1]);
              }
          }
          $self->anchor2node->{$anchor} = $node;
      }
      return $node;
  }
  
  # Parse the inline YAML mapping into a Perl hash
  sub _parse_inline_mapping {
      my $self = shift;
      my ($anchor) = @_;
      my $node = {};
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_MAP')
        unless $self->{inline} =~ s/^\{\s*//;
      while (not $self->{inline} =~ s/^\s*\}//) {
          my $key = $self->_parse_inline();
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\: \s*//;
          my $value = $self->_parse_inline();
          if (exists $node->{$key}) {
              $self->warn('YAML_LOAD_WARN_DUPLICATE_KEY');
          }
          else {
              $node->{$key} = $value;
          }
          next if $self->inline =~ /^\s*\}/;
          $self->die('YAML_PARSE_ERR_INLINE_MAP')
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline YAML sequence into a Perl array
  sub _parse_inline_seq {
      my $self = shift;
      my ($anchor) = @_;
      my $node = [];
      $self->anchor2node->{$anchor} = $node;
  
      $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE')
        unless $self->{inline} =~ s/^\[\s*//;
      while (not $self->{inline} =~ s/^\s*\]//) {
          my $value = $self->_parse_inline();
          push @$node, $value;
          next if $self->inline =~ /^\s*\]/;
          $self->die('YAML_PARSE_ERR_INLINE_SEQUENCE') 
            unless $self->{inline} =~ s/^\,\s*//;
      }
      return $node;
  }
  
  # Parse the inline double quoted string.
  sub _parse_inline_double_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^"((?:\\"|[^"])*)"\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/\\"/"/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_DOUBLE');
      }
      return $node;
  }
  
  
  # Parse the inline single quoted string.
  sub _parse_inline_single_quoted {
      my $self = shift;
      my $node;
      if ($self->inline =~ /^'((?:''|[^'])*)'\s*(.*)$/) {
          $node = $1;
          $self->inline($2);
          $node =~ s/''/'/g;
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_SINGLE');
      }
      return $node;
  }
  
  # Parse the inline unquoted string and do implicit typing.
  sub _parse_inline_simple {
      my $self = shift;
      my $value;
      if ($self->inline =~ /^(|[^!@#%^&*].*?)(?=[\[\]\{\},]|, |: |- |:\s*$|$)/) {
          $value = $1;
          substr($self->{inline}, 0, length($1)) = '';
      }
      else {
          $self->die('YAML_PARSE_ERR_BAD_INLINE_IMPLICIT', $value);
      }
      return $value;
  }
  
  sub _parse_implicit {
      my $self = shift;
      my ($value) = @_;
      $value =~ s/\s*$//;
      return $value if $value eq '';
      return undef if $value =~ /^~$/;
      return $value
        unless $value =~ /^[\@\`\^]/ or
               $value =~ /^[\-\?]\s/;
      $self->die('YAML_PARSE_ERR_BAD_IMPLICIT', $value);
  }
  
  # Unfold a YAML multiline scalar into a single string.
  sub _parse_unfold {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      my $space = 0;
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content. "\n";
          $self->_parse_next_line(LEAF);
      }
      $node =~ s/^(\S.*)\n(?=\S)/$1 /gm;
      $node =~ s/^(\S.*)\n(\n+\S)/$1$2/gm;
      $node =~ s/\n*\Z// unless $chomp eq '+';
      $node .= "\n" unless $chomp;
      return $node;
  }
  
  # Parse a YAML block style scalar. This is like a Perl here-document.
  sub _parse_block {
      my $self = shift;
      my ($chomp) = @_;
      my $node = '';
      while (not $self->done and $self->indent == $self->offset->[$self->level]) {
          $node .= $self->content . "\n";
          $self->_parse_next_line(LEAF);
      }
      return $node if '+' eq $chomp;
      $node =~ s/\n*\Z/\n/;
      $node =~ s/\n\Z// if $chomp eq '-';
      return $node;
  }
  
  # Handle Perl style '#' comments. Comments must be at the same indentation
  # level as the collection line following them.
  sub _parse_throwaway_comments {
      my $self = shift;
      while (@{$self->lines} and
             $self->lines->[0] =~ m{^\s*(\#|$)}
            ) {
          shift @{$self->lines};
          $self->{line}++;
      }
      $self->eos($self->{done} = not @{$self->lines});
  }
  
  # This is the routine that controls what line is being parsed. It gets called
  # once for each line in the YAML stream.
  #
  # This routine must:
  # 1) Skip past the current line
  # 2) Determine the indentation offset for a new level
  # 3) Find the next _content_ line
  #   A) Skip over any throwaways (Comments/blanks)
  #   B) Set $self->indent, $self->content, $self->line
  # 4) Expand tabs appropriately  
  sub _parse_next_line {
      my $self = shift;
      my ($type) = @_;
      my $level = $self->level;
      my $offset = $self->offset->[$level];
      $self->die('YAML_EMIT_ERR_BAD_LEVEL') unless defined $offset;
      shift @{$self->lines};
      $self->eos($self->{done} = not @{$self->lines});
      return if $self->eos;
      $self->{line}++;
  
      # Determine the offset for a new leaf node
      if ($self->preface =~
          qr/(?:^|\s)(?:$FOLD_CHAR|$LIT_CHAR_RX)(?:-|\+)?(\d*)\s*$/
         ) {
          $self->die('YAML_PARSE_ERR_ZERO_INDENT')
            if length($1) and $1 == 0;
          $type = LEAF;
          if (length($1)) {
              $self->offset->[$level + 1] = $offset + $1;
          }
          else {
              # First get rid of any comments.
              while (@{$self->lines} && ($self->lines->[0] =~ /^\s*#/)) {
                  $self->lines->[0] =~ /^( *)/ or die;
                  last unless length($1) <= $offset;
                  shift @{$self->lines};
                  $self->{line}++;
              }
              $self->eos($self->{done} = not @{$self->lines});
              return if $self->eos;
              if ($self->lines->[0] =~ /^( *)\S/ and length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
      # Determine the offset for a new collection level
      elsif ($type == COLLECTION and 
             $self->preface =~ /^(\s*(\!\S*|\&\S+))*\s*$/) {
          $self->_parse_throwaway_comments();
          if ($self->eos) {
              $self->offset->[$level+1] = $offset + 1;
              return;
          }
          else {
              $self->lines->[0] =~ /^( *)\S/ or die;
              if (length($1) > $offset) {
                  $self->offset->[$level+1] = length($1);
              }
              else {
                  $self->offset->[$level+1] = $offset + 1;
              }
          }
          $offset = $self->offset->[++$level];
      }
          
      if ($type == LEAF) {
          while (@{$self->lines} and
                 $self->lines->[0] =~ m{^( *)(\#)} and
                 length($1) < $offset
                ) {
              shift @{$self->lines};
              $self->{line}++;
          }
          $self->eos($self->{done} = not @{$self->lines});
      }
      else {
          $self->_parse_throwaway_comments();
      }
      return if $self->eos; 
      
      if ($self->lines->[0] =~ /^---(\s|$)/) {
          $self->done(1);
          return;
      }
      if ($type == LEAF and 
          $self->lines->[0] =~ /^ {$offset}(.*)$/
         ) {
          $self->indent($offset);
          $self->content($1);
      }
      elsif ($self->lines->[0] =~ /^\s*$/) {
          $self->indent($offset);
          $self->content('');
      }
      else {
          $self->lines->[0] =~ /^( *)(\S.*)$/;
          while ($self->offset->[$level] > length($1)) {
              $level--;
          }
          $self->die('YAML_PARSE_ERR_INCONSISTENT_INDENTATION') 
            if $self->offset->[$level] != length($1);
          $self->indent(length($1));
          $self->content($2);
      }
      $self->die('YAML_PARSE_ERR_INDENTATION')
        if $self->indent - $offset > 1;
  }
  
  #==============================================================================
  # Utility subroutines.
  #==============================================================================
  
  # Printable characters for escapes
  my %unescapes = (
     0 => "\x00",
     a => "\x07",
     t => "\x09",
     n => "\x0a",
     'v' => "\x0b", # Potential v-string error on 5.6.2 if not quoted
     f => "\x0c",
     r => "\x0d",
     e => "\x1b",
     '\\' => '\\',
    );
     
  # Transform all the backslash style escape characters to their literal meaning
  sub _unescape {
      my $self = shift;
      my ($node) = @_;
      $node =~ s/\\([never\\fart0]|x([0-9a-fA-F]{2}))/
                (length($1)>1)?pack("H2",$2):$unescapes{$1}/gex;
      return $node;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Loader - YAML class for loading Perl objects to YAML
  
  =head1 SYNOPSIS
  
      use YAML::Loader;
      my $loader = YAML::Loader->new;
      my $hash = $loader->load(<<'...');
      foo: bar
      ...
  
  =head1 DESCRIPTION
  
  YAML::Loader is the module that YAML.pm used to deserialize YAML to Perl
  objects. It is fully object oriented and usable on its own.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER

$fatpacked{"YAML/Loader/Base.pm"} = <<'YAML_LOADER_BASE';
  package YAML::Loader::Base;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  has load_code     => default => sub {0};
  has stream        => default => sub {''};
  has document      => default => sub {0};
  has line          => default => sub {0};
  has documents     => default => sub {[]};
  has lines         => default => sub {[]};
  has eos           => default => sub {0};
  has done          => default => sub {0};
  has anchor2node   => default => sub {{}};
  has level         => default => sub {0};
  has offset        => default => sub {[]};
  has preface       => default => sub {''};
  has content       => default => sub {''};
  has indent        => default => sub {0};
  has major_version => default => sub {0};
  has minor_version => default => sub {0};
  has inline        => default => sub {''};
  
  sub set_global_options {
      my $self = shift;
      $self->load_code($YAML::LoadCode || $YAML::UseCode)
        if defined $YAML::LoadCode or defined $YAML::UseCode;
  }
  
  sub load {
      die 'load() not implemented in this class.';
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Loader::Base - Base class for YAML Loader classes
  
  =head1 SYNOPSIS
  
      package YAML::Loader::Something;
      use YAML::Loader::Base -base;
  
  =head1 DESCRIPTION
  
  YAML::Loader::Base is a base class for creating YAML loader classes.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_LOADER_BASE

$fatpacked{"YAML/Marshall.pm"} = <<'YAML_MARSHALL';
  use strict;
  use warnings;
  package YAML::Marshall;
  
  our $VERSION = '0.84';
  
  use YAML::Node ();
  
  sub import {
      my $class = shift;
      no strict 'refs';
      my $package = caller;
      unless (grep { $_ eq $class} @{$package . '::ISA'}) {
          push @{$package . '::ISA'}, $class;
      }
  
      my $tag = shift;
      if ( $tag ) {
          no warnings 'once';
          $YAML::TagClass->{$tag} = $package;
          ${$package . "::YamlTag"} = $tag;
      }
  }
  
  sub yaml_dump {
      my $self = shift;
      no strict 'refs';
      my $tag = ${ref($self) . "::YamlTag"} || 'perl/' . ref($self);
      $self->yaml_node($self, $tag);
  }
  
  sub yaml_load {
      my ($class, $node) = @_;
      if (my $ynode = $class->yaml_ynode($node)) {
          $node = $ynode->{NODE};
      }
      bless $node, $class;
  }
  
  sub yaml_node {
      shift;
      YAML::Node->new(@_);
  }
  
  sub yaml_ynode {
      shift;
      YAML::Node::ynode(@_);
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Marshall - YAML marshalling class you can mixin to your classes
  
  =head1 SYNOPSIS
  
      package Bar;
      use Foo -base;
      use YAML::Marshall -mixin;
  
  =head1 DESCRIPTION
  
  For classes that want to handle their own YAML serialization.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_MARSHALL

$fatpacked{"YAML/Mo.pm"} = <<'YAML_MO';
  package YAML::Mo; $VERSION = '0.84';
  # use Mo qw[builder default import];
  #   The following line of code was produced from the previous line by
  #   Mo::Inline version 0.31
  no warnings;my$M=__PACKAGE__.'::';*{$M.Object::new}=sub{bless{@_[1..$#_]},$_[0]};*{$M.import}=sub{import warnings;$^H|=1538;my($P,%e,%o)=caller.'::';shift;eval"no Mo::$_",&{$M.$_.::e}($P,\%e,\%o,\@_)for@_;return if$e{M};%e=(extends,sub{eval"no $_[0]()";@{$P.ISA}=$_[0]},has,sub{my$n=shift;my$m=sub{$#_?$_[0]{$n}=$_[1]:$_[0]{$n}};$m=$o{$_}->($m,$n,@_)for sort keys%o;*{$P.$n}=$m},%e,);*{$P.$_}=$e{$_}for keys%e;@{$P.ISA}=$M.Object};*{$M.'builder::e'}=sub{my($P,$e,$o)=@_;$o->{builder}=sub{my($m,$n,%a)=@_;my$b=$a{builder}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$_[0]->$b:$m->(@_)}}};*{$M.'default::e'}=sub{my($P,$e,$o)=@_;$o->{default}=sub{my($m,$n,%a)=@_;$a{default}or return$m;sub{$#_?$m->(@_):!exists$_[0]{$n}?$_[0]{$n}=$a{default}->(@_):$m->(@_)}}};my$i=\&import;*{$M.import}=sub{(@_==2 and not $_[1])?pop@_:@_==1?push@_,grep!/import/,@f:();goto&$i};@f=qw[builder default import];use strict;use warnings;
  
  our $DumperModule = 'Data::Dumper';
  
  my ($_new_error, $_info, $_scalar_info);
  
  no strict 'refs';
  *{$M.'Object::die'} = sub {
      my $self = shift;
      my $error = $self->$_new_error(@_);
      $error->type('Error');
      Carp::croak($error->format_message);
  };
  
  *{$M.'Object::warn'} = sub {
      my $self = shift;
      return unless $^W;
      my $error = $self->$_new_error(@_);
      $error->type('Warning');
      Carp::cluck($error->format_message);
  };
  
  # This code needs to be refactored to be simpler and more precise, and no,
  # Scalar::Util doesn't DWIM.
  #
  # Can't handle:
  # * blessed regexp
  *{$M.'Object::node_info'} = sub {
      my $self = shift;
      my $stringify = $_[1] || 0;
      my ($class, $type, $id) =
          ref($_[0])
          ? $stringify
            ? &$_info("$_[0]")
            : do {
                require overload;
                my @info = &$_info(overload::StrVal($_[0]));
                if (ref($_[0]) eq 'Regexp') {
                    @info[0, 1] = (undef, 'REGEXP');
                }
                @info;
            }
          : &$_scalar_info($_[0]);
      ($class, $type, $id) = &$_scalar_info("$_[0]")
          unless $id;
      return wantarray ? ($class, $type, $id) : $id;
  };
  
  #-------------------------------------------------------------------------------
  $_info = sub {
      return (($_[0]) =~ qr{^(?:(.*)\=)?([^=]*)\(([^\(]*)\)$}o);
  };
  
  $_scalar_info = sub {
      my $id = 'undef';
      if (defined $_[0]) {
          \$_[0] =~ /\((\w+)\)$/o or CORE::die();
          $id = "$1-S";
      }
      return (undef, undef, $id);
  };
  
  $_new_error = sub {
      require Carp;
      my $self = shift;
      require YAML::Error;
  
      my $code = shift || 'unknown error';
      my $error = YAML::Error->new(code => $code);
      $error->line($self->line) if $self->can('line');
      $error->document($self->document) if $self->can('document');
      $error->arguments([@_]);
      return $error;
  };
  
  1;
YAML_MO

$fatpacked{"YAML/Node.pm"} = <<'YAML_NODE';
  use strict;
  use warnings;
  package YAML::Node;
  
  our $VERSION = '0.84';
  
  use YAML::Tag;
  require YAML::Mo;
  
  use Exporter;
  our @ISA     = qw(Exporter YAML::Mo::Object);
  our @EXPORT  = qw(ynode);
  
  sub ynode {
      my $self;
      if (ref($_[0]) eq 'HASH') {
  	$self = tied(%{$_[0]});
      }
      elsif (ref($_[0]) eq 'ARRAY') {
  	$self = tied(@{$_[0]});
      }
      elsif (ref(\$_[0]) eq 'GLOB') {
  	$self = tied(*{$_[0]});
      }
      else {
  	$self = tied($_[0]);
      }
      return (ref($self) =~ /^yaml_/) ? $self : undef;
  }
  
  sub new {
      my ($class, $node, $tag) = @_;
      my $self;
      $self->{NODE} = $node;
      my (undef, $type) = YAML::Mo::Object->node_info($node);
      $self->{KIND} = (not defined $type) ? 'scalar' :
                      ($type eq 'ARRAY') ? 'sequence' :
  		    ($type eq 'HASH') ? 'mapping' :
  		    $class->die("Can't create YAML::Node from '$type'");
      tag($self, ($tag || ''));
      if ($self->{KIND} eq 'scalar') {
  	yaml_scalar->new($self, $_[1]);
  	return \ $_[1];
      }
      my $package = "yaml_" . $self->{KIND};    
      $package->new($self)
  }
  
  sub node { $_->{NODE} }
  sub kind { $_->{KIND} }
  sub tag {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{TAG} = YAML::Tag->new($value);
  	return $self;
      }
      else {
         return $self->{TAG};
      }
  }
  sub keys {
      my ($self, $value) = @_;
      if (defined $value) {
         	$self->{KEYS} = $value;
  	return $self;
      }
      else {
         return $self->{KEYS};
      }
  }
  
  #==============================================================================
  package yaml_scalar;
  
  @yaml_scalar::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      tie $_[2], $class, $self;
  }
  
  sub TIESCALAR {
      my ($class, $self) = @_;
      bless $self, $class;
      $self
  }
  
  sub FETCH {
      my ($self) = @_;
      $self->{NODE}
  }
  
  sub STORE {
      my ($self, $value) = @_;
      $self->{NODE} = $value
  }
  
  #==============================================================================
  package yaml_sequence;
  
  @yaml_sequence::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      my $new;
      tie @$new, $class, $self;
      $new
  }
  
  sub TIEARRAY {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCHSIZE {
      my ($self) = @_;
      scalar @{$self->{NODE}};
  }
  
  sub FETCH {
      my ($self, $index) = @_;
      $self->{NODE}[$index]
  }
  
  sub STORE {
      my ($self, $index, $value) = @_;
      $self->{NODE}[$index] = $value
  }
  
  sub undone {
      die "Not implemented yet"; # XXX
  }
  
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS = 
  *STORESIZE = *POP = *PUSH = *SHIFT = *UNSHIFT = *SPLICE = *DELETE = *EXISTS = 
  *undone; # XXX Must implement before release
  
  #==============================================================================
  package yaml_mapping;
  
  @yaml_mapping::ISA = qw(YAML::Node);
  
  sub new {
      my ($class, $self) = @_;
      @{$self->{KEYS}} = sort keys %{$self->{NODE}}; 
      my $new;
      tie %$new, $class, $self;
      $new
  }
  
  sub TIEHASH {
      my ($class, $self) = @_;
      bless $self, $class
  }
  
  sub FETCH {
      my ($self, $key) = @_;
      if (exists $self->{NODE}{$key}) {
  	return (grep {$_ eq $key} @{$self->{KEYS}}) 
  	       ? $self->{NODE}{$key} : undef;
      }
      return $self->{HASH}{$key};
  }
  
  sub STORE {
      my ($self, $key, $value) = @_;
      if (exists $self->{NODE}{$key}) {
  	$self->{NODE}{$key} = $value;
      }
      elsif (exists $self->{HASH}{$key}) {
  	$self->{HASH}{$key} = $value;
      }
      else {
  	if (not grep {$_ eq $key} @{$self->{KEYS}}) {
  	    push(@{$self->{KEYS}}, $key);
  	}
  	$self->{HASH}{$key} = $value;
      }
      $value
  }
  
  sub DELETE {
      my ($self, $key) = @_;
      my $return;
      if (exists $self->{NODE}{$key}) {
  	$return = $self->{NODE}{$key};
      }
      elsif (exists $self->{HASH}{$key}) {
  	$return = delete $self->{NODE}{$key};
      }
      for (my $i = 0; $i < @{$self->{KEYS}}; $i++) {
  	if ($self->{KEYS}[$i] eq $key) {
  	    splice(@{$self->{KEYS}}, $i, 1);
  	}
      }
      return $return;
  }
  
  sub CLEAR {
      my ($self) = @_;
      @{$self->{KEYS}} = ();
      %{$self->{HASH}} = ();
  }
  
  sub FIRSTKEY {
      my ($self) = @_;
      $self->{ITER} = 0;
      $self->{KEYS}[0]
  }
  
  sub NEXTKEY {
      my ($self) = @_;
      $self->{KEYS}[++$self->{ITER}]
  }
  
  sub EXISTS {
      my ($self, $key) = @_;
      exists $self->{NODE}{$key}
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Node - A generic data node that encapsulates YAML information
  
  =head1 SYNOPSIS
  
      use YAML;
      use YAML::Node;
      
      my $ynode = YAML::Node->new({}, 'ingerson.com/fruit');
      %$ynode = qw(orange orange apple red grape green);
      print Dump $ynode;
  
  yields:
  
      --- !ingerson.com/fruit
      orange: orange
      apple: red
      grape: green
  
  =head1 DESCRIPTION
  
  A generic node in YAML is similar to a plain hash, array, or scalar node
  in Perl except that it must also keep track of its type. The type is a
  URI called the YAML type tag.
  
  YAML::Node is a class for generating and manipulating these containers.
  A YAML node (or ynode) is a tied hash, array or scalar. In most ways it
  behaves just like the plain thing. But you can assign and retrieve and
  YAML type tag URI to it. For the hash flavor, you can also assign the
  order that the keys will be retrieved in. By default a ynode will offer
  its keys in the same order that they were assigned.
  
  YAML::Node has a class method call new() that will return a ynode. You
  pass it a regular node and an optional type tag. After that you can
  use it like a normal Perl node, but when you YAML::Dump it, the magical
  properties will be honored.
  
  This is how you can control the sort order of hash keys during a YAML
  serialization. By default, YAML sorts keys alphabetically. But notice
  in the above example that the keys were Dumped in the same order they
  were assigned.
  
  YAML::Node exports a function called ynode(). This function returns the tied object so that you can call special methods on it like ->keys().
  
  keys() works like this:
  
      use YAML;
      use YAML::Node;
      
      %$node = qw(orange orange apple red grape green);
      $ynode = YAML::Node->new($node);
      ynode($ynode)->keys(['grape', 'apple']);
      print Dump $ynode;
  
  produces:
  
      ---
      grape: green
      apple: red
  
  It tells the ynode which keys and what order to use.
  
  ynodes will play a very important role in how programs use YAML. They
  are the foundation of how a Perl class can marshall the Loading and
  Dumping of its objects.
  
  The upcoming versions of YAML.pm will have much more information on this.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  Copyright (c) 2002. Brian Ingerson. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_NODE

$fatpacked{"YAML/Tag.pm"} = <<'YAML_TAG';
  use strict;
  use warnings;
  package YAML::Tag;
  
  our $VERSION = '0.84';
  
  use overload '""' => sub { ${$_[0]} };
  
  sub new {
      my ($class, $self) = @_;
      bless \$self, $class
  }
  
  sub short {
      ${$_[0]}
  }
  
  sub canonical {
      ${$_[0]}
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Tag - Tag URI object class for YAML
  
  =head1 SYNOPSIS
  
      use YAML::Tag;
  
  =head1 DESCRIPTION
  
  Used by YAML::Node.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TAG

$fatpacked{"YAML/Types.pm"} = <<'YAML_TYPES';
  package YAML::Types;
  use YAML::Mo;
  
  our $VERSION = '0.84';
  
  use YAML::Node;
  
  # XXX These classes and their APIs could still use some refactoring,
  # but at least they work for now.
  #-------------------------------------------------------------------------------
  package YAML::Type::blessed;
  use YAML::Mo; # XXX
  
  sub yaml_dump {
      my $self = shift;
      my ($value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      no strict 'refs';
      my $kind = lc($type) . ':';
      my $tag = ${$class . '::ClassTag'} ||
                "!perl/$kind$class";
      if ($type eq 'REF') {
          YAML::Node->new(
              {(&YAML::VALUE, ${$_[0]})}, $tag
          );
      }
      elsif ($type eq 'SCALAR') {
          $_[1] = $$value;
          YAML::Node->new($_[1], $tag);
      } else {
          YAML::Node->new($value, $tag);
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::undef;
  
  sub yaml_dump {
      my $self = shift;
  }
  
  sub yaml_load {
      my $self = shift;
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::glob;
  
  sub yaml_dump {
      my $self = shift;
      my $ynode = YAML::Node->new({}, '!perl/glob:');
      for my $type (qw(PACKAGE NAME SCALAR ARRAY HASH CODE IO)) {
          my $value = *{$_[0]}{$type};
          $value = $$value if $type eq 'SCALAR';
          if (defined $value) {
              if ($type eq 'IO') {
                  my @stats = qw(device inode mode links uid gid rdev size
                                 atime mtime ctime blksize blocks);
                  undef $value;
                  $value->{stat} = YAML::Node->new({});
                  if ($value->{fileno} = fileno(*{$_[0]})) {
                      local $^W;
                      map {$value->{stat}{shift @stats} = $_} stat(*{$_[0]});
                      $value->{tell} = tell(*{$_[0]});
                  }
              }
              $ynode->{$type} = $value; 
          }
      }
      return $ynode;
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      my ($name, $package);
      if (defined $node->{NAME}) {
          $name = $node->{NAME};
          delete $node->{NAME};
      }
      else {
          $loader->warn('YAML_LOAD_WARN_GLOB_NAME');
          return undef;
      }
      if (defined $node->{PACKAGE}) {
          $package = $node->{PACKAGE};
          delete $node->{PACKAGE};
      }
      else {
          $package = 'main';
      }
      no strict 'refs';
      if (exists $node->{SCALAR}) {
          *{"${package}::$name"} = \$node->{SCALAR};
          delete $node->{SCALAR};
      }
      for my $elem (qw(ARRAY HASH CODE IO)) {
          if (exists $node->{$elem}) {
              if ($elem eq 'IO') {
                  $loader->warn('YAML_LOAD_WARN_GLOB_IO');
                  delete $node->{IO};
                  next;
              }
              *{"${package}::$name"} = $node->{$elem};
              delete $node->{$elem};
          }
      }
      for my $elem (sort keys %$node) {
          $loader->warn('YAML_LOAD_WARN_BAD_GLOB_ELEM', $elem);
      }
      return *{"${package}::$name"};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::code;
  
  my $dummy_warned = 0; 
  my $default = '{ "DUMMY" }';
  
  sub yaml_dump {
      my $self = shift;
      my $code;
      my ($dumpflag, $value) = @_;
      my ($class, $type) = YAML::Mo::Object->node_info($value);
      my $tag = "!perl/code";
      $tag .= ":$class" if defined $class;
      if (not $dumpflag) {
          $code = $default;
      }
      else {
          bless $value, "CODE" if $class;
          eval { use B::Deparse };
          return if $@;
          my $deparse = B::Deparse->new();
          eval {
              local $^W = 0;
              $code = $deparse->coderef2text($value);
          };
          if ($@) {
              warn YAML::YAML_DUMP_WARN_DEPARSE_FAILED() if $^W;
              $code = $default;
          }
          bless $value, $class if $class;
          chomp $code;
          $code .= "\n";
      }
      $_[2] = $code;
      YAML::Node->new($_[2], $tag);
  }    
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      if ($loader->load_code) {
          my $code = eval "package main; sub $node";
          if ($@) {
              $loader->warn('YAML_LOAD_WARN_PARSE_CODE', $@);
              return sub {};
          }
          else {
              CORE::bless $code, $class if $class;
              return $code;
          }
      }
      else {
          return CORE::bless sub {}, $class if $class;
          return sub {};
      }
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::ref;
  
  sub yaml_dump {
      my $self = shift;
      YAML::Node->new({(&YAML::VALUE, ${$_[0]})}, '!perl/ref')
  }
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class, $loader) = @_;
      $loader->die('YAML_LOAD_ERR_NO_DEFAULT_VALUE', 'ptr')
        unless exists $node->{&YAML::VALUE};
      return \$node->{&YAML::VALUE};
  }
  
  #-------------------------------------------------------------------------------
  package YAML::Type::regexp;
  
  # XXX Be sure to handle blessed regexps (if possible)
  sub yaml_dump {
      die "YAML::Type::regexp::yaml_dump not currently implemented";
  }
  
  use constant _QR_TYPES => {
      '' => sub { qr{$_[0]} },
      x => sub { qr{$_[0]}x },
      i => sub { qr{$_[0]}i },
      s => sub { qr{$_[0]}s },
      m => sub { qr{$_[0]}m },
      ix => sub { qr{$_[0]}ix },
      sx => sub { qr{$_[0]}sx },
      mx => sub { qr{$_[0]}mx },
      si => sub { qr{$_[0]}si },
      mi => sub { qr{$_[0]}mi },
      ms => sub { qr{$_[0]}sm },
      six => sub { qr{$_[0]}six },
      mix => sub { qr{$_[0]}mix },
      msx => sub { qr{$_[0]}msx },
      msi => sub { qr{$_[0]}msi },
      msix => sub { qr{$_[0]}msix },
  };
  
  sub yaml_load {
      my $self = shift;
      my ($node, $class) = @_;
      return qr{$node} unless $node =~ /^\(\?([\^\-xism]*):(.*)\)\z/s;
      my ($flags, $re) = ($1, $2);
      $flags =~ s/-.*//;
      $flags =~ s/^\^//;
      my $sub = _QR_TYPES->{$flags} || sub { qr{$_[0]} };
      my $qr = &$sub($re);
      bless $qr, $class if length $class;
      return $qr;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  YAML::Types - Marshall Perl internal data types to/from YAML
  
  =head1 SYNOPSIS
  
      $::foo = 42;
      print YAML::Dump(*::foo);
  
      print YAML::Dump(qr{match me});
  
  =head1 DESCRIPTION
  
  This module has the helper classes for transferring objects,
  subroutines, references, globs, regexps and file handles to and
  from YAML.
  
  =head1 AUTHOR
  
  Ingy dt Net <ingy@cpan.org>
  
  =head1 COPYRIGHT
  
  Copyright (c) 2006, 2011-2012. Ingy dt Net. All rights reserved.
  
  This program is free software; you can redistribute it and/or modify it
  under the same terms as Perl itself.
  
  See L<http://www.perl.com/perl/misc/Artistic.html>
  
  =cut
YAML_TYPES

$fatpacked{"autodie.pm"} = <<'AUTODIE';
  package autodie;
  use 5.008;
  use strict;
  use warnings;
  
  use Fatal ();
  our @ISA = qw(Fatal);
  our $VERSION;
  
  # ABSTRACT: Replace functions with ones that succeed or die with lexical scope
  
  BEGIN {
      our $VERSION = '2.20'; # VERSION: Generated by DZP::OurPkg::Version
  }
  
  use constant ERROR_WRONG_FATAL => q{
  Incorrect version of Fatal.pm loaded by autodie.
  
  The autodie pragma uses an updated version of Fatal to do its
  heavy lifting.  We seem to have loaded Fatal version %s, which is
  probably the version that came with your version of Perl.  However
  autodie needs version %s, which would have come bundled with
  autodie.
  
  You may be able to solve this problem by adding the following
  line of code to your main program, before any use of Fatal or
  autodie.
  
      use lib "%s";
  
  };
  
  # We have to check we've got the right version of Fatal before we
  # try to compile the rest of our code, lest we use a constant
  # that doesn't exist.
  
  BEGIN {
  
      # If we have the wrong Fatal, then we've probably loaded the system
      # one, not our own.  Complain, and give a useful hint. ;)
  
      if ($Fatal::VERSION ne $VERSION) {
          my $autodie_path = $INC{'autodie.pm'};
  
          $autodie_path =~ s/autodie\.pm//;
  
          require Carp;
  
          Carp::croak sprintf(
              ERROR_WRONG_FATAL, $Fatal::VERSION, $VERSION, $autodie_path
          );
      }
  }
  
  # When passing args to Fatal we want to keep the first arg
  # (our package) in place.  Hence the splice.
  
  sub import {
          splice(@_,1,0,Fatal::LEXICAL_TAG);
          goto &Fatal::import;
  }
  
  sub unimport {
          splice(@_,1,0,Fatal::LEXICAL_TAG);
          goto &Fatal::unimport;
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie - Replace functions with ones that succeed or die with lexical scope
  
  =head1 SYNOPSIS
  
      use autodie;            # Recommended: implies 'use autodie qw(:default)'
  
      use autodie qw(:all);   # Recommended more: defaults and system/exec.
  
      use autodie qw(open close);   # open/close succeed or die
  
      open(my $fh, "<", $filename); # No need to check!
  
      {
          no autodie qw(open);          # open failures won't die
          open(my $fh, "<", $filename); # Could fail silently!
          no autodie;                   # disable all autodies
      }
  
  =head1 DESCRIPTION
  
          bIlujDI' yIchegh()Qo'; yIHegh()!
  
          It is better to die() than to return() in failure.
  
                  -- Klingon programming proverb.
  
  The C<autodie> pragma provides a convenient way to replace functions
  that normally return false on failure with equivalents that throw
  an exception on failure.
  
  The C<autodie> pragma has I<lexical scope>, meaning that functions
  and subroutines altered with C<autodie> will only change their behaviour
  until the end of the enclosing block, file, or C<eval>.
  
  If C<system> is specified as an argument to C<autodie>, then it
  uses L<IPC::System::Simple> to do the heavy lifting.  See the
  description of that module for more information.
  
  =head1 EXCEPTIONS
  
  Exceptions produced by the C<autodie> pragma are members of the
  L<autodie::exception> class.  The preferred way to work with
  these exceptions under Perl 5.10 is as follows:
  
      use feature qw(switch);
  
      eval {
          use autodie;
  
          open(my $fh, '<', $some_file);
  
          my @records = <$fh>;
  
          # Do things with @records...
  
          close($fh);
  
      };
  
      given ($@) {
          when (undef)   { say "No error";                    }
          when ('open')  { say "Error from open";             }
          when (':io')   { say "Non-open, IO error.";         }
          when (':all')  { say "All other autodie errors."    }
          default        { say "Not an autodie error at all." }
      }
  
  Under Perl 5.8, the C<given/when> structure is not available, so the
  following structure may be used:
  
      eval {
          use autodie;
  
          open(my $fh, '<', $some_file);
  
          my @records = <$fh>;
  
          # Do things with @records...
  
          close($fh);
      };
  
      if ($@ and $@->isa('autodie::exception')) {
          if ($@->matches('open')) { print "Error from open\n";   }
          if ($@->matches(':io' )) { print "Non-open, IO error."; }
      } elsif ($@) {
          # A non-autodie exception.
      }
  
  See L<autodie::exception> for further information on interrogating
  exceptions.
  
  =head1 CATEGORIES
  
  Autodie uses a simple set of categories to group together similar
  built-ins.  Requesting a category type (starting with a colon) will
  enable autodie for all built-ins beneath that category.  For example,
  requesting C<:file> will enable autodie for C<close>, C<fcntl>,
  C<fileno>, C<open> and C<sysopen>.
  
  The categories are currently:
  
      :all
          :default
              :io
                  read
                  seek
                  sysread
                  sysseek
                  syswrite
                  :dbm
                      dbmclose
                      dbmopen
                  :file
                      binmode
                      close
                      chmod
                      chown
                      fcntl
                      fileno
                      flock
                      ioctl
                      open
                      sysopen
                      truncate
                  :filesys
                      chdir
                      closedir
                      opendir
                      link
                      mkdir
                      readlink
                      rename
                      rmdir
                      symlink
                      unlink
                  :ipc
                      pipe
                      :msg
                          msgctl
                          msgget
                          msgrcv
                          msgsnd
                      :semaphore
                          semctl
                          semget
                          semop
                      :shm
                          shmctl
                          shmget
                          shmread
                  :socket
                      accept
                      bind
                      connect
                      getsockopt
                      listen
                      recv
                      send
                      setsockopt
                      shutdown
                      socketpair
              :threads
                  fork
          :system
              system
              exec
  
  
  Note that while the above category system is presently a strict
  hierarchy, this should not be assumed.
  
  A plain C<use autodie> implies C<use autodie qw(:default)>.  Note that
  C<system> and C<exec> are not enabled by default.  C<system> requires
  the optional L<IPC::System::Simple> module to be installed, and enabling
  C<system> or C<exec> will invalidate their exotic forms.  See L</BUGS>
  below for more details.
  
  The syntax:
  
      use autodie qw(:1.994);
  
  allows the C<:default> list from a particular version to be used.  This
  provides the convenience of using the default methods, but the surety
  that no behavioral changes will occur if the C<autodie> module is
  upgraded.
  
  C<autodie> can be enabled for all of Perl's built-ins, including
  C<system> and C<exec> with:
  
      use autodie qw(:all);
  
  =head1 FUNCTION SPECIFIC NOTES
  
  =head2 flock
  
  It is not considered an error for C<flock> to return false if it fails
  due to an C<EWOULDBLOCK> (or equivalent) condition.  This means one can
  still use the common convention of testing the return value of
  C<flock> when called with the C<LOCK_NB> option:
  
      use autodie;
  
      if ( flock($fh, LOCK_EX | LOCK_NB) ) {
          # We have a lock
      }
  
  Autodying C<flock> will generate an exception if C<flock> returns
  false with any other error.
  
  =head2 system/exec
  
  The C<system> built-in is considered to have failed in the following
  circumstances:
  
  =over 4
  
  =item *
  
  The command does not start.
  
  =item *
  
  The command is killed by a signal.
  
  =item *
  
  The command returns a non-zero exit value (but see below).
  
  =back
  
  On success, the autodying form of C<system> returns the I<exit value>
  rather than the contents of C<$?>.
  
  Additional allowable exit values can be supplied as an optional first
  argument to autodying C<system>:
  
      system( [ 0, 1, 2 ], $cmd, @args);  # 0,1,2 are good exit values
  
  C<autodie> uses the L<IPC::System::Simple> module to change C<system>.
  See its documentation for further information.
  
  Applying C<autodie> to C<system> or C<exec> causes the exotic
  forms C<system { $cmd } @args > or C<exec { $cmd } @args>
  to be considered a syntax error until the end of the lexical scope.
  If you really need to use the exotic form, you can call C<CORE::system>
  or C<CORE::exec> instead, or use C<no autodie qw(system exec)> before
  calling the exotic form.
  
  =head1 GOTCHAS
  
  Functions called in list context are assumed to have failed if they
  return an empty list, or a list consisting only of a single undef
  element.
  
  =head1 DIAGNOSTICS
  
  =over 4
  
  =item :void cannot be used with lexical scope
  
  The C<:void> option is supported in L<Fatal>, but not
  C<autodie>.  To workaround this, C<autodie> may be explicitly disabled until
  the end of the current block with C<no autodie>.
  To disable autodie for only a single function (eg, open)
  use C<no autodie qw(open)>.
  
  C<autodie> performs no checking of called context to determine whether to throw
  an exception; the explicitness of error handling with C<autodie> is a deliberate
  feature.
  
  =item No user hints defined for %s
  
  You've insisted on hints for user-subroutines, either by pre-pending
  a C<!> to the subroutine name itself, or earlier in the list of arguments
  to C<autodie>.  However the subroutine in question does not have
  any hints available.
  
  =back
  
  See also L<Fatal/DIAGNOSTICS>.
  
  =head1 BUGS
  
  "Used only once" warnings can be generated when C<autodie> or C<Fatal>
  is used with package filehandles (eg, C<FILE>).  Scalar filehandles are
  strongly recommended instead.
  
  When using C<autodie> or C<Fatal> with user subroutines, the
  declaration of those subroutines must appear before the first use of
  C<Fatal> or C<autodie>, or have been exported from a module.
  Attempting to use C<Fatal> or C<autodie> on other user subroutines will
  result in a compile-time error.
  
  Due to a bug in Perl, C<autodie> may "lose" any format which has the
  same name as an autodying built-in or function.
  
  C<autodie> may not work correctly if used inside a file with a
  name that looks like a string eval, such as F<eval (3)>.
  
  =head2 autodie and string eval
  
  Due to the current implementation of C<autodie>, unexpected results
  may be seen when used near or with the string version of eval.
  I<None of these bugs exist when using block eval>.
  
  Under Perl 5.8 only, C<autodie> I<does not> propagate into string C<eval>
  statements, although it can be explicitly enabled inside a string
  C<eval>.
  
  Under Perl 5.10 only, using a string eval when C<autodie> is in
  effect can cause the autodie behaviour to leak into the surrounding
  scope.  This can be worked around by using a C<no autodie> at the
  end of the scope to explicitly remove autodie's effects, or by
  avoiding the use of string eval.
  
  I<None of these bugs exist when using block eval>.  The use of
  C<autodie> with block eval is considered good practice.
  
  =head2 REPORTING BUGS
  
  Please report bugs via the CPAN Request Tracker at
  L<http://rt.cpan.org/NoAuth/Bugs.html?Dist=autodie>.
  
  =head1 FEEDBACK
  
  If you find this module useful, please consider rating it on the
  CPAN Ratings service at
  L<http://cpanratings.perl.org/rate?distribution=autodie> .
  
  The module author loves to hear how C<autodie> has made your life
  better (or worse).  Feedback can be sent to
  E<lt>pjf@perltraining.com.auE<gt>.
  
  =head1 AUTHOR
  
  Copyright 2008-2009, Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<Fatal>, L<autodie::exception>, L<autodie::hints>, L<IPC::System::Simple>
  
  I<Perl tips, autodie> at
  L<http://perltraining.com.au/tips/2008-08-20.html>
  
  =head1 ACKNOWLEDGEMENTS
  
  Mark Reed and Roland Giersig -- Klingon translators.
  
  See the F<AUTHORS> file for full credits.  The latest version of this
  file can be found at
  L<https://github.com/pjf/autodie/tree/master/AUTHORS> .
  
  =cut
AUTODIE

$fatpacked{"autodie/exception.pm"} = <<'AUTODIE_EXCEPTION';
  package autodie::exception;
  use 5.008;
  use strict;
  use warnings;
  use Carp qw(croak);
  
  our $VERSION = '2.20'; # VERSION: Generated by DZP::OurPkg:Version
  # ABSTRACT: Exceptions from autodying functions.
  
  our $DEBUG = 0;
  
  use overload
      q{""} => "stringify"
  ;
  
  # Overload smart-match only if we're using 5.10
  
  use if ($] >= 5.010), overload => '~~'  => "matches";
  
  my $PACKAGE = __PACKAGE__;  # Useful to have a scalar for hash keys.
  
  =head1 NAME
  
  autodie::exception - Exceptions from autodying functions.
  
  =head1 SYNOPSIS
  
      eval {
          use autodie;
  
          open(my $fh, '<', 'some_file.txt');
  
          ...
      };
  
      if (my $E = $@) {
          say "Ooops!  ",$E->caller," had problems: $@";
      }
  
  
  =head1 DESCRIPTION
  
  When an L<autodie> enabled function fails, it generates an
  C<autodie::exception> object.  This can be interrogated to
  determine further information about the error that occurred.
  
  This document is broken into two sections; those methods that
  are most useful to the end-developer, and those methods for
  anyone wishing to subclass or get very familiar with
  C<autodie::exception>.
  
  =head2 Common Methods
  
  These methods are intended to be used in the everyday dealing
  of exceptions.
  
  The following assume that the error has been copied into
  a separate scalar:
  
      if ($E = $@) {
          ...
      }
  
  This is not required, but is recommended in case any code
  is called which may reset or alter C<$@>.
  
  =cut
  
  =head3 args
  
      my $array_ref = $E->args;
  
  Provides a reference to the arguments passed to the subroutine
  that died.
  
  =cut
  
  sub args        { return $_[0]->{$PACKAGE}{args}; }
  
  =head3 function
  
      my $sub = $E->function;
  
  The subroutine (including package) that threw the exception.
  
  =cut
  
  sub function   { return $_[0]->{$PACKAGE}{function};  }
  
  =head3 file
  
      my $file = $E->file;
  
  The file in which the error occurred (eg, C<myscript.pl> or
  C<MyTest.pm>).
  
  =cut
  
  sub file        { return $_[0]->{$PACKAGE}{file};  }
  
  =head3 package
  
      my $package = $E->package;
  
  The package from which the exceptional subroutine was called.
  
  =cut
  
  sub package     { return $_[0]->{$PACKAGE}{package}; }
  
  =head3 caller
  
      my $caller = $E->caller;
  
  The subroutine that I<called> the exceptional code.
  
  =cut
  
  sub caller      { return $_[0]->{$PACKAGE}{caller};  }
  
  =head3 line
  
      my $line = $E->line;
  
  The line in C<< $E->file >> where the exceptional code was called.
  
  =cut
  
  sub line        { return $_[0]->{$PACKAGE}{line};  }
  
  =head3 context
  
      my $context = $E->context;
  
  The context in which the subroutine was called by autodie; usually
  the same as the context in which you called the autodying subroutine.
  This can be 'list', 'scalar', or undefined (unknown).  It will never
  be 'void', as C<autodie> always captures the return value in one way
  or another.
  
  For some core functions that always return a scalar value regardless
  of their context (eg, C<chown>), this may be 'scalar', even if you
  used a list context.
  
  =cut
  
  # TODO: The comments above say this can be undefined. Is that actually
  # the case? (With 'system', perhaps?)
  
  sub context     { return $_[0]->{$PACKAGE}{context} }
  
  =head3 return
  
      my $return_value = $E->return;
  
  The value(s) returned by the failed subroutine.  When the subroutine
  was called in a list context, this will always be a reference to an
  array containing the results.  When the subroutine was called in
  a scalar context, this will be the actual scalar returned.
  
  =cut
  
  sub return      { return $_[0]->{$PACKAGE}{return} }
  
  =head3 errno
  
      my $errno = $E->errno;
  
  The value of C<$!> at the time when the exception occurred.
  
  B<NOTE>: This method will leave the main C<autodie::exception> class
  and become part of a role in the future.  You should only call
  C<errno> for exceptions where C<$!> would reasonably have been
  set on failure.
  
  =cut
  
  # TODO: Make errno part of a role.  It doesn't make sense for
  # everything.
  
  sub errno       { return $_[0]->{$PACKAGE}{errno}; }
  
  =head3 eval_error
  
      my $old_eval_error = $E->eval_error;
  
  The contents of C<$@> immediately after autodie triggered an
  exception.  This may be useful when dealing with modules such
  as L<Text::Balanced> that set (but do not throw) C<$@> on error.
  
  =cut
  
  sub eval_error { return $_[0]->{$PACKAGE}{eval_error}; }
  
  =head3 matches
  
      if ( $e->matches('open') ) { ... }
  
      if ( $e ~~ 'open' ) { ... }
  
  C<matches> is used to determine whether a
  given exception matches a particular role.  On Perl 5.10,
  using smart-match (C<~~>) with an C<autodie::exception> object
  will use C<matches> underneath.
  
  An exception is considered to match a string if:
  
  =over 4
  
  =item *
  
  For a string not starting with a colon, the string exactly matches the
  package and subroutine that threw the exception.  For example,
  C<MyModule::log>.  If the string does not contain a package name,
  C<CORE::> is assumed.
  
  =item *
  
  For a string that does start with a colon, if the subroutine
  throwing the exception I<does> that behaviour.  For example, the
  C<CORE::open> subroutine does C<:file>, C<:io> and C<:all>.
  
  See L<autodie/CATEGORIES> for further information.
  
  =back
  
  =cut
  
  {
      my (%cache);
  
      sub matches {
          my ($this, $that) = @_;
  
          # TODO - Handle references
          croak "UNIMPLEMENTED" if ref $that;
  
          my $sub = $this->function;
  
          if ($DEBUG) {
              my $sub2 = $this->function;
              warn "Smart-matching $that against $sub / $sub2\n";
          }
  
          # Direct subname match.
          return 1 if $that eq $sub;
          return 1 if $that !~ /:/ and "CORE::$that" eq $sub;
          return 0 if $that !~ /^:/;
  
          # Cached match / check tags.
          require Fatal;
  
          if (exists $cache{$sub}{$that}) {
              return $cache{$sub}{$that};
          }
  
          # This rather awful looking line checks to see if our sub is in the
          # list of expanded tags, caches it, and returns the result.
  
          return $cache{$sub}{$that} = grep { $_ eq $sub } @{ $this->_expand_tag($that) };
      }
  }
  
  # This exists primarily so that child classes can override or
  # augment it if they wish.
  
  sub _expand_tag {
      my ($this, @args) = @_;
  
      return Fatal->_expand_tag(@args);
  }
  
  =head2 Advanced methods
  
  The following methods, while usable from anywhere, are primarily
  intended for developers wishing to subclass C<autodie::exception>,
  write code that registers custom error messages, or otherwise
  work closely with the C<autodie::exception> model.
  
  =cut
  
  # The table below records customer formatters.
  # TODO - Should this be a package var instead?
  # TODO - Should these be in a completely different file, or
  #        perhaps loaded on demand?  Most formatters will never
  #        get used in most programs.
  
  my %formatter_of = (
      'CORE::close'   => \&_format_close,
      'CORE::open'    => \&_format_open,
      'CORE::dbmopen' => \&_format_dbmopen,
      'CORE::flock'   => \&_format_flock,
  );
  
  # TODO: Our tests only check LOCK_EX | LOCK_NB is properly
  # formatted.  Try other combinations and ensure they work
  # correctly.
  
  sub _format_flock {
      my ($this) = @_;
  
      require Fcntl;
  
      my $filehandle = $this->args->[0];
      my $raw_mode   = $this->args->[1];
  
      my $mode_type;
      my $lock_unlock;
  
      if ($raw_mode & Fcntl::LOCK_EX() ) {
          $lock_unlock = "lock";
          $mode_type = "for exclusive access";
      }
      elsif ($raw_mode & Fcntl::LOCK_SH() ) {
          $lock_unlock = "lock";
          $mode_type = "for shared access";
      }
      elsif ($raw_mode & Fcntl::LOCK_UN() ) {
          $lock_unlock = "unlock";
          $mode_type = "";
      }
      else {
          # I've got no idea what they're trying to do.
          $lock_unlock = "lock";
          $mode_type = "with mode $raw_mode";
      }
  
      my $cooked_filehandle;
  
      if ($filehandle and not ref $filehandle) {
  
          # A package filehandle with a name!
  
          $cooked_filehandle = " $filehandle";
      }
      else {
          # Otherwise we have a scalar filehandle.
  
          $cooked_filehandle = '';
  
      }
  
      local $! = $this->errno;
  
      return "Can't $lock_unlock filehandle$cooked_filehandle $mode_type: $!";
  
  }
  
  # Default formatter for CORE::dbmopen
  sub _format_dbmopen {
      my ($this) = @_;
      my @args   = @{$this->args};
  
      # TODO: Presently, $args flattens out the (usually empty) hash
      # which is passed as the first argument to dbmopen.  This is
      # a bug in our args handling code (taking a reference to it would
      # be better), but for the moment we'll just examine the end of
      # our arguments list for message formatting.
  
      my $mode = $args[-1];
      my $file = $args[-2];
  
      # If we have a mask, then display it in octal, not decimal.
      # We don't do this if it already looks octalish, or doesn't
      # look like a number.
  
      if ($mode =~ /^[^\D0]\d+$/) {
          $mode = sprintf("0%lo", $mode);
      };
  
      local $! = $this->errno;
  
      return "Can't dbmopen(%hash, '$file', $mode): '$!'";
  }
  
  # Default formatter for CORE::close
  
  sub _format_close {
      my ($this) = @_;
      my $close_arg = $this->args->[0];
  
      local $! = $this->errno;
  
      # If we've got an old-style filehandle, mention it.
      if ($close_arg and not ref $close_arg) {
          return "Can't close filehandle '$close_arg': '$!'";
      }
  
      # TODO - This will probably produce an ugly error.  Test and fix.
      return "Can't close($close_arg) filehandle: '$!'";
  
  }
  
  # Default formatter for CORE::open
  
  use constant _FORMAT_OPEN => "Can't open '%s' for %s: '%s'";
  
  sub _format_open_with_mode {
      my ($this, $mode, $file, $error) = @_;
  
      my $wordy_mode;
  
      if    ($mode eq '<')  { $wordy_mode = 'reading';   }
      elsif ($mode eq '>')  { $wordy_mode = 'writing';   }
      elsif ($mode eq '>>') { $wordy_mode = 'appending'; }
  
      return sprintf _FORMAT_OPEN, $file, $wordy_mode, $error if $wordy_mode;
  
      Carp::confess("Internal autodie::exception error: Don't know how to format mode '$mode'.");
  
  }
  
  sub _format_open {
      my ($this) = @_;
  
      my @open_args = @{$this->args};
  
      # Use the default formatter for single-arg and many-arg open
      if (@open_args <= 1 or @open_args >= 4) {
          return $this->format_default;
      }
  
      # For two arg open, we have to extract the mode
      if (@open_args == 2) {
          my ($fh, $file) = @open_args;
  
          if (ref($fh) eq "GLOB") {
              $fh = '$fh';
          }
  
          my ($mode) = $file =~ m{
              ^\s*                # Spaces before mode
              (
                  (?>             # Non-backtracking subexp.
                      <           # Reading
                      |>>?        # Writing/appending
                  )
              )
              [^&]                # Not an ampersand (which means a dup)
          }x;
  
          if (not $mode) {
              # Maybe it's a 2-arg open without any mode at all?
              # Detect the most simple case for this, where our
              # file consists only of word characters.
  
              if ( $file =~ m{^\s*\w+\s*$} ) {
                  $mode = '<'
              }
              else {
                  # Otherwise, we've got no idea what's going on.
                  # Use the default.
                  return $this->format_default;
              }
          }
  
          # Localising $! means perl makes it a pretty error for us.
          local $! = $this->errno;
  
          return $this->_format_open_with_mode($mode, $file, $!);
      }
  
      # Here we must be using three arg open.
  
      my $file = $open_args[2];
  
      local $! = $this->errno;
  
      my $mode = $open_args[1];
  
      local $@;
  
      my $msg = eval { $this->_format_open_with_mode($mode, $file, $!); };
  
      return $msg if $msg;
  
      # Default message (for pipes and odd things)
  
      return "Can't open '$file' with mode '$open_args[1]': '$!'";
  }
  
  =head3 register
  
      autodie::exception->register( 'CORE::open' => \&mysub );
  
  The C<register> method allows for the registration of a message
  handler for a given subroutine.  The full subroutine name including
  the package should be used.
  
  Registered message handlers will receive the C<autodie::exception>
  object as the first parameter.
  
  =cut
  
  sub register {
      my ($class, $symbol, $handler) = @_;
  
      croak "Incorrect call to autodie::register" if @_ != 3;
  
      $formatter_of{$symbol} = $handler;
  
  }
  
  =head3 add_file_and_line
  
      say "Problem occurred",$@->add_file_and_line;
  
  Returns the string C< at %s line %d>, where C<%s> is replaced with
  the filename, and C<%d> is replaced with the line number.
  
  Primarily intended for use by format handlers.
  
  =cut
  
  # Simply produces the file and line number; intended to be added
  # to the end of error messages.
  
  sub add_file_and_line {
      my ($this) = @_;
  
      return sprintf(" at %s line %d\n", $this->file, $this->line);
  }
  
  =head3 stringify
  
      say "The error was: ",$@->stringify;
  
  Formats the error as a human readable string.  Usually there's no
  reason to call this directly, as it is used automatically if an
  C<autodie::exception> object is ever used as a string.
  
  Child classes can override this method to change how they're
  stringified.
  
  =cut
  
  sub stringify {
      my ($this) = @_;
  
      my $call        =  $this->function;
  
      if ($DEBUG) {
          my $dying_pkg   = $this->package;
          my $sub   = $this->function;
          my $caller = $this->caller;
          warn "Stringifing exception for $dying_pkg :: $sub / $caller / $call\n";
      }
  
      # TODO - This isn't using inheritance.  Should it?
      if ( my $sub = $formatter_of{$call} ) {
          return $sub->($this) . $this->add_file_and_line;
      }
  
      return $this->format_default . $this->add_file_and_line;
  
  }
  
  =head3 format_default
  
      my $error_string = $E->format_default;
  
  This produces the default error string for the given exception,
  I<without using any registered message handlers>.  It is primarily
  intended to be called from a message handler when they have
  been passed an exception they don't want to format.
  
  Child classes can override this method to change how default
  messages are formatted.
  
  =cut
  
  # TODO: This produces ugly errors.  Is there any way we can
  # dig around to find the actual variable names?  I know perl 5.10
  # does some dark and terrible magicks to find them for undef warnings.
  
  sub format_default {
      my ($this) = @_;
  
      my $call        =  $this->function;
  
      local $! = $this->errno;
  
      # TODO: This is probably a good idea for CORE, is it
      # a good idea for other subs?
  
      # Trim package name off dying sub for error messages.
      $call =~ s/.*:://;
  
      # Walk through all our arguments, and...
      #
      #   * Replace undef with the word 'undef'
      #   * Replace globs with the string '$fh'
      #   * Quote all other args.
  
      my @args = @{ $this->args() };
  
      foreach my $arg (@args) {
         if    (not defined($arg))   { $arg = 'undef' }
         elsif (ref($arg) eq "GLOB") { $arg = '$fh'   }
         else                        { $arg = qq{'$arg'} }
      }
  
      # Format our beautiful error.
  
      return "Can't $call(".  join(q{, }, @args) . "): $!" ;
  
      # TODO - Handle user-defined errors from hash.
  
      # TODO - Handle default error messages.
  
  }
  
  =head3 new
  
      my $error = autodie::exception->new(
          args => \@_,
          function => "CORE::open",
          errno => $!,
          context => 'scalar',
          return => undef,
      );
  
  
  Creates a new C<autodie::exception> object.  Normally called
  directly from an autodying function.  The C<function> argument
  is required, its the function we were trying to call that
  generated the exception.  The C<args> parameter is optional.
  
  The C<errno> value is optional.  In versions of C<autodie::exception>
  1.99 and earlier the code would try to automatically use the
  current value of C<$!>, but this was unreliable and is no longer
  supported.
  
  Atrributes such as package, file, and caller are determined
  automatically, and cannot be specified.
  
  =cut
  
  sub new {
      my ($class, @args) = @_;
  
      my $this = {};
  
      bless($this,$class);
  
      # I'd love to use EVERY here, but it causes our code to die
      # because it wants to stringify our objects before they're
      # initialised, causing everything to explode.
  
      $this->_init(@args);
  
      return $this;
  }
  
  sub _init {
  
      my ($this, %args) = @_;
  
      # Capturing errno here is not necessarily reliable.
      my $original_errno = $!;
  
      our $init_called = 1;
  
      my $class = ref $this;
  
      # We're going to walk up our call stack, looking for the
      # first thing that doesn't look like our exception
      # code, autodie/Fatal, or some whacky eval.
  
      my ($package, $file, $line, $sub);
  
      my $depth = 0;
  
      while (1) {
          $depth++;
  
          ($package, $file, $line, $sub) = CORE::caller($depth);
  
          # Skip up the call stack until we find something outside
          # of the Fatal/autodie/eval space.
  
          next if $package->isa('Fatal');
          next if $package->isa($class);
          next if $package->isa(__PACKAGE__);
  
          # Anything with the 'autodie::skip' role wants us to skip it.
          # https://github.com/pjf/autodie/issues/15
  
          next if ($package->can('DOES') and $package->DOES('autodie::skip'));
  
          next if $file =~ /^\(eval\s\d+\)$/;
  
          last;
  
      }
  
      # We now have everything correct, *except* for our subroutine
      # name.  If it's __ANON__ or (eval), then we need to keep on
      # digging deeper into our stack to find the real name.  However we
      # don't update our other information, since that will be correct
      # for our current exception.
  
      my $first_guess_subroutine = $sub;
  
      while (defined $sub and $sub =~ /^\(eval\)$|::__ANON__$/) {
          $depth++;
  
          $sub = (CORE::caller($depth))[3];
      }
  
      # If we end up falling out the bottom of our stack, then our
      # __ANON__ guess is the best we can get.  This includes situations
      # where we were called from the top level of a program.
  
      if (not defined $sub) {
          $sub = $first_guess_subroutine;
      }
  
      $this->{$PACKAGE}{package} = $package;
      $this->{$PACKAGE}{file}    = $file;
      $this->{$PACKAGE}{line}    = $line;
      $this->{$PACKAGE}{caller}  = $sub;
      $this->{$PACKAGE}{package} = $package;
  
      $this->{$PACKAGE}{errno}   = $args{errno} || 0;
  
      $this->{$PACKAGE}{context} = $args{context};
      $this->{$PACKAGE}{return}  = $args{return};
      $this->{$PACKAGE}{eval_error}  = $args{eval_error};
  
      $this->{$PACKAGE}{args}    = $args{args} || [];
      $this->{$PACKAGE}{function}= $args{function} or
                croak("$class->new() called without function arg");
  
      return $this;
  
  }
  
  1;
  
  __END__
  
  =head1 SEE ALSO
  
  L<autodie>, L<autodie::exception::system>
  
  =head1 LICENSE
  
  Copyright (C)2008 Paul Fenwick
  
  This is free software.  You may modify and/or redistribute this
  code under the same terms as Perl 5.10 itself, or, at your option,
  any later version of Perl 5.
  
  =head1 AUTHOR
  
  Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
AUTODIE_EXCEPTION

$fatpacked{"autodie/exception/system.pm"} = <<'AUTODIE_EXCEPTION_SYSTEM';
  package autodie::exception::system;
  use 5.008;
  use strict;
  use warnings;
  use base 'autodie::exception';
  use Carp qw(croak);
  
  our $VERSION = '2.20'; # VERSION: Generated by DZP::OurPkg:Version
  
  # ABSTRACT: Exceptions from autodying system().
  
  my $PACKAGE = __PACKAGE__;
  
  =head1 NAME
  
  autodie::exception::system - Exceptions from autodying system().
  
  =head1 SYNOPSIS
  
      eval {
          use autodie qw(system);
  
          system($cmd, @args);
  
      };
  
      if (my $E = $@) {
          say "Ooops!  ",$E->caller," had problems: $@";
      }
  
  
  =head1 DESCRIPTION
  
  This is a L<autodie::exception> class for failures from the
  C<system> command.
  
  Presently there is no way to interrogate an C<autodie::exception::system>
  object for the command, exit status, and other information you'd expect
  such an object to hold.  The interface will be expanded to accommodate
  this in the future.
  
  =cut
  
  sub _init {
      my ($this, %args) = @_;
  
      $this->{$PACKAGE}{message} = $args{message}
          || croak "'message' arg not supplied to autodie::exception::system->new";
  
      return $this->SUPER::_init(%args);
  
  }
  
  =head2 stringify
  
  When stringified, C<autodie::exception::system> objects currently
  use the message generated by L<IPC::System::Simple>.
  
  =cut
  
  sub stringify {
  
      my ($this) = @_;
  
      return $this->{$PACKAGE}{message} . $this->add_file_and_line;
  
  }
  
  1;
  
  __END__
  
  =head1 LICENSE
  
  Copyright (C)2008 Paul Fenwick
  
  This is free software.  You may modify and/or redistribute this
  code under the same terms as Perl 5.10 itself, or, at your option,
  any later version of Perl 5.
  
  =head1 AUTHOR
  
  Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
AUTODIE_EXCEPTION_SYSTEM

$fatpacked{"autodie/hints.pm"} = <<'AUTODIE_HINTS';
  package autodie::hints;
  
  use strict;
  use warnings;
  
  use constant PERL58 => ( $] < 5.009 );
  
  our $VERSION = '2.20'; # VERSION: Generated by DZP::OurPkg:Version
  
  # ABSTRACT: Provide hints about user subroutines to autodie
  
  =head1 NAME
  
  autodie::hints - Provide hints about user subroutines to autodie
  
  =head1 SYNOPSIS
  
      package Your::Module;
  
      our %DOES = ( 'autodie::hints::provider' => 1 );
  
      sub AUTODIE_HINTS {
          return {
              foo => { scalar => HINTS, list => SOME_HINTS },
              bar => { scalar => HINTS, list => MORE_HINTS },
          }
      }
  
      # Later, in your main program...
  
      use Your::Module qw(foo bar);
      use autodie      qw(:default foo bar);
  
      foo();         # succeeds or dies based on scalar hints
  
      # Alternatively, hints can be set on subroutines we've
      # imported.
  
      use autodie::hints;
      use Some::Module qw(think_positive);
  
      BEGIN {
          autodie::hints->set_hints_for(
              \&think_positive,
              {
                  fail => sub { $_[0] <= 0 }
              }
          )
      }
      use autodie qw(think_positive);
  
      think_positive(...);    # Returns positive or dies.
  
  
  =head1 DESCRIPTION
  
  =head2 Introduction
  
  The L<autodie> pragma is very smart when it comes to working with
  Perl's built-in functions.  The behaviour for these functions are
  fixed, and C<autodie> knows exactly how they try to signal failure.
  
  But what about user-defined subroutines from modules?  If you use
  C<autodie> on a user-defined subroutine then it assumes the following
  behaviour to demonstrate failure:
  
  =over
  
  =item *
  
  A false value, in scalar context
  
  =item * 
  
  An empty list, in list context
  
  =item *
  
  A list containing a single undef, in list context
  
  =back
  
  All other return values (including the list of the single zero, and the
  list containing a single empty string) are considered successful.  However,
  real-world code isn't always that easy.  Perhaps the code you're working
  with returns a string containing the word "FAIL" upon failure, or a
  two element list containing C<(undef, "human error message")>.  To make
  autodie work with these sorts of subroutines, we have
  the I<hinting interface>.
  
  The hinting interface allows I<hints> to be provided to C<autodie>
  on how it should detect failure from user-defined subroutines.  While
  these I<can> be provided by the end-user of C<autodie>, they are ideally
  written into the module itself, or into a helper module or sub-class
  of C<autodie> itself.
  
  =head2 What are hints?
  
  A I<hint> is a subroutine or value that is checked against the
  return value of an autodying subroutine.  If the match returns true,
  C<autodie> considers the subroutine to have failed.
  
  If the hint provided is a subroutine, then C<autodie> will pass
  the complete return value to that subroutine.  If the hint is
  any other value, then C<autodie> will smart-match against the
  value provided.  In Perl 5.8.x there is no smart-match operator, and as such
  only subroutine hints are supported in these versions.
  
  Hints can be provided for both scalar and list contexts.  Note
  that an autodying subroutine will never see a void context, as
  C<autodie> always needs to capture the return value for examination.
  Autodying subroutines called in void context act as if they're called
  in a scalar context, but their return value is discarded after it
  has been checked.
  
  =head2 Example hints
  
  Hints may consist of scalars, array references, regular expressions and
  subroutine references.  You can specify different hints for how
  failure should be identified in scalar and list contexts.
  
  These examples apply for use in the C<AUTODIE_HINTS> subroutine and when
  calling C<autodie::hints->set_hints_for()>.
  
  The most common context-specific hints are:
  
          # Scalar failures always return undef:
              {  scalar => undef  }
  
          # Scalar failures return any false value [default expectation]:
              {  scalar => sub { ! $_[0] }  }
  
          # Scalar failures always return zero explicitly:
              {  scalar => '0'  }
  
          # List failures always return an empty list:
              {  list => []  }
  
          # List failures return () or (undef) [default expectation]:
              {  list => sub { ! @_ || @_ == 1 && !defined $_[0] }  }
  
          # List failures return () or a single false value:
              {  list => sub { ! @_ || @_ == 1 && !$_[0] }  }
  
          # List failures return (undef, "some string")
              {  list => sub { @_ == 2 && !defined $_[0] }  }
  
          # Unsuccessful foo() returns 'FAIL' or '_FAIL' in scalar context,
          #                    returns (-1) in list context...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  scalar => qr/^ _? FAIL $/xms,
                  list   => [-1],
              }
          );
  
          # Unsuccessful foo() returns 0 in all contexts...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  scalar => 0,
                  list   => [0],
              }
          );
  
  This "in all contexts" construction is very common, and can be
  abbreviated, using the 'fail' key.  This sets both the C<scalar>
  and C<list> hints to the same value:
  
          # Unsuccessful foo() returns 0 in all contexts...
          autodie::hints->set_hints_for(
              \&foo,
              {
                  fail => sub { @_ == 1 and defined $_[0] and $_[0] == 0 }
              }
  	);
  
          # Unsuccessful think_positive() returns negative number on failure...
          autodie::hints->set_hints_for(
              \&think_positive,
              {
                  fail => sub { $_[0] < 0 }
              }
  	);
  
          # Unsuccessful my_system() returns non-zero on failure...
          autodie::hints->set_hints_for(
              \&my_system,
              {
                  fail => sub { $_[0] != 0 }
              }
  	);
  
  =head1 Manually setting hints from within your program
  
  If you are using a module which returns something special on failure, then
  you can manually create hints for each of the desired subroutines.  Once
  the hints are specified, they are available for all files and modules loaded
  thereafter, thus you can move this work into a module and it will still
  work.
  
  	use Some::Module qw(foo bar);
  	use autodie::hints;
  
  	autodie::hints->set_hints_for(
  		\&foo,
  		{
  			scalar => SCALAR_HINT,
  			list   => LIST_HINT,
  		}
  	);
  	autodie::hints->set_hints_for(
  		\&bar,
                  { fail => SOME_HINT, }
  	);
  
  It is possible to pass either a subroutine reference (recommended) or a fully
  qualified subroutine name as the first argument.  This means you can set hints
  on modules that I<might> get loaded:
  
  	use autodie::hints;
  	autodie::hints->set_hints_for(
  		'Some::Module:bar', { fail => SCALAR_HINT, }
  	);
  
  This technique is most useful when you have a project that uses a
  lot of third-party modules.  You can define all your possible hints
  in one-place.  This can even be in a sub-class of autodie.  For
  example:
  
          package my::autodie;
  
          use parent qw(autodie);
          use autodie::hints;
  
          autodie::hints->set_hints_for(...);
  
          1;
  
  You can now C<use my::autodie>, which will work just like the standard
  C<autodie>, but is now aware of any hints that you've set.
  
  =head1 Adding hints to your module
  
  C<autodie> provides a passive interface to allow you to declare hints for
  your module.  These hints will be found and used by C<autodie> if it
  is loaded, but otherwise have no effect (or dependencies) without autodie.
  To set these, your module needs to declare that it I<does> the
  C<autodie::hints::provider> role.  This can be done by writing your
  own C<DOES> method, using a system such as C<Class::DOES> to handle
  the heavy-lifting for you, or declaring a C<%DOES> package variable
  with a C<autodie::hints::provider> key and a corresponding true value.
  
  Note that checking for a C<%DOES> hash is an C<autodie>-only
  short-cut.  Other modules do not use this mechanism for checking
  roles, although you can use the C<Class::DOES> module from the
  CPAN to allow it.
  
  In addition, you must define a C<AUTODIE_HINTS> subroutine that returns
  a hash-reference containing the hints for your subroutines:
  
          package Your::Module;
  
          # We can use the Class::DOES from the CPAN to declare adherence
          # to a role.
  
          use Class::DOES 'autodie::hints::provider' => 1;
  
          # Alternatively, we can declare the role in %DOES.  Note that
          # this is an autodie specific optimisation, although Class::DOES
          # can be used to promote this to a true role declaration.
  
          our %DOES = ( 'autodie::hints::provider' => 1 );
  
          # Finally, we must define the hints themselves.
  
  	sub AUTODIE_HINTS {
  	    return {
  	        foo => { scalar => HINTS, list => SOME_HINTS },
  	        bar => { scalar => HINTS, list => MORE_HINTS },
  	        baz => { fail => HINTS },
  	    }
  	}
  
  This allows your code to set hints without relying on C<autodie> and
  C<autodie::hints> being loaded, or even installed.  In this way your
  code can do the right thing when C<autodie> is installed, but does not
  need to depend upon it to function.
  
  =head1 Insisting on hints
  
  When a user-defined subroutine is wrapped by C<autodie>, it will
  use hints if they are available, and otherwise reverts to the
  I<default behaviour> described in the introduction of this document.
  This can be problematic if we expect a hint to exist, but (for
  whatever reason) it has not been loaded.
  
  We can ask autodie to I<insist> that a hint be used by prefixing
  an exclamation mark to the start of the subroutine name.  A lone
  exclamation mark indicates that I<all> subroutines after it must
  have hints declared.
  
  	# foo() and bar() must have their hints defined
  	use autodie qw( !foo !bar baz );
  
  	# Everything must have hints (recommended).
  	use autodie qw( ! foo bar baz );
  
  	# bar() and baz() must have their hints defined
  	use autodie qw( foo ! bar baz );
  
          # Enable autodie for all of Perl's supported built-ins,
          # as well as for foo(), bar() and baz().  Everything must
          # have hints.
          use autodie qw( ! :all foo bar baz );
  
  If hints are not available for the specified subroutines, this will cause a
  compile-time error.  Insisting on hints for Perl's built-in functions
  (eg, C<open> and C<close>) is always successful.
  
  Insisting on hints is I<strongly> recommended.
  
  =cut
  
  # TODO: implement regular expression hints
  
  use constant UNDEF_ONLY       => sub { not defined $_[0] };
  use constant EMPTY_OR_UNDEF   => sub {
      ! @_ or
      @_==1 && !defined $_[0]
  };
  
  use constant EMPTY_ONLY     => sub { @_ == 0 };
  use constant EMPTY_OR_FALSE => sub {
      ! @_ or
      @_==1 && !$_[0]
  };
  
  use constant SINGLE_TRUE => sub { @_ == 1 and not $_[0] };
  
  use constant DEFAULT_HINTS => {
      scalar => UNDEF_ONLY,
      list   => EMPTY_OR_UNDEF,
  };
  
  
  use constant HINTS_PROVIDER => 'autodie::hints::provider';
  
  use base qw(Exporter);
  
  our $DEBUG = 0;
  
  # Only ( undef ) is a strange but possible situation for very
  # badly written code.  It's not supported yet.
  
  my %Hints = (
      'File::Copy::copy' => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::move' => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::cp'   => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
      'File::Copy::mv'   => { scalar => SINGLE_TRUE, list => SINGLE_TRUE },
  );
  
  # Start by using Sub::Identify if it exists on this system.
  
  eval { require Sub::Identify; Sub::Identify->import('get_code_info'); };
  
  # If it doesn't exist, we'll define our own.  This code is directly
  # taken from Rafael Garcia's Sub::Identify 0.04, used under the same
  # license as Perl itself.
  
  if ($@) {
      require B;
  
      no warnings 'once';
  
      *get_code_info = sub ($) {
  
          my ($coderef) = @_;
          ref $coderef or return;
          my $cv = B::svref_2object($coderef);
          $cv->isa('B::CV') or return;
          # bail out if GV is undefined
          $cv->GV->isa('B::SPECIAL') and return;
  
          return ($cv->GV->STASH->NAME, $cv->GV->NAME);
      };
  
  }
  
  sub sub_fullname {
      return join( '::', get_code_info( $_[1] ) );
  }
  
  my %Hints_loaded = ();
  
  sub load_hints {
      my ($class, $sub) = @_;
  
      my ($package) = ( $sub =~ /(.*)::/ );
  
      if (not defined $package) {
          require Carp;
          Carp::croak(
              "Internal error in autodie::hints::load_hints - no package found.
          ");
      }
  
      # Do nothing if we've already tried to load hints for
      # this package.
      return if $Hints_loaded{$package}++;
  
      my $hints_available = 0;
  
      {
          no strict 'refs';   ## no critic
  
          if ($package->can('DOES') and $package->DOES(HINTS_PROVIDER) ) {
              $hints_available = 1;
          }
          elsif ( PERL58 and $package->isa(HINTS_PROVIDER) ) {
              $hints_available = 1;
          }
          elsif ( ${"${package}::DOES"}{HINTS_PROVIDER.""} ) {
              $hints_available = 1;
          }
      }
  
      return if not $hints_available;
  
      my %package_hints = %{ $package->AUTODIE_HINTS };
  
      foreach my $sub (keys %package_hints) {
  
          my $hint = $package_hints{$sub};
  
          # Ensure we have a package name.
          $sub = "${package}::$sub" if $sub !~ /::/;
  
          # TODO - Currently we don't check for conflicts, should we?
          $Hints{$sub} = $hint;
  
          $class->normalise_hints(\%Hints, $sub);
      }
  
      return;
  
  }
  
  sub normalise_hints {
      my ($class, $hints, $sub) = @_;
  
      if ( exists $hints->{$sub}->{fail} ) {
  
          if ( exists $hints->{$sub}->{scalar} or
               exists $hints->{$sub}->{list}
          ) {
              # TODO: Turn into a proper diagnostic.
              require Carp;
              local $Carp::CarpLevel = 1;
              Carp::croak("fail hints cannot be provided with either scalar or list hints for $sub");
          }
  
          # Set our scalar and list hints.
  
          $hints->{$sub}->{scalar} = 
          $hints->{$sub}->{list} = delete $hints->{$sub}->{fail};
  
          return;
  
      }
  
      # Check to make sure all our hints exist.
  
      foreach my $hint (qw(scalar list)) {
          if ( not exists $hints->{$sub}->{$hint} ) {
              # TODO: Turn into a proper diagnostic.
              require Carp;
              local $Carp::CarpLevel = 1;
              Carp::croak("$hint hint missing for $sub");
          }
      }
  
      return;
  }
  
  sub get_hints_for {
      my ($class, $sub) = @_;
  
      my $subname = $class->sub_fullname( $sub );
  
      # If we have hints loaded for a sub, then return them.
  
      if ( exists $Hints{ $subname } ) {
          return $Hints{ $subname };
      }
  
      # If not, we try to load them...
  
      $class->load_hints( $subname );
  
      # ...and try again!
  
      if ( exists $Hints{ $subname } ) {
          return $Hints{ $subname };
      }
  
      # It's the caller's responsibility to use defaults if desired.
      # This allows on autodie to insist on hints if needed.
  
      return;
  
  }
  
  sub set_hints_for {
      my ($class, $sub, $hints) = @_;
  
      if (ref $sub) {
          $sub = $class->sub_fullname( $sub );
  
          require Carp;
  
          $sub or Carp::croak("Attempts to set_hints_for unidentifiable subroutine");
      }
  
      if ($DEBUG) {
          warn "autodie::hints: Setting $sub to hints: $hints\n";
      }
  
      $Hints{ $sub } = $hints;
  
      $class->normalise_hints(\%Hints, $sub);
  
      return;
  }
  
  1;
  
  __END__
  
  
  =head1 Diagnostics
  
  =over 4
  
  =item Attempts to set_hints_for unidentifiable subroutine
  
  You've called C<< autodie::hints->set_hints_for() >> using a subroutine
  reference, but that reference could not be resolved back to a
  subroutine name.  It may be an anonymous subroutine (which can't
  be made autodying), or may lack a name for other reasons.
  
  If you receive this error with a subroutine that has a real name,
  then you may have found a bug in autodie.  See L<autodie/BUGS>
  for how to report this.
  
  =item fail hints cannot be provided with either scalar or list hints for %s
  
  When defining hints, you can either supply both C<list> and
  C<scalar> keywords, I<or> you can provide a single C<fail> keyword.
  You can't mix and match them.
  
  =item %s hint missing for %s
  
  You've provided either a C<scalar> hint without supplying
  a C<list> hint, or vice-versa.  You I<must> supply both C<scalar>
  and C<list> hints, I<or> a single C<fail> hint.
  
  =back
  
  =head1 ACKNOWLEDGEMENTS
  
  =over 
  
  =item *
  
  Dr Damian Conway for suggesting the hinting interface and providing the
  example usage.
  
  =item *
  
  Jacinta Richardson for translating much of my ideas into this
  documentation.
  
  =back
  
  =head1 AUTHOR
  
  Copyright 2009, Paul Fenwick E<lt>pjf@perltraining.com.auE<gt>
  
  =head1 LICENSE
  
  This module is free software.  You may distribute it under the
  same terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie>, L<Class::DOES>
  
  =for Pod::Coverage get_hints_for load_hints normalise_hints sub_fullname
  
  =cut
AUTODIE_HINTS

$fatpacked{"autodie/skip.pm"} = <<'AUTODIE_SKIP';
  package autodie::skip;
  use strict;
  use warnings;
  
  our $VERSION = '2.20'; # VERSION
  
  # This package exists purely so people can inherit from it,
  # which isn't at all how roles are supposed to work, but it's
  # how people will use them anyway.
  
  if ($] < 5.010) {
      # Older Perls don't have a native ->DOES.  Let's provide a cheap
      # imitation here.
  
      *DOES = sub { return shift->isa(@_); };
  }
  
  1;
  
  __END__
  
  =head1 NAME
  
  autodie::skip - Skip a package when throwing autodie exceptions
  
  =head1 SYNPOSIS
  
      use parent qw(autodie::skip);
  
  =head1 DESCRIPTION
  
  This dummy class exists to signal that the class inheriting it should
  be skipped when reporting exceptions from autodie.  This is useful
  for utility classes like L<Path::Tiny> that wish to report the location
  of where they were called on failure.
  
  If your class has a better way of doing roles, then you should not
  load this class and instead simply say that your class I<DOES>
  C<autodie::skip> instead.
  
  =head1 AUTHOR
  
  Copyright 2013, Paul Fenwick <pjf@cpan.org>
  
  =head1 LICENSE
  
  This module is free software. You may distribute it under the same
  terms as Perl itself.
  
  =head1 SEE ALSO
  
  L<autodie>, L<autodie::exception>
  
  =cut
AUTODIE_SKIP

s/^  //mg for values %fatpacked;

unshift @INC, sub {
  if (my $fat = $fatpacked{$_[1]}) {
    if ($] < 5.008) {
      return sub {
        return 0 unless length $fat;
        $fat =~ s/^([^\n]*\n?)//;
        $_ = $1;
        return 1;
      };
    }
    open my $fh, '<', \$fat
      or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
    return $fh;
  }
  return
};

} # END OF FATPACK CODE


use strict;
use warnings;
use 5.014;
use YAML;
use File::chdir;
use File::Spec 3.4;
use Path::Tiny;

sub initialize {
	my ($conf) = @_;
	die("you need to remove .vim to proceed.") unless ! path("~/.vim")->is_dir;
	foreach (@{$conf->{script}}) {
		say "running: $_";
		`$_`;
	}
	local $CWD = $ENV{HOME}.'/.vim/bundle';
	foreach (@{$conf->{plugins}}) {
		`git clone -q $_`;
	}
	path("~/.vimrc")->spew_raw($conf->{config});
}

###############################################################################
# YAML Configuration
###############################################################################
my $vim_conf = YAML::Load << '...';
---
name: vim
description: VIM Text Editor and plugins
config: |
  execute pathogen#infect()
  syntax on
  filetype plugin indent on
  
  set background=dark
  colorscheme jellybeans
  set textwidth=79
  set formatoptions=qrn1
  if exists('+colorcolumn')
    set colorcolumn=80
  endif
  set list
  set listchars=tab:.\ ,trail:.,extends:#,nbsp:.
  if has("gui_running")
    set guifont=Ubuntu\ Mono\ 13
    set list
    set listchars=tab:\ ,eol:,extends:#,nbsp:.,trail:.
    set guioptions-=r
    set go-=L
    set go-=T
  endif
  
  set numberwidth=5
  set cursorline
  set cursorcolumn
  set guicursor+=a:blinkon0
  nmap <c-up> ddkP
  nmap <c-down> dd
  nmap + <c-w>+
  nmap _ <c-w>-
  nmap > <c-w>>
  nmap < <c-w><
  vmap <c-up> xkP`[V`]
  vmap <c-down> xp`[V`]
  
  au BufEnter * silent! lcd %:p:h " auto change directory of current file
  au WinLeave * set nocursorline nocursorcolumn
  au WinEnter * set cursorline cursorcolumn
  set cursorline cursorcolumn
  if ! has('gui_running')
      set ttimeoutlen=10
      augroup FastEscape
  	autocmd!
  	au InsertEnter * set timeoutlen=0
  	au InsertLeave * set timeoutlen=1000
      augroup END
  endif
  autocmd GUIEnter * set vb t_vb= " for your GUI
  autocmd VimEnter * set vb t_vb=
packages:
  - vim
  - vim-gtk
plugins:
  - git://github.com/antono/html.vim
  - git://github.com/juvenn/mustache.vim
  - git://github.com/kien/ctrlp.vim
  - git://github.com/klen/python-mode
  - git://github.com/nanotech/jellybeans.vim
  - git://github.com/othree/html5.vim
  - git://github.com/pangloss/vim-javascript
  - git://github.com/rodjek/vim-puppet
  - git://github.com/sickill/vim-pasta
  - git://github.com/tpope/vim-bundler
  - git://github.com/tpope/vim-endwise
  - git://github.com/tpope/vim-eunuch
  - git://github.com/tpope/vim-fugitive
  - git://github.com/tpope/vim-haml
  - git://github.com/tpope/vim-markdown
  - git://github.com/tpope/vim-rails
  - git://github.com/tpope/vim-scriptease
  - git://github.com/tpope/vim-sensible
  - git://github.com/tpope/vim-surround
  - git://github.com/tpope/vim-unimpaired
  - git://github.com/vim-perl/vim-perl
  - git://github.com/vim-ruby/vim-ruby
  - git://github.com/vim-scripts/taglist.vim
  - git://github.com/vimoutliner/vimoutliner
  - git://github.com/bling/vim-airline
  - git://github.com/Yggdroot/indentLine
script:
  - mkdir -p ~/.vim/autoload ~/.vim/bundle
  - curl -Sso ~/.vim/autoload/pathogen.vim https://raw.github.com/tpope/vim-pathogen/master/autoload/pathogen.vim
  - sudo apt-add-repository -y ppa:nmi/vim-snapshots
  - sudo apt-get update
  - sudo apt-get -y install vim vim-gtk ctags vim-doc vim-scripts cscope ttf-dejavu indent
...

###############################################################################
# start this up
###############################################################################
initialize($vim_conf);

__END__

No futher.
